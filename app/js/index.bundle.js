/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/bookmark.js":
/*!*************************!*\
  !*** ./src/bookmark.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");


const bookmark = {
    bookmarkBarElement: window.bookmark_bar,
}

/**
 * Create bookmark item from bookmark nodes
 * @param  {Object} node
 * @return {string} HTML generated by bookmark node
 */
bookmark.create = (node) => {
    const { url, title, children } = node

    if (children) {
        setTimeout(() => bookmark.render(node))
        return ''
    }

    return `
    <a class="item" href="${url}">
        <img src="${chrome.runtime.getURL('/_favicon/')}?pageUrl=${url}">
        <div class="title">${title}</div>
    </a>`
}

/**
 * Create a parent of bookmark, this is a group of bookmark items
 * @param  {Object} node
 * @return {string}      HTML generated by bookmark nodes
 */
bookmark.createParent = (node) => {
    const label = node.title
    const nodes = node.children
    const childs = nodes.map((node) => bookmark.create(node)).join('')
    const parentId = `${label}-${node.parentId || 'root'}`
    const status = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][`bookmark:parent:${parentId}`] || 'open'

    return `
    <div class="parent ${status}">
        <div class="parent-header" data-parent-id="${parentId}">
            <span class="icon icon-folder"></span>
            <div class="label">${label}</div>
        </div>
        <div class="stopgrap"></div>
        <div class="parent-childs">${childs}</div>
    </div>`
}

/**
 * Render bookmark from bookmark node
 * @param  {Object}  node
 * @param  {Boolean} [clear=false] clean bookmark bar before render
 */
bookmark.render = (node, clear = false) => {
    if (clear) {
        bookmark.bookmarkBarElement.innerHTML = ''
    }

    bookmark.bookmarkBarElement.innerHTML += bookmark.createParent(node)
}

/**
 * Toggle open parent
 * @param  {string} id
 */
bookmark.toggleOpenParent = (id) => {
    const open = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][`bookmark:parent:${id}`] === 'close' ? 'open' : 'close'
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][`bookmark:parent:${id}`] = open
    document.querySelector(`[data-parent-id="${id}"]`).parentNode.className = `parent ${open}`
}

bookmark.fetch = () => {
    chrome.topSites.get((tops) => {
        bookmark.render({ children: tops, title: 'Most visited' }, true)

        chrome.bookmarks.getTree((bookmarks) => {
            bookmark.render(bookmarks[0].children[0])
        })
    })
}

bookmark.boot = () => {
    bookmark.bookmarkBarElement.addEventListener('click', ({ target }) => {
        const id = target.getAttribute('data-parent-id') || target.parentNode.getAttribute('data-parent-id')

        if (id) {
            bookmark.toggleOpenParent(id)
        }
    })

    chrome.bookmarks.onCreated.addListener(bookmark.fetch)
    chrome.bookmarks.onRemoved.addListener(bookmark.fetch)
    chrome.bookmarks.onChanged.addListener(bookmark.fetch)
    chrome.bookmarks.onMoved.addListener(bookmark.fetch)

    bookmark.fetch()
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bookmark);


/***/ }),

/***/ "./src/core/emitter.js":
/*!*****************************!*\
  !*** ./src/core/emitter.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/core/logger.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event */ "./src/core/event.js");



const emitter = {
    mounted: {},
}

/**
 * Emitter generator
 * @param name {string} Emitter name
 * @param handle {function} Call one time for setup emitter
 */
emitter.gen = (name, handle) => {
    if (emitter[name] || !/^[a-zA-Z][a-zA-Z0-9_]{0,63}$/.test(name)) {
        return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error(`emitter: Name "${name}" existed or invalid`)
    }

    emitter[name] = () => {
        if (emitter.mounted[name]) {
            return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error(`emitter: Duplicate mount emitter ${name}`)
        }

        handle()

        emitter.mounted[name] = true
    }
}

/**
 * Define emitter
 * ==============
 */

emitter.gen('click', () => {
    function handleClickR(target, domEvent, up = 0) {
        if (up > 5 || !target) {
            return
        }

        const clickEmit = target.getAttribute('click-emit')

        if (!clickEmit) {
            return handleClickR(target.parentElement, domEvent, up + 1)
        }

        const name = clickEmit.split(':')[0]

        let payload = clickEmit.split(':').slice(1).join(':')

        // handle object payload
        if (payload[0] === '?') {
            const payloadObject = {}
            payload
                .slice(1)
                .split('&')
                .forEach((q) => {
                    const [key, value] = q.split('=')
                    if (key === '') {
                        return
                    }
                    payloadObject[key] = value
                })
            payload = payloadObject
        }

        _event__WEBPACK_IMPORTED_MODULE_1__["default"].next(name, payload, { target, domEvent })
    }

    window.document.body.addEventListener('click', (domEvent) => {
        handleClickR(domEvent.target, domEvent)
    })

    _logger__WEBPACK_IMPORTED_MODULE_0__["default"].info('emiter: Click emiter mounted')
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (emitter);


/***/ }),

/***/ "./src/core/event.js":
/*!***************************!*\
  !*** ./src/core/event.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const event = {
    pool: {},
}

event.emit = (name, ...payload) => {
    for (const handle of event.pool[name] ?? []) {
        handle(...payload)
    }
}

event.on = (name, handle) => {
    event.pool[name]?.push(handle) || (event.pool[name] = [handle])
}

event.next = (name, ...payload) => {
    setTimeout(event.emit, 0, name, ...payload)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (event);


/***/ }),

/***/ "./src/core/logger.js":
/*!****************************!*\
  !*** ./src/core/logger.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const LEVEL = ['debug', 'info', 'warning', 'error']

const logger = {
    log_level: 'debug',

    get debug() {
        if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('debug')) {
            return console.debug.bind(window.console, '%cDEBUG  :', 'color: #6c757d')
        }

        return () => undefined
    },

    get info() {
        if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('info')) {
            return console.info.bind(window.console, '%cINFO   :', 'color: #17a2b8')
        }

        return () => undefined
    },

    get warning() {
        if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('warning')) {
            return console.warn.bind(window.console, '%cWARNING:', 'color: #ffc107')
        }

        return () => undefined
    },

    get error() {
        if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('error')) {
            return console.error.bind(window.error, '%cERROR  :', 'color: #dc3545')
        }

        return () => undefined
    },
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (logger);


/***/ }),

/***/ "./src/core/storage.js":
/*!*****************************!*\
  !*** ./src/core/storage.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/core/logger.js");


const storage = {}
const handler = {}

handler.get = (target, key) => {
    if (key === 'origin') {
        return target
    }

    const raw = window.localStorage[key]

    try {
        return raw && JSON.parse(raw)
    } catch (error) {
        return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error('storage: Parse json fail, key: ', key)
    }
}

handler.set = (target, key, value) => {
    window.localStorage[key] = JSON.stringify(value)
    target[key] = value
    return true
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Proxy(storage, handler));


/***/ }),

/***/ "./src/core/util.js":
/*!**************************!*\
  !*** ./src/core/util.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const util = {}

util.throttle = (wait = 200, trailling = true) => {
    const instance = {
        lock: false,
        handle: null,
    }

    instance.execute = (handle, ...args) => {
        instance.handle = handle

        if (instance.lock) {
            return
        }

        instance.lock = true
        instance.handle = null
        instance.handle(...args)

        setTimeout(() => {
            instance.lock = false

            if (trailling && instance.handle) {
                instance.execute(instance.handle, ...args)
            }
        }, wait)
    }

    return instance
}

util.debounce = (wait = 200) => {
    const instance = {
        timeout: null,
    }

    instance.execute = (handle, ...args) => {
        clearTimeout(instance.timeout)
        instance.timeout = setTimeout(handle, wait, ...args)
    }

    return instance
}

util.raf = () => {
    const instance = {
        lock: false,
        handle: null,
    }

    instance.execute = (handle, ...args) => {
        instance.handle = handle

        if (instance.lock) {
            return
        }

        instance.lock = true

        window.requestAnimationFrame(() => {
            instance.lock = false
            instance.handle(...args)
        })
    }

    return instance
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (util);


/***/ }),

/***/ "./src/noter.js":
/*!**********************!*\
  !*** ./src/noter.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/logger */ "./src/core/logger.js");
/* harmony import */ var _core_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/event */ "./src/core/event.js");
/* harmony import */ var _core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/util */ "./src/core/util.js");





const noter = {
    MAX_NOTE_NUMBER: 300,
    MAX_NOTE_CHARACTER: 3000,
    notes: [],

    call: {
        save: _core_util__WEBPACK_IMPORTED_MODULE_3__["default"].debounce(2000),
        move: _core_util__WEBPACK_IMPORTED_MODULE_3__["default"].raf(),
    },
}

noter.fetch = () => {
    chrome.storage.local.get(['notes', 'version']).then((local) => {
        noter.notes = local.notes || []
        noter.render()

        chrome.storage.sync.get().then((sync) => {
            if (sync.version > local.version) {
                noter.notes = []

                for (const [key, value] of Object.entries(sync)) {
                    if (key.startsWith('note:')) {
                        noter.notes.push(value)
                    }
                }

                noter.render()

                chrome.storage.local.set({
                    notes: noter.notes,
                    version: sync.version,
                })

                _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('noter: Render sync data')
            } else if (sync.version < local.version) {
                noter.sync(local.version)
            }
        })
    })
}

noter.save = () => {
    const version = Date.now()

    chrome.storage.local.set({
        notes: noter.notes,
        version,
    })

    noter.sync(version)
    _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('noter: Noter save:', noter.notes)
}

noter.sync = (version) => {
    const update = { version }
    const removes = []

    chrome.storage.sync.get().then((sync) => {
        for (const [key, value] of Object.entries(sync)) {
            if (key.startsWith('note:') && !noter.notes.find((n) => n.id === value.id)) {
                removes.push(key)
            }
        }

        for (const note of noter.notes) {
            update[`note:${note.id}`] = note
        }

        noter.call.save.execute(() => {
            chrome.storage.sync.set(update)
            chrome.storage.sync.remove(removes)
            _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('noter: Sync done', { update, removes })
        })
    })
}

noter.createObject = (note) => {
    const defaultData = {
        msg: '',
        x: Math.floor(Math.random() * (holder.w_w - 500)),
        y: Math.floor(Math.random() * (holder.w_h - 250)),
        w: 300,
        h: 100,
        workspace: _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace,
        status: 'default',
    }

    return Object.assign(defaultData, note)
}

noter.createElement = (note) => {
    const { id, msg, x, y, w, h, status } = note
    const dom = document.createElement('div')

    dom.setAttribute('id', `noteid_${id}`)
    dom.setAttribute('class', 'note')
    dom.setAttribute('style', `transform: translate(${x}px, ${y}px)`)
    dom.setAttribute('note-status', status || 'default')

    dom.innerHTML = `
    <div class="note-controls" note-move-id="${id}">
        <div class="note-remove" click-emit="note_remove:${id}">&times;</div>
    </div>
    <div class="note-rainbow">
        <div click-emit="note_mark:${id},primary"></div>
        <div click-emit="note_mark:${id},success"></div>
        <div click-emit="note_mark:${id},danger"></div>
    </div>
    <textarea
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
        note-editor-id="${id}"
        style="width:${w}px;height:${h - 20}px;"
    >${msg}</textarea>`

    noter.handleHashtag(dom)
    return dom
}

noter.add = (note) => {
    if (noter.notes.length > noter.MAX_NOTE_NUMBER) {
        return window.alert('The maximum number of notes has been reached')
    }

    // New note don't have a id, push it to noter.notes
    if (note.id === undefined) {
        note.id = Date.now().toString()
        noter.notes.push(note)
    }

    // Render html
    window.note_box.appendChild(noter.createElement(note))
}

noter.render = (clear = true, workspace = +_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0) => {
    // Clear before render
    if (clear) {
        window.note_box.innerHTML = ''
    }

    // Loop adding
    for (const note of noter.notes) {
        if (workspace === note.workspace) {
            noter.add(note)
        }
    }

    _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('noter: Render note', noter.notes)
}

noter.checkAndReplaceCode = (textarea) => {
    const string = textarea.value

    holder.code_tables.forEach((code) => {
        const cregex = new RegExp(code.code)

        const result = string.match(cregex)
        if (result) {
            const datas = result.slice(1)

            const oldSelectionStart = textarea.selectionStart
            const oldValue = textarea.value

            let codeValue = code.value

            datas.forEach((data) => {
                codeValue = codeValue.replace('$', data)
            })

            textarea.value = string.replace(cregex, codeValue)

            const newSelectionStart = oldSelectionStart + textarea.value.length - oldValue.length
            textarea.setSelectionRange(newSelectionStart, newSelectionStart)
        }
    })
}

noter.handleHashtag = (dom) => {
    const textarea = dom.querySelector('textarea')
    const line = textarea.value.slice(0, textarea.value.indexOf('\n'))
    let className = 'note'

    if (line.startsWith('# ')) {
        const hashtags = line.slice(2).split(' ').filter((t) => t)
        console.log(hashtags)

        if (hashtags.includes('monospace')) {
            className += ' note-ffm'
        }
    }

    dom.className = className
}

noter.remove = (id) => {
    const index = noter.notes.findIndex((note) => note.id == id)
    noter.notes.splice(index, 1)

    // Remove dom
    const dom = window[`noteid_${id}`]
    dom.parentElement.removeChild(dom)

    noter.save()
}

noter.mark = (id, status) => {
    const note = noter.notes.find((n) => n.id == id)

    if (note.status === status) {
        note.status = 'default'
    } else {
        note.status = status
    }

    window[`noteid_${id}`].setAttribute('note-status', note.status)
    noter.save()
}

noter.handleOnChange = ({ target, key }) => {
    const id = target.getAttribute('note-editor-id')

    if (id) {
        const index = noter.notes.findIndex((note) => note.id == id)

        // Check changed
        if (noter.notes[index].msg === target.value) {
            return
        }

        // Handle note code
        if (key === '=') {
            noter.checkAndReplaceCode(target)
        }

        // Handle note hashtag
        noter.handleHashtag(target.parentElement)

        // Check max note character
        if (target.value.length > noter.MAX_NOTE_CHARACTER) {
            return window.alert('The maximum character has been reached')
        }

        noter.notes[index].msg = target.value
        noter.save()
    }
}

noter.boot = () => {
    const state = {
        resize: false,
        move: false,
        deltaX: 0,
        deltaY: 0,
    }

    _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('note_remove', (id) => {
        noter.remove(id)
    })

    _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('note_mark', (mark) => {
        const [id, status] = mark.split(',')
        noter.mark(id, status)
    })

    // Handle move
    window.note_box.addEventListener('mousedown', (event) => {
        // Prevent right mouse
        if (event.which === 3) {
            return
        }

        const { target } = event

        // Detect resize
        if (target.getAttribute('note-editor-id') !== null) {
            const cx = event.clientX
            const cy = event.clientY
            const noteId = +target.getAttribute('note-editor-id')
            const noteIndex = noter.notes.findIndex((note) => note.id == noteId)
            const note = noter.notes[noteIndex]

            // Detect mouse down over resize btn
            if (note.x + note.w - cx < 15 && note.y + note.h - cy < 15) {
                state.resize = noteId
            }
        }

        if (target.getAttribute('note-move-id') !== null) {
            const noteId = +target.getAttribute('note-move-id')
            const noteIndex = noter.notes.findIndex((note) => note.id == noteId)

            // Fix position mouse vs note
            state.deltaX = event.clientX - noter.notes[noteIndex].x
            state.deltaY = event.clientY - noter.notes[noteIndex].y

            // Start move handle
            state.move = noteId
        }
    })

    window.addEventListener('mousemove', (event) => {
        if (state.move === false) {
            return
        }

        event.preventDefault()

        noter.call.move.execute(() => {
            const dom = window[`noteid_${state.move}`]

            if (dom) {
                const x = Math.min(holder.w_w - 20, Math.max(event.clientX - state.deltaX, 0))
                const y = Math.min(holder.w_h - 20, Math.max(event.clientY - state.deltaY, 0))
                dom.style.transform = `translate(${x}px, ${y}px)`
            }
        })
    })

    window.addEventListener('mouseup', (event) => {
        if (state.move !== false) {
            const x = event.clientX - state.deltaX
            const y = event.clientY - state.deltaY
            const noteIndex = noter.notes.findIndex((note) => note.id == state.move)

            if (noteIndex !== -1) {
                noter.notes[noteIndex].x = x
                noter.notes[noteIndex].y = y
            }

            // End move handle
            state.move = false

            // Save when done move a note
            noter.save()
        } else if (state.resize !== false) {
            const index = noter.notes.findIndex((note) => note.id == state.resize)
            const w = window['noteid_' + state.resize].offsetWidth
            const h = window['noteid_' + state.resize].offsetHeight

            if (index !== -1) {
                noter.notes[index].w = w
                noter.notes[index].h = h
            }

            // End resize handle
            state.resize = false

            // Save when done move a note
            noter.save()
        }
    })

    window.note_box.addEventListener('keyup', noter.handleOnChange)
    window.note_box.addEventListener('paste', noter.handleOnChange)

    // Listen add note
    _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('noter_add', () => {
        noter.add(noter.createObject())
        noter.save()
    })

    // Listen switch workspace
    _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('noter_switch_workspace', () => {
        let workspace = +_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0

        if (workspace > 2) {
            workspace = 0
        } else {
            workspace++
        }

        window.switch_workspace_btn.innerHTML = workspace
        _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace = workspace

        noter.save()
        noter.render()
    })

    // Listen sync notes cross tab
    chrome.storage.onChanged.addListener((change, namespace) => {
        if (!document.hidden || namespace !== 'local' || !change.notes) {
            return
        }

        noter.notes = change.notes.newValue
        noter.render()
    })

    noter.fetch()
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (noter);


/***/ }),

/***/ "./src/prototype.js":
/*!**************************!*\
  !*** ./src/prototype.js ***!
  \**************************/
/***/ (() => {

Array.prototype.sum = function () {
    return this.reduce((acc, e) => acc + e)
}

HTMLElement.prototype.addClass = function (className) {
    const regex = new RegExp(`^${className}$|^${className} | ${className}$| ${className}( )`, 'g')
    if (!regex.test(this.className)) {
        this.className = `${this.className} ${className}`.trim()
    }
}

HTMLElement.prototype.removeClass = function (className) {
    const regex = new RegExp(`^${className}$|^${className} | ${className}$| ${className}( )`, 'g')
    this.className = this.className.replace(regex, '$1').trim()
}

HTMLCollection.prototype.toArray = function () {
    return [...this]
}

NodeList.prototype.toArray = function () {
    return [...this]
}


/***/ }),

/***/ "./src/setting.js":
/*!************************!*\
  !*** ./src/setting.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/event */ "./src/core/event.js");
/* harmony import */ var _noter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noter */ "./src/noter.js");




const PLACEHOLDER_IMG_SRC =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQYV2M4c+bMfwAIMANkq3cY2wAAAABJRU5ErkJggg'
const EXTEND_WALLPAPER_SIZE = 5

const setting = {
    isOpen: false,
    blob_buffer_url: null,
}

setting.render = () => {
    // Render wallpaper
    const walW = window.settings_wallpapers.clientWidth / 6 - 10
    const walH = (walW * holder.w_h) / holder.w_w

    if (_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers.length === 3) {
        // Add placeholder for edit
        _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = [
            ..._core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers,
            ...new Array(EXTEND_WALLPAPER_SIZE).fill({ url: PLACEHOLDER_IMG_SRC }),
        ]
    }

    window.settings_wallpapers.innerHTML = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers.map((wall, index) => {
            let className = 'settings-wall-pre'
            if (wall.active) {
                className += ' active'
            }

            let inner = ''

            if (index >= 3) {
                inner += `<span click-emit="setting_wallpaper_edit:${index}">EDIT</span>`
            }

            return `
            <div
                class="${className}"
                style="width: ${walW}px; height: ${walH}px; background-image: url(${wall.url})"
                click-emit="setting_wallpaper_toggle:${index}"
            >${inner}</div>
            `
        })
        .join('')

    // Render config
    window.setting_config_input.value = JSON.stringify(_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config)
        .replace(/,/g, ',\n')
        .replace('{', '{\n')
        .replace('}', '\n}')

    // Render code table
    window.setting_code_table_input.value = holder.code_tables
        .map((codeTable) => {
            return `${codeTable.code.slice(0, -2)} -> ${codeTable.value}`
        })
        .join('\n')
}

setting.toggle = (state) => {
    if (state === undefined) {
        state = !setting.isOpen
    }

    setting.isOpen = state

    if (state) {
        window.setting_box.removeClass('hidden')
        setting.render()
    } else {
        window.setting_box.addClass('hidden')
    }
}

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_close', () => {
    setting.toggle(false)
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_open', () => {
    setting.toggle(true)
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_backup', () => {
    const now = new Date()

    const data = {}
    data.notes = _noter__WEBPACK_IMPORTED_MODULE_2__["default"].notes
    data.storage = JSON.parse(JSON.stringify(window.localStorage))

    const jsonStringData = JSON.stringify(data)

    const blob = new Blob([jsonStringData], { type: 'text/plain' })

    // Try collect buffer memory
    if (setting.blob_buffer_url !== null) {
        window.URL.revokeObjectURL(setting.blob_buffer_url)
    }

    setting.blob_buffer_url = window.URL.createObjectURL(blob)

    const anc = document.createElement('a')
    anc.href = setting.blob_buffer_url
    anc.download = 'sein-backup-' + now.toLocaleDateString().replace(/\//g, '-') + '.json'
    anc.click()
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_restore', () => {
    const input = document.createElement('input')
    input.type = 'file'

    input.addEventListener(
        'change',
        () => {
            const file = input.files[0]
            const reader = new FileReader()

            reader.addEventListener('load', () => {
                const backupJsonStringData = reader.result
                const backupData = JSON.parse(backupJsonStringData)
                const { notes, storage } = backupData

                _noter__WEBPACK_IMPORTED_MODULE_2__["default"].notes = notes
                _noter__WEBPACK_IMPORTED_MODULE_2__["default"].save()

                Object.keys(storage).forEach((k) => {
                    window.localStorage[k] = storage[k]
                })

                window.alert('Restore completed')
                window.location.reload()
            })

            reader.readAsText(file)
        },
        { once: true },
    )

    input.click()
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_config_save', () => {
    try {
        const config = JSON.parse(window.setting_config_input.value)
        _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config = config
    } catch (error) {
        return window.alert('Parse config error')
    }
    window.alert('Save config success')
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_wallpaper_toggle', (index, { target }) => {
    index = +index

    const wallpapers = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers
    const isActive = target.className.indexOf('active') !== -1

    if (isActive) {
        target.removeClass('active')
    } else {
        target.addClass('active')
    }

    wallpapers[index].active = !isActive

    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = wallpapers
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_wallpaper_edit', (index, { target }) => {
    index = +index

    const input = document.createElement('input')
    input.type = 'file'

    input.addEventListener(
        'change',
        () => {
            const file = input.files[0]
            const reader = new FileReader()

            // Check file size
            if (file.size > 1048576) {
                return window.alert('Image must be less than 1 megabytes')
            }

            reader.addEventListener('load', () => {
                const buffys = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers

                buffys[index].url = reader.result
                _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = buffys

                const item = target.parentElement
                item.style.backgroundImage = `url(${reader.result})`
            })

            reader.readAsDataURL(file)
        },
        { once: true },
    )

    input.click()
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_wallpaper_reset', () => {
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = null
    window.location.reload()
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setting);


/***/ }),

/***/ "./src/wallpaper.js":
/*!**************************!*\
  !*** ./src/wallpaper.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");


let wallpapers = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers

if (!wallpapers) {
    wallpapers = [
        {
            url: `img/w1.jpg`,
            active: true,
        },
        {
            url: `img/w2.jpg`,
            active: true,
        },
        {
            url: `img/w3.jpg`,
            active: true,
        },
    ]

    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = wallpapers
}

wallpapers = wallpapers.filter((w) => w.active)

const wallForShow = wallpapers[Math.floor(Math.random() * wallpapers.length)]

if (wallForShow) {
    window.wall.style.backgroundImage = `url(${wallForShow.url})`

    setTimeout(() => {
        window.wall_ghost_left.style.backgroundImage = `url(${wallForShow.url})`
        window.wall_ghost_right.style.backgroundImage = `url(${wallForShow.url})`
    }, 500)
}


/***/ }),

/***/ "./src/waver.js":
/*!**********************!*\
  !*** ./src/waver.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const waver = {}

waver.add = (x, y) => {
    window.wave_click_box.innerHTML = `
    <div class="wave active" style="transform: translate(${x}px, ${y}px)">
        <div></div>
        <div></div>
        <div></div>
    </div>`
}

window.addEventListener('mouseup', (event) => {
    waver.add(event.clientX, event.clientY)
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (waver);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _prototype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prototype */ "./src/prototype.js");
/* harmony import */ var _prototype__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prototype__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wallpaper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wallpaper */ "./src/wallpaper.js");
/* harmony import */ var _core_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/emitter */ "./src/core/emitter.js");
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/logger */ "./src/core/logger.js");
/* harmony import */ var _noter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./noter */ "./src/noter.js");
/* harmony import */ var _bookmark__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bookmark */ "./src/bookmark.js");
/* harmony import */ var _waver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./waver */ "./src/waver.js");
/* harmony import */ var _setting__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./setting */ "./src/setting.js");










window.holder = {
    w_w: window.document.documentElement.clientWidth,
    w_h: window.document.documentElement.clientHeight,

    code_tables: [
        { code: 'date==', value: new Date().toLocaleDateString() },
        { code: 'time==', value: new Date().toLocaleTimeString() },
        { code: 'now==', value: new Date().toLocaleString() },
        // { code: 'name_(.+?)', value: 'Hi sir, $ <3' },
    ],
}

window.addEventListener('resize', () => {
    holder.w_w = window.document.documentElement.clientWidth
    holder.w_h = window.document.documentElement.clientHeight
})

_noter__WEBPACK_IMPORTED_MODULE_5__["default"].boot()
_bookmark__WEBPACK_IMPORTED_MODULE_6__["default"].boot()
_core_emitter__WEBPACK_IMPORTED_MODULE_2__["default"].click()

_core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].config = _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].config || {
    log_level: 'debug',
}

_core_logger__WEBPACK_IMPORTED_MODULE_4__["default"].log_level = _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].config.log_level
window.switch_workspace_btn.innerHTML = _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].workspace || 0

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YWNrOi8vc2Vpbi8uL3NyYy9jb3JlL2VtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9jb3JlL2V2ZW50LmpzIiwid2VicGFjazovL3NlaW4vLi9zcmMvY29yZS9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9jb3JlL3N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9jb3JlL3V0aWwuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9ub3Rlci5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL3Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL3NldHRpbmcuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy93YWxscGFwZXIuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy93YXZlci5qcyIsIndlYnBhY2s6Ly9zZWluL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3NlaW4vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vc2Vpbi93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vc2Vpbi93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3NlaW4vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdG9yYWdlIGZyb20gJy4vY29yZS9zdG9yYWdlJ1xuXG5jb25zdCBib29rbWFyayA9IHtcbiAgICBib29rbWFya0JhckVsZW1lbnQ6IHdpbmRvdy5ib29rbWFya19iYXIsXG59XG5cbi8qKlxuICogQ3JlYXRlIGJvb2ttYXJrIGl0ZW0gZnJvbSBib29rbWFyayBub2Rlc1xuICogQHBhcmFtICB7T2JqZWN0fSBub2RlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgZ2VuZXJhdGVkIGJ5IGJvb2ttYXJrIG5vZGVcbiAqL1xuYm9va21hcmsuY3JlYXRlID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCB7IHVybCwgdGl0bGUsIGNoaWxkcmVuIH0gPSBub2RlXG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBib29rbWFyay5yZW5kZXIobm9kZSkpXG4gICAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIHJldHVybiBgXG4gICAgPGEgY2xhc3M9XCJpdGVtXCIgaHJlZj1cIiR7dXJsfVwiPlxuICAgICAgICA8aW1nIHNyYz1cIiR7Y2hyb21lLnJ1bnRpbWUuZ2V0VVJMKCcvX2Zhdmljb24vJyl9P3BhZ2VVcmw9JHt1cmx9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPiR7dGl0bGV9PC9kaXY+XG4gICAgPC9hPmBcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXJlbnQgb2YgYm9va21hcmssIHRoaXMgaXMgYSBncm91cCBvZiBib29rbWFyayBpdGVtc1xuICogQHBhcmFtICB7T2JqZWN0fSBub2RlXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgSFRNTCBnZW5lcmF0ZWQgYnkgYm9va21hcmsgbm9kZXNcbiAqL1xuYm9va21hcmsuY3JlYXRlUGFyZW50ID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCBsYWJlbCA9IG5vZGUudGl0bGVcbiAgICBjb25zdCBub2RlcyA9IG5vZGUuY2hpbGRyZW5cbiAgICBjb25zdCBjaGlsZHMgPSBub2Rlcy5tYXAoKG5vZGUpID0+IGJvb2ttYXJrLmNyZWF0ZShub2RlKSkuam9pbignJylcbiAgICBjb25zdCBwYXJlbnRJZCA9IGAke2xhYmVsfS0ke25vZGUucGFyZW50SWQgfHwgJ3Jvb3QnfWBcbiAgICBjb25zdCBzdGF0dXMgPSBzdG9yYWdlW2Bib29rbWFyazpwYXJlbnQ6JHtwYXJlbnRJZH1gXSB8fCAnb3BlbidcblxuICAgIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cInBhcmVudCAke3N0YXR1c31cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhcmVudC1oZWFkZXJcIiBkYXRhLXBhcmVudC1pZD1cIiR7cGFyZW50SWR9XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gaWNvbi1mb2xkZXJcIj48L3NwYW4+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGFiZWxcIj4ke2xhYmVsfTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN0b3BncmFwXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYXJlbnQtY2hpbGRzXCI+JHtjaGlsZHN9PC9kaXY+XG4gICAgPC9kaXY+YFxufVxuXG4vKipcbiAqIFJlbmRlciBib29rbWFyayBmcm9tIGJvb2ttYXJrIG5vZGVcbiAqIEBwYXJhbSAge09iamVjdH0gIG5vZGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtjbGVhcj1mYWxzZV0gY2xlYW4gYm9va21hcmsgYmFyIGJlZm9yZSByZW5kZXJcbiAqL1xuYm9va21hcmsucmVuZGVyID0gKG5vZGUsIGNsZWFyID0gZmFsc2UpID0+IHtcbiAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgYm9va21hcmsuYm9va21hcmtCYXJFbGVtZW50LmlubmVySFRNTCA9ICcnXG4gICAgfVxuXG4gICAgYm9va21hcmsuYm9va21hcmtCYXJFbGVtZW50LmlubmVySFRNTCArPSBib29rbWFyay5jcmVhdGVQYXJlbnQobm9kZSlcbn1cblxuLyoqXG4gKiBUb2dnbGUgb3BlbiBwYXJlbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAqL1xuYm9va21hcmsudG9nZ2xlT3BlblBhcmVudCA9IChpZCkgPT4ge1xuICAgIGNvbnN0IG9wZW4gPSBzdG9yYWdlW2Bib29rbWFyazpwYXJlbnQ6JHtpZH1gXSA9PT0gJ2Nsb3NlJyA/ICdvcGVuJyA6ICdjbG9zZSdcbiAgICBzdG9yYWdlW2Bib29rbWFyazpwYXJlbnQ6JHtpZH1gXSA9IG9wZW5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYXJlbnQtaWQ9XCIke2lkfVwiXWApLnBhcmVudE5vZGUuY2xhc3NOYW1lID0gYHBhcmVudCAke29wZW59YFxufVxuXG5ib29rbWFyay5mZXRjaCA9ICgpID0+IHtcbiAgICBjaHJvbWUudG9wU2l0ZXMuZ2V0KCh0b3BzKSA9PiB7XG4gICAgICAgIGJvb2ttYXJrLnJlbmRlcih7IGNoaWxkcmVuOiB0b3BzLCB0aXRsZTogJ01vc3QgdmlzaXRlZCcgfSwgdHJ1ZSlcblxuICAgICAgICBjaHJvbWUuYm9va21hcmtzLmdldFRyZWUoKGJvb2ttYXJrcykgPT4ge1xuICAgICAgICAgICAgYm9va21hcmsucmVuZGVyKGJvb2ttYXJrc1swXS5jaGlsZHJlblswXSlcbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5ib29rbWFyay5ib290ID0gKCkgPT4ge1xuICAgIGJvb2ttYXJrLmJvb2ttYXJrQmFyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICh7IHRhcmdldCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1wYXJlbnQtaWQnKSB8fCB0YXJnZXQucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFyZW50LWlkJylcblxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGJvb2ttYXJrLnRvZ2dsZU9wZW5QYXJlbnQoaWQpXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgY2hyb21lLmJvb2ttYXJrcy5vbkNyZWF0ZWQuYWRkTGlzdGVuZXIoYm9va21hcmsuZmV0Y2gpXG4gICAgY2hyb21lLmJvb2ttYXJrcy5vblJlbW92ZWQuYWRkTGlzdGVuZXIoYm9va21hcmsuZmV0Y2gpXG4gICAgY2hyb21lLmJvb2ttYXJrcy5vbkNoYW5nZWQuYWRkTGlzdGVuZXIoYm9va21hcmsuZmV0Y2gpXG4gICAgY2hyb21lLmJvb2ttYXJrcy5vbk1vdmVkLmFkZExpc3RlbmVyKGJvb2ttYXJrLmZldGNoKVxuXG4gICAgYm9va21hcmsuZmV0Y2goKVxufVxuXG5leHBvcnQgZGVmYXVsdCBib29rbWFya1xuIiwiaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcidcbmltcG9ydCBldmVudCBmcm9tICcuL2V2ZW50J1xuXG5jb25zdCBlbWl0dGVyID0ge1xuICAgIG1vdW50ZWQ6IHt9LFxufVxuXG4vKipcbiAqIEVtaXR0ZXIgZ2VuZXJhdG9yXG4gKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBFbWl0dGVyIG5hbWVcbiAqIEBwYXJhbSBoYW5kbGUge2Z1bmN0aW9ufSBDYWxsIG9uZSB0aW1lIGZvciBzZXR1cCBlbWl0dGVyXG4gKi9cbmVtaXR0ZXIuZ2VuID0gKG5hbWUsIGhhbmRsZSkgPT4ge1xuICAgIGlmIChlbWl0dGVyW25hbWVdIHx8ICEvXlthLXpBLVpdW2EtekEtWjAtOV9dezAsNjN9JC8udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLmVycm9yKGBlbWl0dGVyOiBOYW1lIFwiJHtuYW1lfVwiIGV4aXN0ZWQgb3IgaW52YWxpZGApXG4gICAgfVxuXG4gICAgZW1pdHRlcltuYW1lXSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGVtaXR0ZXIubW91bnRlZFtuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci5lcnJvcihgZW1pdHRlcjogRHVwbGljYXRlIG1vdW50IGVtaXR0ZXIgJHtuYW1lfWApXG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGUoKVxuXG4gICAgICAgIGVtaXR0ZXIubW91bnRlZFtuYW1lXSA9IHRydWVcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lIGVtaXR0ZXJcbiAqID09PT09PT09PT09PT09XG4gKi9cblxuZW1pdHRlci5nZW4oJ2NsaWNrJywgKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrUih0YXJnZXQsIGRvbUV2ZW50LCB1cCA9IDApIHtcbiAgICAgICAgaWYgKHVwID4gNSB8fCAhdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsaWNrRW1pdCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2NsaWNrLWVtaXQnKVxuXG4gICAgICAgIGlmICghY2xpY2tFbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2xpY2tSKHRhcmdldC5wYXJlbnRFbGVtZW50LCBkb21FdmVudCwgdXAgKyAxKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmFtZSA9IGNsaWNrRW1pdC5zcGxpdCgnOicpWzBdXG5cbiAgICAgICAgbGV0IHBheWxvYWQgPSBjbGlja0VtaXQuc3BsaXQoJzonKS5zbGljZSgxKS5qb2luKCc6JylcblxuICAgICAgICAvLyBoYW5kbGUgb2JqZWN0IHBheWxvYWRcbiAgICAgICAgaWYgKHBheWxvYWRbMF0gPT09ICc/Jykge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZE9iamVjdCA9IHt9XG4gICAgICAgICAgICBwYXlsb2FkXG4gICAgICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcmJylcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgocSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBxLnNwbGl0KCc9JylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRPYmplY3Rba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkT2JqZWN0XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5uZXh0KG5hbWUsIHBheWxvYWQsIHsgdGFyZ2V0LCBkb21FdmVudCB9KVxuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGRvbUV2ZW50KSA9PiB7XG4gICAgICAgIGhhbmRsZUNsaWNrUihkb21FdmVudC50YXJnZXQsIGRvbUV2ZW50KVxuICAgIH0pXG5cbiAgICBsb2dnZXIuaW5mbygnZW1pdGVyOiBDbGljayBlbWl0ZXIgbW91bnRlZCcpXG59KVxuXG5leHBvcnQgZGVmYXVsdCBlbWl0dGVyXG4iLCJjb25zdCBldmVudCA9IHtcbiAgICBwb29sOiB7fSxcbn1cblxuZXZlbnQuZW1pdCA9IChuYW1lLCAuLi5wYXlsb2FkKSA9PiB7XG4gICAgZm9yIChjb25zdCBoYW5kbGUgb2YgZXZlbnQucG9vbFtuYW1lXSA/PyBbXSkge1xuICAgICAgICBoYW5kbGUoLi4ucGF5bG9hZClcbiAgICB9XG59XG5cbmV2ZW50Lm9uID0gKG5hbWUsIGhhbmRsZSkgPT4ge1xuICAgIGV2ZW50LnBvb2xbbmFtZV0/LnB1c2goaGFuZGxlKSB8fCAoZXZlbnQucG9vbFtuYW1lXSA9IFtoYW5kbGVdKVxufVxuXG5ldmVudC5uZXh0ID0gKG5hbWUsIC4uLnBheWxvYWQpID0+IHtcbiAgICBzZXRUaW1lb3V0KGV2ZW50LmVtaXQsIDAsIG5hbWUsIC4uLnBheWxvYWQpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGV2ZW50XG4iLCJjb25zdCBMRVZFTCA9IFsnZGVidWcnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJ11cblxuY29uc3QgbG9nZ2VyID0ge1xuICAgIGxvZ19sZXZlbDogJ2RlYnVnJyxcblxuICAgIGdldCBkZWJ1ZygpIHtcbiAgICAgICAgaWYgKExFVkVMLmluZGV4T2YodGhpcy5sb2dfbGV2ZWwudG9Mb3dlckNhc2UoKSkgPD0gTEVWRUwuaW5kZXhPZignZGVidWcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUuZGVidWcuYmluZCh3aW5kb3cuY29uc29sZSwgJyVjREVCVUcgIDonLCAnY29sb3I6ICM2Yzc1N2QnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZFxuICAgIH0sXG5cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgaWYgKExFVkVMLmluZGV4T2YodGhpcy5sb2dfbGV2ZWwudG9Mb3dlckNhc2UoKSkgPD0gTEVWRUwuaW5kZXhPZignaW5mbycpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS5pbmZvLmJpbmQod2luZG93LmNvbnNvbGUsICclY0lORk8gICA6JywgJ2NvbG9yOiAjMTdhMmI4JylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB1bmRlZmluZWRcbiAgICB9LFxuXG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIGlmIChMRVZFTC5pbmRleE9mKHRoaXMubG9nX2xldmVsLnRvTG93ZXJDYXNlKCkpIDw9IExFVkVMLmluZGV4T2YoJ3dhcm5pbmcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2Fybi5iaW5kKHdpbmRvdy5jb25zb2xlLCAnJWNXQVJOSU5HOicsICdjb2xvcjogI2ZmYzEwNycpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkXG4gICAgfSxcblxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgaWYgKExFVkVMLmluZGV4T2YodGhpcy5sb2dfbGV2ZWwudG9Mb3dlckNhc2UoKSkgPD0gTEVWRUwuaW5kZXhPZignZXJyb3InKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IuYmluZCh3aW5kb3cuZXJyb3IsICclY0VSUk9SICA6JywgJ2NvbG9yOiAjZGMzNTQ1JylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB1bmRlZmluZWRcbiAgICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBsb2dnZXJcbiIsImltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInXG5cbmNvbnN0IHN0b3JhZ2UgPSB7fVxuY29uc3QgaGFuZGxlciA9IHt9XG5cbmhhbmRsZXIuZ2V0ID0gKHRhcmdldCwga2V5KSA9PiB7XG4gICAgaWYgKGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cblxuICAgIGNvbnN0IHJhdyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vba2V5XVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJhdyAmJiBKU09OLnBhcnNlKHJhdylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLmVycm9yKCdzdG9yYWdlOiBQYXJzZSBqc29uIGZhaWwsIGtleTogJywga2V5KVxuICAgIH1cbn1cblxuaGFuZGxlci5zZXQgPSAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiB7XG4gICAgd2luZG93LmxvY2FsU3RvcmFnZVtrZXldID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBQcm94eShzdG9yYWdlLCBoYW5kbGVyKVxuIiwiY29uc3QgdXRpbCA9IHt9XG5cbnV0aWwudGhyb3R0bGUgPSAod2FpdCA9IDIwMCwgdHJhaWxsaW5nID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0ge1xuICAgICAgICBsb2NrOiBmYWxzZSxcbiAgICAgICAgaGFuZGxlOiBudWxsLFxuICAgIH1cblxuICAgIGluc3RhbmNlLmV4ZWN1dGUgPSAoaGFuZGxlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGluc3RhbmNlLmhhbmRsZSA9IGhhbmRsZVxuXG4gICAgICAgIGlmIChpbnN0YW5jZS5sb2NrKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGluc3RhbmNlLmxvY2sgPSB0cnVlXG4gICAgICAgIGluc3RhbmNlLmhhbmRsZSA9IG51bGxcbiAgICAgICAgaW5zdGFuY2UuaGFuZGxlKC4uLmFyZ3MpXG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5sb2NrID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKHRyYWlsbGluZyAmJiBpbnN0YW5jZS5oYW5kbGUpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5leGVjdXRlKGluc3RhbmNlLmhhbmRsZSwgLi4uYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgd2FpdClcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2Vcbn1cblxudXRpbC5kZWJvdW5jZSA9ICh3YWl0ID0gMjAwKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgICAgIHRpbWVvdXQ6IG51bGwsXG4gICAgfVxuXG4gICAgaW5zdGFuY2UuZXhlY3V0ZSA9IChoYW5kbGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLnRpbWVvdXQpXG4gICAgICAgIGluc3RhbmNlLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGhhbmRsZSwgd2FpdCwgLi4uYXJncylcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2Vcbn1cblxudXRpbC5yYWYgPSAoKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgICAgIGxvY2s6IGZhbHNlLFxuICAgICAgICBoYW5kbGU6IG51bGwsXG4gICAgfVxuXG4gICAgaW5zdGFuY2UuZXhlY3V0ZSA9IChoYW5kbGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaW5zdGFuY2UuaGFuZGxlID0gaGFuZGxlXG5cbiAgICAgICAgaWYgKGluc3RhbmNlLmxvY2spIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaW5zdGFuY2UubG9jayA9IHRydWVcblxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmxvY2sgPSBmYWxzZVxuICAgICAgICAgICAgaW5zdGFuY2UuaGFuZGxlKC4uLmFyZ3MpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWxcbiIsImltcG9ydCBzdG9yYWdlIGZyb20gJy4vY29yZS9zdG9yYWdlJ1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2NvcmUvbG9nZ2VyJ1xuaW1wb3J0IGV2ZW50IGZyb20gJy4vY29yZS9ldmVudCdcbmltcG9ydCB1dGlsIGZyb20gJy4vY29yZS91dGlsJ1xuXG5jb25zdCBub3RlciA9IHtcbiAgICBNQVhfTk9URV9OVU1CRVI6IDMwMCxcbiAgICBNQVhfTk9URV9DSEFSQUNURVI6IDMwMDAsXG4gICAgbm90ZXM6IFtdLFxuXG4gICAgY2FsbDoge1xuICAgICAgICBzYXZlOiB1dGlsLmRlYm91bmNlKDIwMDApLFxuICAgICAgICBtb3ZlOiB1dGlsLnJhZigpLFxuICAgIH0sXG59XG5cbm5vdGVyLmZldGNoID0gKCkgPT4ge1xuICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldChbJ25vdGVzJywgJ3ZlcnNpb24nXSkudGhlbigobG9jYWwpID0+IHtcbiAgICAgICAgbm90ZXIubm90ZXMgPSBsb2NhbC5ub3RlcyB8fCBbXVxuICAgICAgICBub3Rlci5yZW5kZXIoKVxuXG4gICAgICAgIGNocm9tZS5zdG9yYWdlLnN5bmMuZ2V0KCkudGhlbigoc3luYykgPT4ge1xuICAgICAgICAgICAgaWYgKHN5bmMudmVyc2lvbiA+IGxvY2FsLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBub3Rlci5ub3RlcyA9IFtdXG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzeW5jKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ25vdGU6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVyLm5vdGVzLnB1c2godmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub3Rlci5yZW5kZXIoKVxuXG4gICAgICAgICAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXM6IG5vdGVyLm5vdGVzLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBzeW5jLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnbm90ZXI6IFJlbmRlciBzeW5jIGRhdGEnKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzeW5jLnZlcnNpb24gPCBsb2NhbC52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgbm90ZXIuc3luYyhsb2NhbC52ZXJzaW9uKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pXG59XG5cbm5vdGVyLnNhdmUgPSAoKSA9PiB7XG4gICAgY29uc3QgdmVyc2lvbiA9IERhdGUubm93KClcblxuICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7XG4gICAgICAgIG5vdGVzOiBub3Rlci5ub3RlcyxcbiAgICAgICAgdmVyc2lvbixcbiAgICB9KVxuXG4gICAgbm90ZXIuc3luYyh2ZXJzaW9uKVxuICAgIGxvZ2dlci5kZWJ1Zygnbm90ZXI6IE5vdGVyIHNhdmU6Jywgbm90ZXIubm90ZXMpXG59XG5cbm5vdGVyLnN5bmMgPSAodmVyc2lvbikgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHsgdmVyc2lvbiB9XG4gICAgY29uc3QgcmVtb3ZlcyA9IFtdXG5cbiAgICBjaHJvbWUuc3RvcmFnZS5zeW5jLmdldCgpLnRoZW4oKHN5bmMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3luYykpIHtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnbm90ZTonKSAmJiAhbm90ZXIubm90ZXMuZmluZCgobikgPT4gbi5pZCA9PT0gdmFsdWUuaWQpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3Zlcy5wdXNoKGtleSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgbm90ZSBvZiBub3Rlci5ub3Rlcykge1xuICAgICAgICAgICAgdXBkYXRlW2Bub3RlOiR7bm90ZS5pZH1gXSA9IG5vdGVcbiAgICAgICAgfVxuXG4gICAgICAgIG5vdGVyLmNhbGwuc2F2ZS5leGVjdXRlKCgpID0+IHtcbiAgICAgICAgICAgIGNocm9tZS5zdG9yYWdlLnN5bmMuc2V0KHVwZGF0ZSlcbiAgICAgICAgICAgIGNocm9tZS5zdG9yYWdlLnN5bmMucmVtb3ZlKHJlbW92ZXMpXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ25vdGVyOiBTeW5jIGRvbmUnLCB7IHVwZGF0ZSwgcmVtb3ZlcyB9KVxuICAgICAgICB9KVxuICAgIH0pXG59XG5cbm5vdGVyLmNyZWF0ZU9iamVjdCA9IChub3RlKSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdERhdGEgPSB7XG4gICAgICAgIG1zZzogJycsXG4gICAgICAgIHg6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChob2xkZXIud193IC0gNTAwKSksXG4gICAgICAgIHk6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChob2xkZXIud19oIC0gMjUwKSksXG4gICAgICAgIHc6IDMwMCxcbiAgICAgICAgaDogMTAwLFxuICAgICAgICB3b3Jrc3BhY2U6IHN0b3JhZ2Uud29ya3NwYWNlLFxuICAgICAgICBzdGF0dXM6ICdkZWZhdWx0JyxcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0RGF0YSwgbm90ZSlcbn1cblxubm90ZXIuY3JlYXRlRWxlbWVudCA9IChub3RlKSA9PiB7XG4gICAgY29uc3QgeyBpZCwgbXNnLCB4LCB5LCB3LCBoLCBzdGF0dXMgfSA9IG5vdGVcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnaWQnLCBgbm90ZWlkXyR7aWR9YClcbiAgICBkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsICdub3RlJylcbiAgICBkb20uc2V0QXR0cmlidXRlKCdzdHlsZScsIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgKVxuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ25vdGUtc3RhdHVzJywgc3RhdHVzIHx8ICdkZWZhdWx0JylcblxuICAgIGRvbS5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cIm5vdGUtY29udHJvbHNcIiBub3RlLW1vdmUtaWQ9XCIke2lkfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibm90ZS1yZW1vdmVcIiBjbGljay1lbWl0PVwibm90ZV9yZW1vdmU6JHtpZH1cIj4mdGltZXM7PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm5vdGUtcmFpbmJvd1wiPlxuICAgICAgICA8ZGl2IGNsaWNrLWVtaXQ9XCJub3RlX21hcms6JHtpZH0scHJpbWFyeVwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsaWNrLWVtaXQ9XCJub3RlX21hcms6JHtpZH0sc3VjY2Vzc1wiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsaWNrLWVtaXQ9XCJub3RlX21hcms6JHtpZH0sZGFuZ2VyXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPHRleHRhcmVhXG4gICAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICAgIGF1dG9jb3JyZWN0PVwib2ZmXCJcbiAgICAgICAgYXV0b2NhcGl0YWxpemU9XCJvZmZcIlxuICAgICAgICBzcGVsbGNoZWNrPVwiZmFsc2VcIlxuICAgICAgICBub3RlLWVkaXRvci1pZD1cIiR7aWR9XCJcbiAgICAgICAgc3R5bGU9XCJ3aWR0aDoke3d9cHg7aGVpZ2h0OiR7aCAtIDIwfXB4O1wiXG4gICAgPiR7bXNnfTwvdGV4dGFyZWE+YFxuXG4gICAgbm90ZXIuaGFuZGxlSGFzaHRhZyhkb20pXG4gICAgcmV0dXJuIGRvbVxufVxuXG5ub3Rlci5hZGQgPSAobm90ZSkgPT4ge1xuICAgIGlmIChub3Rlci5ub3Rlcy5sZW5ndGggPiBub3Rlci5NQVhfTk9URV9OVU1CRVIpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5hbGVydCgnVGhlIG1heGltdW0gbnVtYmVyIG9mIG5vdGVzIGhhcyBiZWVuIHJlYWNoZWQnKVxuICAgIH1cblxuICAgIC8vIE5ldyBub3RlIGRvbid0IGhhdmUgYSBpZCwgcHVzaCBpdCB0byBub3Rlci5ub3Rlc1xuICAgIGlmIChub3RlLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm90ZS5pZCA9IERhdGUubm93KCkudG9TdHJpbmcoKVxuICAgICAgICBub3Rlci5ub3Rlcy5wdXNoKG5vdGUpXG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIGh0bWxcbiAgICB3aW5kb3cubm90ZV9ib3guYXBwZW5kQ2hpbGQobm90ZXIuY3JlYXRlRWxlbWVudChub3RlKSlcbn1cblxubm90ZXIucmVuZGVyID0gKGNsZWFyID0gdHJ1ZSwgd29ya3NwYWNlID0gK3N0b3JhZ2Uud29ya3NwYWNlIHx8IDApID0+IHtcbiAgICAvLyBDbGVhciBiZWZvcmUgcmVuZGVyXG4gICAgaWYgKGNsZWFyKSB7XG4gICAgICAgIHdpbmRvdy5ub3RlX2JveC5pbm5lckhUTUwgPSAnJ1xuICAgIH1cblxuICAgIC8vIExvb3AgYWRkaW5nXG4gICAgZm9yIChjb25zdCBub3RlIG9mIG5vdGVyLm5vdGVzKSB7XG4gICAgICAgIGlmICh3b3Jrc3BhY2UgPT09IG5vdGUud29ya3NwYWNlKSB7XG4gICAgICAgICAgICBub3Rlci5hZGQobm90ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvZ2dlci5kZWJ1Zygnbm90ZXI6IFJlbmRlciBub3RlJywgbm90ZXIubm90ZXMpXG59XG5cbm5vdGVyLmNoZWNrQW5kUmVwbGFjZUNvZGUgPSAodGV4dGFyZWEpID0+IHtcbiAgICBjb25zdCBzdHJpbmcgPSB0ZXh0YXJlYS52YWx1ZVxuXG4gICAgaG9sZGVyLmNvZGVfdGFibGVzLmZvckVhY2goKGNvZGUpID0+IHtcbiAgICAgICAgY29uc3QgY3JlZ2V4ID0gbmV3IFJlZ0V4cChjb2RlLmNvZGUpXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKGNyZWdleClcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXMgPSByZXN1bHQuc2xpY2UoMSlcblxuICAgICAgICAgICAgY29uc3Qgb2xkU2VsZWN0aW9uU3RhcnQgPSB0ZXh0YXJlYS5zZWxlY3Rpb25TdGFydFxuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0ZXh0YXJlYS52YWx1ZVxuXG4gICAgICAgICAgICBsZXQgY29kZVZhbHVlID0gY29kZS52YWx1ZVxuXG4gICAgICAgICAgICBkYXRhcy5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29kZVZhbHVlID0gY29kZVZhbHVlLnJlcGxhY2UoJyQnLCBkYXRhKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdGV4dGFyZWEudmFsdWUgPSBzdHJpbmcucmVwbGFjZShjcmVnZXgsIGNvZGVWYWx1ZSlcblxuICAgICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uU3RhcnQgPSBvbGRTZWxlY3Rpb25TdGFydCArIHRleHRhcmVhLnZhbHVlLmxlbmd0aCAtIG9sZFZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgdGV4dGFyZWEuc2V0U2VsZWN0aW9uUmFuZ2UobmV3U2VsZWN0aW9uU3RhcnQsIG5ld1NlbGVjdGlvblN0YXJ0KVxuICAgICAgICB9XG4gICAgfSlcbn1cblxubm90ZXIuaGFuZGxlSGFzaHRhZyA9IChkb20pID0+IHtcbiAgICBjb25zdCB0ZXh0YXJlYSA9IGRvbS5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpXG4gICAgY29uc3QgbGluZSA9IHRleHRhcmVhLnZhbHVlLnNsaWNlKDAsIHRleHRhcmVhLnZhbHVlLmluZGV4T2YoJ1xcbicpKVxuICAgIGxldCBjbGFzc05hbWUgPSAnbm90ZSdcblxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJyMgJykpIHtcbiAgICAgICAgY29uc3QgaGFzaHRhZ3MgPSBsaW5lLnNsaWNlKDIpLnNwbGl0KCcgJykuZmlsdGVyKCh0KSA9PiB0KVxuICAgICAgICBjb25zb2xlLmxvZyhoYXNodGFncylcblxuICAgICAgICBpZiAoaGFzaHRhZ3MuaW5jbHVkZXMoJ21vbm9zcGFjZScpKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgKz0gJyBub3RlLWZmbSdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRvbS5jbGFzc05hbWUgPSBjbGFzc05hbWVcbn1cblxubm90ZXIucmVtb3ZlID0gKGlkKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBub3Rlci5ub3Rlcy5maW5kSW5kZXgoKG5vdGUpID0+IG5vdGUuaWQgPT0gaWQpXG4gICAgbm90ZXIubm90ZXMuc3BsaWNlKGluZGV4LCAxKVxuXG4gICAgLy8gUmVtb3ZlIGRvbVxuICAgIGNvbnN0IGRvbSA9IHdpbmRvd1tgbm90ZWlkXyR7aWR9YF1cbiAgICBkb20ucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChkb20pXG5cbiAgICBub3Rlci5zYXZlKClcbn1cblxubm90ZXIubWFyayA9IChpZCwgc3RhdHVzKSA9PiB7XG4gICAgY29uc3Qgbm90ZSA9IG5vdGVyLm5vdGVzLmZpbmQoKG4pID0+IG4uaWQgPT0gaWQpXG5cbiAgICBpZiAobm90ZS5zdGF0dXMgPT09IHN0YXR1cykge1xuICAgICAgICBub3RlLnN0YXR1cyA9ICdkZWZhdWx0J1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vdGUuc3RhdHVzID0gc3RhdHVzXG4gICAgfVxuXG4gICAgd2luZG93W2Bub3RlaWRfJHtpZH1gXS5zZXRBdHRyaWJ1dGUoJ25vdGUtc3RhdHVzJywgbm90ZS5zdGF0dXMpXG4gICAgbm90ZXIuc2F2ZSgpXG59XG5cbm5vdGVyLmhhbmRsZU9uQ2hhbmdlID0gKHsgdGFyZ2V0LCBrZXkgfSkgPT4ge1xuICAgIGNvbnN0IGlkID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbm90ZS1lZGl0b3ItaWQnKVxuXG4gICAgaWYgKGlkKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbm90ZXIubm90ZXMuZmluZEluZGV4KChub3RlKSA9PiBub3RlLmlkID09IGlkKVxuXG4gICAgICAgIC8vIENoZWNrIGNoYW5nZWRcbiAgICAgICAgaWYgKG5vdGVyLm5vdGVzW2luZGV4XS5tc2cgPT09IHRhcmdldC52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgbm90ZSBjb2RlXG4gICAgICAgIGlmIChrZXkgPT09ICc9Jykge1xuICAgICAgICAgICAgbm90ZXIuY2hlY2tBbmRSZXBsYWNlQ29kZSh0YXJnZXQpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgbm90ZSBoYXNodGFnXG4gICAgICAgIG5vdGVyLmhhbmRsZUhhc2h0YWcodGFyZ2V0LnBhcmVudEVsZW1lbnQpXG5cbiAgICAgICAgLy8gQ2hlY2sgbWF4IG5vdGUgY2hhcmFjdGVyXG4gICAgICAgIGlmICh0YXJnZXQudmFsdWUubGVuZ3RoID4gbm90ZXIuTUFYX05PVEVfQ0hBUkFDVEVSKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmFsZXJ0KCdUaGUgbWF4aW11bSBjaGFyYWN0ZXIgaGFzIGJlZW4gcmVhY2hlZCcpXG4gICAgICAgIH1cblxuICAgICAgICBub3Rlci5ub3Rlc1tpbmRleF0ubXNnID0gdGFyZ2V0LnZhbHVlXG4gICAgICAgIG5vdGVyLnNhdmUoKVxuICAgIH1cbn1cblxubm90ZXIuYm9vdCA9ICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgcmVzaXplOiBmYWxzZSxcbiAgICAgICAgbW92ZTogZmFsc2UsXG4gICAgICAgIGRlbHRhWDogMCxcbiAgICAgICAgZGVsdGFZOiAwLFxuICAgIH1cblxuICAgIGV2ZW50Lm9uKCdub3RlX3JlbW92ZScsIChpZCkgPT4ge1xuICAgICAgICBub3Rlci5yZW1vdmUoaWQpXG4gICAgfSlcblxuICAgIGV2ZW50Lm9uKCdub3RlX21hcmsnLCAobWFyaykgPT4ge1xuICAgICAgICBjb25zdCBbaWQsIHN0YXR1c10gPSBtYXJrLnNwbGl0KCcsJylcbiAgICAgICAgbm90ZXIubWFyayhpZCwgc3RhdHVzKVxuICAgIH0pXG5cbiAgICAvLyBIYW5kbGUgbW92ZVxuICAgIHdpbmRvdy5ub3RlX2JveC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gUHJldmVudCByaWdodCBtb3VzZVxuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IGV2ZW50XG5cbiAgICAgICAgLy8gRGV0ZWN0IHJlc2l6ZVxuICAgICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZSgnbm90ZS1lZGl0b3ItaWQnKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3ggPSBldmVudC5jbGllbnRYXG4gICAgICAgICAgICBjb25zdCBjeSA9IGV2ZW50LmNsaWVudFlcbiAgICAgICAgICAgIGNvbnN0IG5vdGVJZCA9ICt0YXJnZXQuZ2V0QXR0cmlidXRlKCdub3RlLWVkaXRvci1pZCcpXG4gICAgICAgICAgICBjb25zdCBub3RlSW5kZXggPSBub3Rlci5ub3Rlcy5maW5kSW5kZXgoKG5vdGUpID0+IG5vdGUuaWQgPT0gbm90ZUlkKVxuICAgICAgICAgICAgY29uc3Qgbm90ZSA9IG5vdGVyLm5vdGVzW25vdGVJbmRleF1cblxuICAgICAgICAgICAgLy8gRGV0ZWN0IG1vdXNlIGRvd24gb3ZlciByZXNpemUgYnRuXG4gICAgICAgICAgICBpZiAobm90ZS54ICsgbm90ZS53IC0gY3ggPCAxNSAmJiBub3RlLnkgKyBub3RlLmggLSBjeSA8IDE1KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucmVzaXplID0gbm90ZUlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZSgnbm90ZS1tb3ZlLWlkJykgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVJZCA9ICt0YXJnZXQuZ2V0QXR0cmlidXRlKCdub3RlLW1vdmUtaWQnKVxuICAgICAgICAgICAgY29uc3Qgbm90ZUluZGV4ID0gbm90ZXIubm90ZXMuZmluZEluZGV4KChub3RlKSA9PiBub3RlLmlkID09IG5vdGVJZClcblxuICAgICAgICAgICAgLy8gRml4IHBvc2l0aW9uIG1vdXNlIHZzIG5vdGVcbiAgICAgICAgICAgIHN0YXRlLmRlbHRhWCA9IGV2ZW50LmNsaWVudFggLSBub3Rlci5ub3Rlc1tub3RlSW5kZXhdLnhcbiAgICAgICAgICAgIHN0YXRlLmRlbHRhWSA9IGV2ZW50LmNsaWVudFkgLSBub3Rlci5ub3Rlc1tub3RlSW5kZXhdLnlcblxuICAgICAgICAgICAgLy8gU3RhcnQgbW92ZSBoYW5kbGVcbiAgICAgICAgICAgIHN0YXRlLm1vdmUgPSBub3RlSWRcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5tb3ZlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgICAgbm90ZXIuY2FsbC5tb3ZlLmV4ZWN1dGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9tID0gd2luZG93W2Bub3RlaWRfJHtzdGF0ZS5tb3ZlfWBdXG5cbiAgICAgICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oaG9sZGVyLndfdyAtIDIwLCBNYXRoLm1heChldmVudC5jbGllbnRYIC0gc3RhdGUuZGVsdGFYLCAwKSlcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4oaG9sZGVyLndfaCAtIDIwLCBNYXRoLm1heChldmVudC5jbGllbnRZIC0gc3RhdGUuZGVsdGFZLCAwKSlcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5tb3ZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFggLSBzdGF0ZS5kZWx0YVhcbiAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZIC0gc3RhdGUuZGVsdGFZXG4gICAgICAgICAgICBjb25zdCBub3RlSW5kZXggPSBub3Rlci5ub3Rlcy5maW5kSW5kZXgoKG5vdGUpID0+IG5vdGUuaWQgPT0gc3RhdGUubW92ZSlcblxuICAgICAgICAgICAgaWYgKG5vdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBub3Rlci5ub3Rlc1tub3RlSW5kZXhdLnggPSB4XG4gICAgICAgICAgICAgICAgbm90ZXIubm90ZXNbbm90ZUluZGV4XS55ID0geVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbmQgbW92ZSBoYW5kbGVcbiAgICAgICAgICAgIHN0YXRlLm1vdmUgPSBmYWxzZVxuXG4gICAgICAgICAgICAvLyBTYXZlIHdoZW4gZG9uZSBtb3ZlIGEgbm90ZVxuICAgICAgICAgICAgbm90ZXIuc2F2ZSgpXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUucmVzaXplICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBub3Rlci5ub3Rlcy5maW5kSW5kZXgoKG5vdGUpID0+IG5vdGUuaWQgPT0gc3RhdGUucmVzaXplKVxuICAgICAgICAgICAgY29uc3QgdyA9IHdpbmRvd1snbm90ZWlkXycgKyBzdGF0ZS5yZXNpemVdLm9mZnNldFdpZHRoXG4gICAgICAgICAgICBjb25zdCBoID0gd2luZG93Wydub3RlaWRfJyArIHN0YXRlLnJlc2l6ZV0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBub3Rlci5ub3Rlc1tpbmRleF0udyA9IHdcbiAgICAgICAgICAgICAgICBub3Rlci5ub3Rlc1tpbmRleF0uaCA9IGhcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5kIHJlc2l6ZSBoYW5kbGVcbiAgICAgICAgICAgIHN0YXRlLnJlc2l6ZSA9IGZhbHNlXG5cbiAgICAgICAgICAgIC8vIFNhdmUgd2hlbiBkb25lIG1vdmUgYSBub3RlXG4gICAgICAgICAgICBub3Rlci5zYXZlKClcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICB3aW5kb3cubm90ZV9ib3guYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBub3Rlci5oYW5kbGVPbkNoYW5nZSlcbiAgICB3aW5kb3cubm90ZV9ib3guYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBub3Rlci5oYW5kbGVPbkNoYW5nZSlcblxuICAgIC8vIExpc3RlbiBhZGQgbm90ZVxuICAgIGV2ZW50Lm9uKCdub3Rlcl9hZGQnLCAoKSA9PiB7XG4gICAgICAgIG5vdGVyLmFkZChub3Rlci5jcmVhdGVPYmplY3QoKSlcbiAgICAgICAgbm90ZXIuc2F2ZSgpXG4gICAgfSlcblxuICAgIC8vIExpc3RlbiBzd2l0Y2ggd29ya3NwYWNlXG4gICAgZXZlbnQub24oJ25vdGVyX3N3aXRjaF93b3Jrc3BhY2UnLCAoKSA9PiB7XG4gICAgICAgIGxldCB3b3Jrc3BhY2UgPSArc3RvcmFnZS53b3Jrc3BhY2UgfHwgMFxuXG4gICAgICAgIGlmICh3b3Jrc3BhY2UgPiAyKSB7XG4gICAgICAgICAgICB3b3Jrc3BhY2UgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3Jrc3BhY2UrK1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LnN3aXRjaF93b3Jrc3BhY2VfYnRuLmlubmVySFRNTCA9IHdvcmtzcGFjZVxuICAgICAgICBzdG9yYWdlLndvcmtzcGFjZSA9IHdvcmtzcGFjZVxuXG4gICAgICAgIG5vdGVyLnNhdmUoKVxuICAgICAgICBub3Rlci5yZW5kZXIoKVxuICAgIH0pXG5cbiAgICAvLyBMaXN0ZW4gc3luYyBub3RlcyBjcm9zcyB0YWJcbiAgICBjaHJvbWUuc3RvcmFnZS5vbkNoYW5nZWQuYWRkTGlzdGVuZXIoKGNoYW5nZSwgbmFtZXNwYWNlKSA9PiB7XG4gICAgICAgIGlmICghZG9jdW1lbnQuaGlkZGVuIHx8IG5hbWVzcGFjZSAhPT0gJ2xvY2FsJyB8fCAhY2hhbmdlLm5vdGVzKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIG5vdGVyLm5vdGVzID0gY2hhbmdlLm5vdGVzLm5ld1ZhbHVlXG4gICAgICAgIG5vdGVyLnJlbmRlcigpXG4gICAgfSlcblxuICAgIG5vdGVyLmZldGNoKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90ZXJcbiIsIkFycmF5LnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKChhY2MsIGUpID0+IGFjYyArIGUpXG59XG5cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4ke2NsYXNzTmFtZX0kfF4ke2NsYXNzTmFtZX0gfCAke2NsYXNzTmFtZX0kfCAke2NsYXNzTmFtZX0oIClgLCAnZycpXG4gICAgaWYgKCFyZWdleC50ZXN0KHRoaXMuY2xhc3NOYW1lKSkge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGAke3RoaXMuY2xhc3NOYW1lfSAke2NsYXNzTmFtZX1gLnRyaW0oKVxuICAgIH1cbn1cblxuSFRNTEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7Y2xhc3NOYW1lfSR8XiR7Y2xhc3NOYW1lfSB8ICR7Y2xhc3NOYW1lfSR8ICR7Y2xhc3NOYW1lfSggKWAsICdnJylcbiAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UocmVnZXgsICckMScpLnRyaW0oKVxufVxuXG5IVE1MQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXNdXG59XG5cbk5vZGVMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbLi4udGhpc11cbn1cbiIsImltcG9ydCBzdG9yYWdlIGZyb20gJy4vY29yZS9zdG9yYWdlJ1xuaW1wb3J0IGV2ZW50IGZyb20gJy4vY29yZS9ldmVudCdcbmltcG9ydCBub3RlciBmcm9tICcuL25vdGVyJ1xuXG5jb25zdCBQTEFDRUhPTERFUl9JTUdfU1JDID1cbiAgICAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQURVbEVRVlFZVjJNNGMrYk1md0FJTUFOa3EzY1kyd0FBQUFCSlJVNUVya0pnZ2cnXG5jb25zdCBFWFRFTkRfV0FMTFBBUEVSX1NJWkUgPSA1XG5cbmNvbnN0IHNldHRpbmcgPSB7XG4gICAgaXNPcGVuOiBmYWxzZSxcbiAgICBibG9iX2J1ZmZlcl91cmw6IG51bGwsXG59XG5cbnNldHRpbmcucmVuZGVyID0gKCkgPT4ge1xuICAgIC8vIFJlbmRlciB3YWxscGFwZXJcbiAgICBjb25zdCB3YWxXID0gd2luZG93LnNldHRpbmdzX3dhbGxwYXBlcnMuY2xpZW50V2lkdGggLyA2IC0gMTBcbiAgICBjb25zdCB3YWxIID0gKHdhbFcgKiBob2xkZXIud19oKSAvIGhvbGRlci53X3dcblxuICAgIGlmIChzdG9yYWdlLndhbGxwYXBlcnMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIC8vIEFkZCBwbGFjZWhvbGRlciBmb3IgZWRpdFxuICAgICAgICBzdG9yYWdlLndhbGxwYXBlcnMgPSBbXG4gICAgICAgICAgICAuLi5zdG9yYWdlLndhbGxwYXBlcnMsXG4gICAgICAgICAgICAuLi5uZXcgQXJyYXkoRVhURU5EX1dBTExQQVBFUl9TSVpFKS5maWxsKHsgdXJsOiBQTEFDRUhPTERFUl9JTUdfU1JDIH0pLFxuICAgICAgICBdXG4gICAgfVxuXG4gICAgd2luZG93LnNldHRpbmdzX3dhbGxwYXBlcnMuaW5uZXJIVE1MID0gc3RvcmFnZS53YWxscGFwZXJzXG4gICAgICAgIC5tYXAoKHdhbGwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gJ3NldHRpbmdzLXdhbGwtcHJlJ1xuICAgICAgICAgICAgaWYgKHdhbGwuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lICs9ICcgYWN0aXZlJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaW5uZXIgPSAnJ1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMykge1xuICAgICAgICAgICAgICAgIGlubmVyICs9IGA8c3BhbiBjbGljay1lbWl0PVwic2V0dGluZ193YWxscGFwZXJfZWRpdDoke2luZGV4fVwiPkVESVQ8L3NwYW4+YFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiJHtjbGFzc05hbWV9XCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cIndpZHRoOiAke3dhbFd9cHg7IGhlaWdodDogJHt3YWxIfXB4OyBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJHt3YWxsLnVybH0pXCJcbiAgICAgICAgICAgICAgICBjbGljay1lbWl0PVwic2V0dGluZ193YWxscGFwZXJfdG9nZ2xlOiR7aW5kZXh9XCJcbiAgICAgICAgICAgID4ke2lubmVyfTwvZGl2PlxuICAgICAgICAgICAgYFxuICAgICAgICB9KVxuICAgICAgICAuam9pbignJylcblxuICAgIC8vIFJlbmRlciBjb25maWdcbiAgICB3aW5kb3cuc2V0dGluZ19jb25maWdfaW5wdXQudmFsdWUgPSBKU09OLnN0cmluZ2lmeShzdG9yYWdlLmNvbmZpZylcbiAgICAgICAgLnJlcGxhY2UoLywvZywgJyxcXG4nKVxuICAgICAgICAucmVwbGFjZSgneycsICd7XFxuJylcbiAgICAgICAgLnJlcGxhY2UoJ30nLCAnXFxufScpXG5cbiAgICAvLyBSZW5kZXIgY29kZSB0YWJsZVxuICAgIHdpbmRvdy5zZXR0aW5nX2NvZGVfdGFibGVfaW5wdXQudmFsdWUgPSBob2xkZXIuY29kZV90YWJsZXNcbiAgICAgICAgLm1hcCgoY29kZVRhYmxlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7Y29kZVRhYmxlLmNvZGUuc2xpY2UoMCwgLTIpfSAtPiAke2NvZGVUYWJsZS52YWx1ZX1gXG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxufVxuXG5zZXR0aW5nLnRvZ2dsZSA9IChzdGF0ZSkgPT4ge1xuICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0YXRlID0gIXNldHRpbmcuaXNPcGVuXG4gICAgfVxuXG4gICAgc2V0dGluZy5pc09wZW4gPSBzdGF0ZVxuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHdpbmRvdy5zZXR0aW5nX2JveC5yZW1vdmVDbGFzcygnaGlkZGVuJylcbiAgICAgICAgc2V0dGluZy5yZW5kZXIoKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5zZXR0aW5nX2JveC5hZGRDbGFzcygnaGlkZGVuJylcbiAgICB9XG59XG5cbmV2ZW50Lm9uKCdzZXR0aW5nX2Nsb3NlJywgKCkgPT4ge1xuICAgIHNldHRpbmcudG9nZ2xlKGZhbHNlKVxufSlcblxuZXZlbnQub24oJ3NldHRpbmdfb3BlbicsICgpID0+IHtcbiAgICBzZXR0aW5nLnRvZ2dsZSh0cnVlKVxufSlcblxuZXZlbnQub24oJ3NldHRpbmdfYmFja3VwJywgKCkgPT4ge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcblxuICAgIGNvbnN0IGRhdGEgPSB7fVxuICAgIGRhdGEubm90ZXMgPSBub3Rlci5ub3Rlc1xuICAgIGRhdGEuc3RvcmFnZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkod2luZG93LmxvY2FsU3RvcmFnZSkpXG5cbiAgICBjb25zdCBqc29uU3RyaW5nRGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpXG5cbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2pzb25TdHJpbmdEYXRhXSwgeyB0eXBlOiAndGV4dC9wbGFpbicgfSlcblxuICAgIC8vIFRyeSBjb2xsZWN0IGJ1ZmZlciBtZW1vcnlcbiAgICBpZiAoc2V0dGluZy5ibG9iX2J1ZmZlcl91cmwgIT09IG51bGwpIHtcbiAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwoc2V0dGluZy5ibG9iX2J1ZmZlcl91cmwpXG4gICAgfVxuXG4gICAgc2V0dGluZy5ibG9iX2J1ZmZlcl91cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuXG4gICAgY29uc3QgYW5jID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgYW5jLmhyZWYgPSBzZXR0aW5nLmJsb2JfYnVmZmVyX3VybFxuICAgIGFuYy5kb3dubG9hZCA9ICdzZWluLWJhY2t1cC0nICsgbm93LnRvTG9jYWxlRGF0ZVN0cmluZygpLnJlcGxhY2UoL1xcLy9nLCAnLScpICsgJy5qc29uJ1xuICAgIGFuYy5jbGljaygpXG59KVxuXG5ldmVudC5vbignc2V0dGluZ19yZXN0b3JlJywgKCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgIGlucHV0LnR5cGUgPSAnZmlsZSdcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdjaGFuZ2UnLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gaW5wdXQuZmlsZXNbMF1cbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcblxuICAgICAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFja3VwSnNvblN0cmluZ0RhdGEgPSByZWFkZXIucmVzdWx0XG4gICAgICAgICAgICAgICAgY29uc3QgYmFja3VwRGF0YSA9IEpTT04ucGFyc2UoYmFja3VwSnNvblN0cmluZ0RhdGEpXG4gICAgICAgICAgICAgICAgY29uc3QgeyBub3Rlcywgc3RvcmFnZSB9ID0gYmFja3VwRGF0YVxuXG4gICAgICAgICAgICAgICAgbm90ZXIubm90ZXMgPSBub3Rlc1xuICAgICAgICAgICAgICAgIG5vdGVyLnNhdmUoKVxuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RvcmFnZSkuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW2tdID0gc3RvcmFnZVtrXVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICB3aW5kb3cuYWxlcnQoJ1Jlc3RvcmUgY29tcGxldGVkJylcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpXG4gICAgICAgIH0sXG4gICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgIClcblxuICAgIGlucHV0LmNsaWNrKClcbn0pXG5cbmV2ZW50Lm9uKCdzZXR0aW5nX2NvbmZpZ19zYXZlJywgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IEpTT04ucGFyc2Uod2luZG93LnNldHRpbmdfY29uZmlnX2lucHV0LnZhbHVlKVxuICAgICAgICBzdG9yYWdlLmNvbmZpZyA9IGNvbmZpZ1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuYWxlcnQoJ1BhcnNlIGNvbmZpZyBlcnJvcicpXG4gICAgfVxuICAgIHdpbmRvdy5hbGVydCgnU2F2ZSBjb25maWcgc3VjY2VzcycpXG59KVxuXG5ldmVudC5vbignc2V0dGluZ193YWxscGFwZXJfdG9nZ2xlJywgKGluZGV4LCB7IHRhcmdldCB9KSA9PiB7XG4gICAgaW5kZXggPSAraW5kZXhcblxuICAgIGNvbnN0IHdhbGxwYXBlcnMgPSBzdG9yYWdlLndhbGxwYXBlcnNcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHRhcmdldC5jbGFzc05hbWUuaW5kZXhPZignYWN0aXZlJykgIT09IC0xXG5cbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICB9XG5cbiAgICB3YWxscGFwZXJzW2luZGV4XS5hY3RpdmUgPSAhaXNBY3RpdmVcblxuICAgIHN0b3JhZ2Uud2FsbHBhcGVycyA9IHdhbGxwYXBlcnNcbn0pXG5cbmV2ZW50Lm9uKCdzZXR0aW5nX3dhbGxwYXBlcl9lZGl0JywgKGluZGV4LCB7IHRhcmdldCB9KSA9PiB7XG4gICAgaW5kZXggPSAraW5kZXhcblxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgIGlucHV0LnR5cGUgPSAnZmlsZSdcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdjaGFuZ2UnLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gaW5wdXQuZmlsZXNbMF1cbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZmlsZSBzaXplXG4gICAgICAgICAgICBpZiAoZmlsZS5zaXplID4gMTA0ODU3Nikge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuYWxlcnQoJ0ltYWdlIG11c3QgYmUgbGVzcyB0aGFuIDEgbWVnYWJ5dGVzJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZnlzID0gc3RvcmFnZS53YWxscGFwZXJzXG5cbiAgICAgICAgICAgICAgICBidWZmeXNbaW5kZXhdLnVybCA9IHJlYWRlci5yZXN1bHRcbiAgICAgICAgICAgICAgICBzdG9yYWdlLndhbGxwYXBlcnMgPSBidWZmeXNcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXQucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke3JlYWRlci5yZXN1bHR9KWBcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpXG4gICAgICAgIH0sXG4gICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgIClcblxuICAgIGlucHV0LmNsaWNrKClcbn0pXG5cbmV2ZW50Lm9uKCdzZXR0aW5nX3dhbGxwYXBlcl9yZXNldCcsICgpID0+IHtcbiAgICBzdG9yYWdlLndhbGxwYXBlcnMgPSBudWxsXG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG59KVxuXG5leHBvcnQgZGVmYXVsdCBzZXR0aW5nXG4iLCJpbXBvcnQgc3RvcmFnZSBmcm9tICcuL2NvcmUvc3RvcmFnZSdcblxubGV0IHdhbGxwYXBlcnMgPSBzdG9yYWdlLndhbGxwYXBlcnNcblxuaWYgKCF3YWxscGFwZXJzKSB7XG4gICAgd2FsbHBhcGVycyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdXJsOiBgaW1nL3cxLmpwZ2AsXG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVybDogYGltZy93Mi5qcGdgLFxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB1cmw6IGBpbWcvdzMuanBnYCxcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICBdXG5cbiAgICBzdG9yYWdlLndhbGxwYXBlcnMgPSB3YWxscGFwZXJzXG59XG5cbndhbGxwYXBlcnMgPSB3YWxscGFwZXJzLmZpbHRlcigodykgPT4gdy5hY3RpdmUpXG5cbmNvbnN0IHdhbGxGb3JTaG93ID0gd2FsbHBhcGVyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB3YWxscGFwZXJzLmxlbmd0aCldXG5cbmlmICh3YWxsRm9yU2hvdykge1xuICAgIHdpbmRvdy53YWxsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHt3YWxsRm9yU2hvdy51cmx9KWBcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cud2FsbF9naG9zdF9sZWZ0LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHt3YWxsRm9yU2hvdy51cmx9KWBcbiAgICAgICAgd2luZG93LndhbGxfZ2hvc3RfcmlnaHQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke3dhbGxGb3JTaG93LnVybH0pYFxuICAgIH0sIDUwMClcbn1cbiIsImNvbnN0IHdhdmVyID0ge31cblxud2F2ZXIuYWRkID0gKHgsIHkpID0+IHtcbiAgICB3aW5kb3cud2F2ZV9jbGlja19ib3guaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJ3YXZlIGFjdGl2ZVwiIHN0eWxlPVwidHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpXCI+XG4gICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDxkaXY+PC9kaXY+XG4gICAgPC9kaXY+YFxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIChldmVudCkgPT4ge1xuICAgIHdhdmVyLmFkZChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKVxufSlcblxuZXhwb3J0IGRlZmF1bHQgd2F2ZXJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgJy4vcHJvdG90eXBlJ1xuaW1wb3J0ICcuL3dhbGxwYXBlcidcbmltcG9ydCBlbWl0dGVyIGZyb20gJy4vY29yZS9lbWl0dGVyJ1xuaW1wb3J0IHN0b3JhZ2UgZnJvbSAnLi9jb3JlL3N0b3JhZ2UnXG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vY29yZS9sb2dnZXInXG5pbXBvcnQgbm90ZXIgZnJvbSAnLi9ub3RlcidcbmltcG9ydCBib29rbWFyayBmcm9tICcuL2Jvb2ttYXJrJ1xuaW1wb3J0ICcuL3dhdmVyJ1xuaW1wb3J0ICcuL3NldHRpbmcnXG5cbndpbmRvdy5ob2xkZXIgPSB7XG4gICAgd193OiB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgIHdfaDogd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsXG5cbiAgICBjb2RlX3RhYmxlczogW1xuICAgICAgICB7IGNvZGU6ICdkYXRlPT0nLCB2YWx1ZTogbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKSB9LFxuICAgICAgICB7IGNvZGU6ICd0aW1lPT0nLCB2YWx1ZTogbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKSB9LFxuICAgICAgICB7IGNvZGU6ICdub3c9PScsIHZhbHVlOiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCkgfSxcbiAgICAgICAgLy8geyBjb2RlOiAnbmFtZV8oLis/KScsIHZhbHVlOiAnSGkgc2lyLCAkIDwzJyB9LFxuICAgIF0sXG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgaG9sZGVyLndfdyA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICBob2xkZXIud19oID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbn0pXG5cbm5vdGVyLmJvb3QoKVxuYm9va21hcmsuYm9vdCgpXG5lbWl0dGVyLmNsaWNrKClcblxuc3RvcmFnZS5jb25maWcgPSBzdG9yYWdlLmNvbmZpZyB8fCB7XG4gICAgbG9nX2xldmVsOiAnZGVidWcnLFxufVxuXG5sb2dnZXIubG9nX2xldmVsID0gc3RvcmFnZS5jb25maWcubG9nX2xldmVsXG53aW5kb3cuc3dpdGNoX3dvcmtzcGFjZV9idG4uaW5uZXJIVE1MID0gc3RvcmFnZS53b3Jrc3BhY2UgfHwgMFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9