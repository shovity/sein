/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/bookmark.js":
/*!*************************!*\
  !*** ./src/bookmark.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");


const bookmark = {
  bookmarkBarElement: window.bookmark_bar,
}

/**
 * Create bookmark item from bookmark nodes
 * @param  {Object} node
 * @return {string} HTML generated by bookmark node
 */
bookmark.create = (node) => {
  const { url, title, children } = node

  if (children) {
    setTimeout(() => bookmark.render(node))
    return ''
  }

  return `
    <a class="item" href="${url}">
        <img src="${chrome.runtime.getURL('/_favicon/')}?pageUrl=${url}">
        <div class="title">${title}</div>
    </a>`
}

/**
 * Create a parent of bookmark, this is a group of bookmark items
 * @param  {Object} node
 * @return {string}      HTML generated by bookmark nodes
 */
bookmark.createParent = (node) => {
  const label = node.title
  const nodes = node.children
  const childs = nodes.map((node) => bookmark.create(node)).join('')
  const parentId = `${label}-${node.parentId || 'root'}`
  const status = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][`bookmark:parent:${parentId}`] || 'open'

  return `
    <div class="parent ${status}">
        <div class="parent-header" data-parent-id="${parentId}">
            <span class="icon icon-folder"></span>
            <div class="label">${label}</div>
        </div>
        <div class="stopgrap"></div>
        <div class="parent-childs">${childs}</div>
    </div>`
}

/**
 * Render bookmark from bookmark node
 * @param  {Object}  node
 * @param  {Boolean} [clear=false] clean bookmark bar before render
 */
bookmark.render = (node, clear = false) => {
  if (clear) {
    bookmark.bookmarkBarElement.innerHTML = ''
  }

  bookmark.bookmarkBarElement.innerHTML += bookmark.createParent(node)
}

/**
 * Toggle open parent
 * @param  {string} id
 */
bookmark.toggleOpenParent = (id) => {
  const open = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][`bookmark:parent:${id}`] === 'close' ? 'open' : 'close'
  _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][`bookmark:parent:${id}`] = open
  document.querySelector(`[data-parent-id="${id}"]`).parentNode.className = `parent ${open}`
}

bookmark.fetch = () => {
  chrome.topSites.get((tops) => {
    bookmark.render({ children: tops, title: 'Most visited' }, true)

    chrome.bookmarks.getTree((bookmarks) => {
      bookmark.render(bookmarks[0].children[0])
    })
  })
}

bookmark.boot = () => {
  bookmark.bookmarkBarElement.addEventListener('click', ({ target }) => {
    const id = target.getAttribute('data-parent-id') || target.parentNode.getAttribute('data-parent-id')

    if (id) {
      bookmark.toggleOpenParent(id)
    }
  })

  chrome.bookmarks.onCreated.addListener(bookmark.fetch)
  chrome.bookmarks.onRemoved.addListener(bookmark.fetch)
  chrome.bookmarks.onChanged.addListener(bookmark.fetch)
  chrome.bookmarks.onMoved.addListener(bookmark.fetch)

  bookmark.fetch()
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bookmark);


/***/ }),

/***/ "./src/core/emitter.js":
/*!*****************************!*\
  !*** ./src/core/emitter.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/core/logger.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event */ "./src/core/event.js");



const emitter = {
  mounted: {},
}

/**
 * Emitter generator
 * @param name {string} Emitter name
 * @param handle {function} Call one time for setup emitter
 */
emitter.gen = (name, handle) => {
  if (emitter[name] || !/^[a-zA-Z][a-zA-Z0-9_]{0,63}$/.test(name)) {
    return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error(`emitter: Name "${name}" existed or invalid`)
  }

  emitter[name] = () => {
    if (emitter.mounted[name]) {
      return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error(`emitter: Duplicate mount emitter ${name}`)
    }

    handle()

    emitter.mounted[name] = true
  }
}

/**
 * Define emitter
 * ==============
 */

emitter.gen('click', () => {
  function handleClickR(target, domEvent, up = 0) {
    if (up > 5 || !target) {
      return
    }

    const clickEmit = target.getAttribute('click-emit')

    if (!clickEmit) {
      return handleClickR(target.parentElement, domEvent, up + 1)
    }

    const name = clickEmit.split(':')[0]

    let payload = clickEmit.split(':').slice(1).join(':')

    // handle object payload
    if (payload[0] === '?') {
      const payloadObject = {}
      payload
        .slice(1)
        .split('&')
        .forEach((q) => {
          const [key, value] = q.split('=')
          if (key === '') {
            return
          }
          payloadObject[key] = value
        })
      payload = payloadObject
    }

    _event__WEBPACK_IMPORTED_MODULE_1__["default"].next(name, payload, { target, domEvent })
  }

  window.document.body.addEventListener('click', (domEvent) => {
    handleClickR(domEvent.target, domEvent)
  })

  _logger__WEBPACK_IMPORTED_MODULE_0__["default"].info('emiter: Click emiter mounted')
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (emitter);


/***/ }),

/***/ "./src/core/event.js":
/*!***************************!*\
  !*** ./src/core/event.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const event = {
  pool: {},
}

event.emit = (name, ...payload) => {
  for (const handle of event.pool[name] ?? []) {
    handle(...payload)
  }
}

event.on = (name, handle) => {
  event.pool[name]?.push(handle) || (event.pool[name] = [handle])
}

event.next = (name, ...payload) => {
  setTimeout(event.emit, 0, name, ...payload)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (event);


/***/ }),

/***/ "./src/core/logger.js":
/*!****************************!*\
  !*** ./src/core/logger.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const LEVEL = ['debug', 'info', 'warning', 'error']

const logger = {
  log_level: 'debug',

  get debug() {
    if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('debug')) {
      return console.debug.bind(window.console, '%cDEBUG  :', 'color: #6c757d')
    }

    return () => undefined
  },

  get info() {
    if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('info')) {
      return console.info.bind(window.console, '%cINFO   :', 'color: #17a2b8')
    }

    return () => undefined
  },

  get warning() {
    if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('warning')) {
      return console.warn.bind(window.console, '%cWARNING:', 'color: #ffc107')
    }

    return () => undefined
  },

  get error() {
    if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('error')) {
      return console.error.bind(window.error, '%cERROR  :', 'color: #dc3545')
    }

    return () => undefined
  },
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (logger);


/***/ }),

/***/ "./src/core/storage.js":
/*!*****************************!*\
  !*** ./src/core/storage.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/core/logger.js");


const storage = {}
const handler = {}

handler.get = (target, key) => {
  if (key === 'origin') {
    return target
  }

  const raw = window.localStorage[key]

  try {
    return raw && JSON.parse(raw)
  } catch (error) {
    return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error('storage: Parse json fail, key: ', key)
  }
}

handler.set = (target, key, value) => {
  window.localStorage[key] = JSON.stringify(value)
  target[key] = value
  return true
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Proxy(storage, handler));


/***/ }),

/***/ "./src/core/util.js":
/*!**************************!*\
  !*** ./src/core/util.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const util = {}

util.throttle = (wait = 200, trailling = true) => {
  const instance = {
    lock: false,
    handle: null,
  }

  instance.execute = (handle, ...args) => {
    instance.handle = handle

    if (instance.lock) {
      return
    }

    instance.lock = true
    instance.handle(...args)
    instance.handle = null

    setTimeout(() => {
      instance.lock = false

      if (trailling && instance.handle) {
        instance.execute(instance.handle, ...args)
      }
    }, wait)
  }

  return instance
}

util.debounce = (wait = 200) => {
  const instance = {
    timeout: null,
  }

  instance.execute = (handle, ...args) => {
    clearTimeout(instance.timeout)
    instance.timeout = setTimeout(handle, wait, ...args)
  }

  return instance
}

util.raf = () => {
  const instance = {
    lock: false,
    handle: null,
  }

  instance.execute = (handle, ...args) => {
    instance.handle = handle

    if (instance.lock) {
      return
    }

    instance.lock = true

    window.requestAnimationFrame(() => {
      instance.lock = false
      instance.handle(...args)
    })
  }

  return instance
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (util);


/***/ }),

/***/ "./src/modal.js":
/*!**********************!*\
  !*** ./src/modal.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const modal = {}

modal.hide = () => {
  window.modal.removeClass('modal-show')
}

modal.show = (content) => {
  window.modal_content.innerHTML = content
  window.modal.addClass('modal-show')
}

window.modal.addEventListener('click', ({ target }) => {
  if (target.id === 'modal') {
    modal.hide()
  }
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (modal);


/***/ }),

/***/ "./src/noter.js":
/*!**********************!*\
  !*** ./src/noter.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/logger */ "./src/core/logger.js");
/* harmony import */ var _core_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/event */ "./src/core/event.js");
/* harmony import */ var _core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/util */ "./src/core/util.js");
/* harmony import */ var _modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modal */ "./src/modal.js");






const noter = {
  pull_cooldown: 10000,

  call: {
    move: _core_util__WEBPACK_IMPORTED_MODULE_3__["default"].raf(),
    sync: _core_util__WEBPACK_IMPORTED_MODULE_3__["default"].throttle(),
    push: _core_util__WEBPACK_IMPORTED_MODULE_3__["default"].debounce(1000),
  },

  version: null,
  eqCodeReady: null,
  notes: [],
}

noter.fetch = async () => {
  const local = await chrome.storage.local.get(['notes', 'version'])

  noter.notes = local.notes || []
  noter.version = local.version
  noter.render()
}

noter.save = () => {
  const version = Date.now()

  chrome.storage.local.set({
    notes: noter.notes,
    version,
  })

  noter.version = version
  noter.call.push.execute(noter.push)

  _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('noter: Noter save:', noter.notes)
}

noter.createObject = (note) => {
  const defaultData = {
    msg: '',
    x: Math.floor(Math.random() * (holder.w_w - 500)),
    y: Math.floor(Math.random() * (holder.w_h - 250)),
    w: 300,
    h: 100,
    workspace: _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0,
    status: 'default',
  }

  return Object.assign(defaultData, note)
}

noter.createElement = (note) => {
  const dom = document.createElement('div')

  dom.setAttribute('id', `noteid_${note.id}`)
  dom.setAttribute('class', 'note')
  dom.setAttribute('style', `transform: translate(${note.x}px, ${note.y}px)`)
  dom.setAttribute('note-status', note.status || 'default')

  dom.innerHTML = `
    <div class="note-controls" note-move-id="${note.id}">
        <div class="note-remove" click-emit="note_remove:${note.id}">&times;</div>
    </div>
    <div class="note-rainbow">
        <div click-emit="note_mark:${note.id},primary"></div>
        <div click-emit="note_mark:${note.id},success"></div>
        <div click-emit="note_mark:${note.id},danger"></div>
    </div>
    <div class="note-editor"
        contenteditable="true"
        spellcheck="false"
        note-editor-id="${note.id}"
        style="width:${note.w}px;height:${note.h - 20}px"
    >${note.msg}</div>`

  noter.handleHashtag(dom)

  return dom
}

noter.add = (note) => {
  // New note don't have a id, push it to noter.notes
  if (note.id === undefined) {
    note.id = Date.now().toString()
    note.updatedAt = Date.now()
    noter.notes.push(note)
  }

  // Render html
  window.note_box.appendChild(noter.createElement(note))
}

noter.render = (clear = true, workspace = +_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0) => {
  // Clear before render
  if (clear) {
    window.note_box.innerHTML = ''
  }

  // Loop adding
  for (const note of noter.notes) {
    if (workspace === note.workspace) {
      noter.add(note)
    }
  }

  _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('noter: Render note', noter.notes)
}

noter.handleEqcode = (editor) => {
  // Insert marker
  const sel = window.getSelection()
  const range = sel.getRangeAt(0)
  const markerEl = document.createElement('span')
  markerEl.id = 'caret-marker'
  markerEl.appendChild(document.createTextNode('\u200B'))
  range.insertNode(markerEl)

  const string = editor.innerHTML

  holder.code_tables.forEach((code) => {
    const cregex = new RegExp(code.code)
    const result = string.match(cregex)

    if (result) {
      // Data embedded in command code ex. 'name_(.+?)=='
      const replaces = result.slice(1)
      let codeValue = code.value

      for (const replace of replaces) {
        codeValue = codeValue.replace('$', replace)
      }

      editor.innerHTML = string.replace(cregex, codeValue)
    }
  })

  // Restore carte and remove marker
  const newMarker = document.getElementById('caret-marker')

  if (newMarker) {
    const newRange = document.createRange()
    newRange.setStartAfter(newMarker)
    newRange.collapse(true)
    newMarker.parentNode.removeChild(newMarker)
    sel.removeAllRanges()
    sel.addRange(newRange)
  }
}

noter.handleHashtag = (dom) => {
  const editor = dom.querySelector('.note-editor')
  const head = editor.innerHTML.slice(0, 256)

  const hashtags = head.match(/#[a-z0-9_]{1,12}/gi) || []
  const classes = ['note']

  if (hashtags.includes('#mono')) {
    classes.push('note-ffm')
  }

  dom.className = classes.join(' ')
}

noter.remove = (id) => {
  const index = noter.notes.findIndex((note) => note.id == id)

  if (_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace === -1 || !noter.notes[index].msg) {
    noter.notes.splice(index, 1)
  } else {
    noter.notes[index].workspace = -1
    noter.notes[index].removeAt = Date.now()
    noter.notes[index].updatedAt = Date.now()
  }

  // Remove dom
  const dom = window[`noteid_${id}`]
  dom.parentElement.removeChild(dom)

  noter.save()
}

noter.mark = (id, status) => {
  const note = noter.notes.find((n) => n.id == id)

  if (note.status === status) {
    note.status = 'default'
  } else {
    note.status = status
  }

  window[`noteid_${id}`].setAttribute('note-status', note.status)
  noter.save()
}

noter.handleOnChange = ({ target, key }) => {
  const id = target.getAttribute('note-editor-id')

  if (id) {
    const index = noter.notes.findIndex((note) => note.id == id)

    // Check changed
    if (noter.notes[index].msg === target.innerHTML) {
      return
    }

    // Handle note hashtag
    noter.handleHashtag(target.parentElement)

    // Handle note code
    if (key === '=') {
      if (noter.eqCodeReady) {
        noter.handleEqcode(target)
        noter.eqCodeReady = false
      } else {
        noter.eqCodeReady = true
      }
    }

    noter.notes[index].msg = target.innerHTML
    noter.notes[index].updatedAt = Date.now()

    noter.save()
  }
}

noter.pull = async () => {
  if (!_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config.sync_url) {
    return
  }

  if (_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].pull_date > Date.now() - noter.pull_cooldown) {
    return
  }

  const [url, secret] = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config.sync_url.split('#')

  const now = Date.now()

  const response = await fetch(`${url}?date=${_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].pull_date || 0}`, {
    method: 'GET',
    headers: {
      'X-Secret': secret,
    },
  })

  const { data } = await response.json()

  if (data?.length) {
    const map = {}
    let shouldRender = false

    for (const note of noter.notes) {
      map[note.id] = note
    }

    for (const { raw: note } of data) {
      if (!map[note.id]?.updatedAt || map[note.id].updatedAt < note.updatedAt) {
        map[note.id] = note
        shouldRender = true
      }
    }

    if (shouldRender) {
      noter.notes = Object.values(map)
      noter.render()
      noter.save()
    }
  }

  _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].pull_date = now
}

noter.push = async () => {
  if (!_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config.sync_url) {
    return
  }

  const notes = noter.notes.filter((note) => {
    return +note.updatedAt > (+_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].push_date || 0) && note.msg
  })

  const now = Date.now()
  const [url, secret] = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config.sync_url.split('#')

  if (notes.length) {
    await fetch(url, {
      method: 'POST',
      body: JSON.stringify({ notes }),
      headers: {
        'Content-Type': 'application/json',
        'X-Secret': secret,
      },
    })
  }

  _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].push_date = now
}

noter.clearTrash = () => {
  if (_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].last_clear_trash > Date.now() - 8e7) {
    return
  }

  _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].last_clear_trash = Date.now()

  noter.notes = noter.notes.filter((note) => {
    if (note.workspace !== -1) {
      return true
    }

    if (note.removeAt > Date.now() - 864e5 * 30) {
      return true
    }
  })

  noter.save()
}

noter.boot = () => {
  const state = {
    resize: false,
    move: false,
    deltaX: 0,
    deltaY: 0,
  }

  _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('note_remove', (id) => {
    noter.remove(id)
  })

  _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('note_mark', (mark) => {
    const [id, status] = mark.split(',')
    noter.mark(id, status)
  })

  // Handle move
  window.note_box.addEventListener('mousedown', (event) => {
    // Prevent right mouse
    if (event.which === 3) {
      return
    }

    const { target } = event

    // Detect resize
    if (target.getAttribute('note-editor-id') !== null) {
      const cx = event.clientX
      const cy = event.clientY
      const noteId = +target.getAttribute('note-editor-id')
      const noteIndex = noter.notes.findIndex((note) => note.id == noteId)
      const note = noter.notes[noteIndex]

      // Detect mouse down over resize btn
      if (note.x + note.w - cx < 15 && note.y + note.h - cy < 15) {
        state.resize = noteId
      }
    }

    if (target.getAttribute('note-move-id') !== null) {
      const noteId = +target.getAttribute('note-move-id')
      const noteIndex = noter.notes.findIndex((note) => note.id == noteId)

      // Fix position mouse vs note
      state.deltaX = event.clientX - noter.notes[noteIndex].x
      state.deltaY = event.clientY - noter.notes[noteIndex].y

      // Start move handle
      state.move = noteId
    }
  })

  window.addEventListener('mousemove', (event) => {
    if (state.move === false) {
      return
    }

    event.preventDefault()

    noter.call.move.execute(() => {
      const dom = window[`noteid_${state.move}`]

      if (dom) {
        const x = Math.min(holder.w_w - 20, Math.max(event.clientX - state.deltaX, 0))
        const y = Math.min(holder.w_h - 20, Math.max(event.clientY - state.deltaY, 0))
        dom.style.transform = `translate(${x}px, ${y}px)`
      }
    })
  })

  window.addEventListener('mouseup', (event) => {
    if (state.move !== false) {
      const x = event.clientX - state.deltaX
      const y = event.clientY - state.deltaY
      const note = noter.notes.find((e) => e.id == state.move)

      if (note) {
        note.x = Math.max(0, Math.min(holder.w_w, x))
        note.y = Math.max(0, Math.min(holder.w_h, y))
        note.updatedAt = Date.now()
      }

      // End move handle
      state.move = false

      // Save when done move a note
      noter.save()
    } else if (state.resize !== false) {
      const note = noter.notes.find((e) => e.id == state.resize)

      if (note) {
        note.w = window['noteid_' + state.resize].offsetWidth
        note.h = window['noteid_' + state.resize].offsetHeight
      }

      // End resize handle
      state.resize = false

      // Save when done move a note
      noter.save()
    }
  })

  window.note_box.addEventListener('keyup', noter.handleOnChange)
  window.note_box.addEventListener('paste', noter.handleOnChange)

  window.note_box.addEventListener('click', ({ target }) => {
    if (target.tagName === 'IMG') {
      _modal__WEBPACK_IMPORTED_MODULE_4__["default"].show(`<img src="${target.src}" style="max-width: calc(100vw - 50px)">`)
    }
  })

  // Listen add note
  _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('noter_add', () => {
    noter.add(noter.createObject())
    noter.save()
  })

  // Listen switch workspace
  _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('noter_switch_workspace', () => {
    let workspace = +_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0

    if (workspace > _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config.number_of_workspace - 2) {
      workspace = -1
    } else {
      workspace++
    }

    window.switch_workspace_btn.innerHTML = workspace === -1 ? '🗑️' : workspace
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace = workspace

    noter.save()
    noter.render()
  })

  // Listen sync notes cross tab
  chrome.storage.onChanged.addListener((change, namespace) => {
    if (namespace !== 'local') {
      return
    }

    noter.call.sync.execute(() => {
      if (change.notes && change.version?.newValue > noter.version) {
        noter.notes = change.notes.newValue
        noter.render()
      }
    })
  })

  noter.fetch().then(async () => {
    noter.clearTrash()
    await noter.push()
    await noter.pull()
  })
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (noter);


/***/ }),

/***/ "./src/prototype.js":
/*!**************************!*\
  !*** ./src/prototype.js ***!
  \**************************/
/***/ (() => {

Array.prototype.sum = function () {
  return this.reduce((acc, e) => acc + e)
}

HTMLElement.prototype.addClass = function (className) {
  const regex = new RegExp(`^${className}$|^${className} | ${className}$| ${className}( )`, 'g')
  if (!regex.test(this.className)) {
    this.className = `${this.className} ${className}`.trim()
  }
}

HTMLElement.prototype.removeClass = function (className) {
  const regex = new RegExp(`^${className}$|^${className} | ${className}$| ${className}( )`, 'g')
  this.className = this.className.replace(regex, '$1').trim()
}

HTMLCollection.prototype.toArray = function () {
  return [...this]
}

NodeList.prototype.toArray = function () {
  return [...this]
}


/***/ }),

/***/ "./src/setting.js":
/*!************************!*\
  !*** ./src/setting.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/event */ "./src/core/event.js");
/* harmony import */ var _noter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noter */ "./src/noter.js");
/* harmony import */ var _wallpaper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wallpaper */ "./src/wallpaper.js");





const setting = {
  isOpen: false,
  blob_buffer_url: null,
}

setting.render = () => {
  // Render wallpaper
  const walW = Math.floor(window.settings_wallpapers.clientWidth / 6 - 11)
  const walH = Math.floor((walW * holder.w_h) / holder.w_w)

  window.settings_wallpapers.innerHTML = Array(12)
    .fill(1)
    .map(() => {
      return `
            <div class="settings-wall-pre"
                style="width: ${walW}px; height: ${walH}px; background-image: url(/img/placeholder.png)"
            ></div>
            `
    })
    .join('')

  chrome.storage.local.get('wallpapers', ({ wallpapers }) => {
    window.settings_wallpapers.innerHTML = wallpapers
      .map((wall, index) => {
        let className = 'settings-wall-pre'

        if (wall.active) {
          className += ' active'
        }

        let inner = ''

        if (wall.editbale) {
          inner += `<span click-emit="setting_wallpaper_edit:${index}">EDIT</span>`
        }

        return `
                <div class="${className}"
                    style="width: ${walW}px; height: ${walH}px; background-image: url(${wall.url})"
                    click-emit="setting_wallpaper_toggle:${index}"
                >${inner}</div>
                `
      })
      .join('')
  })

  // Render config
  window.setting_config_input.value = JSON.stringify(_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config, null, 2)
}

setting.toggle = (state) => {
  if (state === undefined) {
    state = !setting.isOpen
  }

  setting.isOpen = state

  if (state) {
    window.setting_box.removeClass('hidden')
    setting.render()
  } else {
    window.setting_box.addClass('hidden')
  }
}

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_close', () => {
  setting.toggle(false)
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_open', () => {
  setting.toggle(true)
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_backup', async () => {
  const now = new Date()
  const local = await chrome.storage.local.get()
  const data = {}

  data.local = local
  data.storage = window.localStorage

  const blob = new Blob([JSON.stringify(data)], { type: 'text/plain' })
  const url = URL.createObjectURL(blob)
  const anc = document.createElement('a')

  anc.href = url
  anc.download = 'sein-backup-' + now.toLocaleDateString().replace(/\//g, '-') + '.json'

  anc.click()
  URL.revokeObjectURL(url)
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_restore', () => {
  const input = document.createElement('input')
  input.type = 'file'

  input.addEventListener(
    'change',
    () => {
      const file = input.files[0]
      const reader = new FileReader()

      reader.addEventListener('load', async () => {
        const { local, storage, notes } = JSON.parse(reader.result)

        if (storage) {
          for (const key of Object.keys(storage)) {
            window.localStorage[key] = storage[key]
          }
        }

        if (local) {
          await chrome.storage.local.set(local)
        }

        if (notes) {
          _noter__WEBPACK_IMPORTED_MODULE_2__["default"].notes = notes
          _noter__WEBPACK_IMPORTED_MODULE_2__["default"].save()
        }

        window.alert('Restore completed')
        window.location.reload()
      })

      reader.readAsText(file)
    },
    { once: true },
  )

  input.click()
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_config_save', () => {
  try {
    const config = JSON.parse(window.setting_config_input.value)
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config = config
  } catch (error) {
    console.error(error)
    return window.alert('Parse and save config error')
  }

  window.alert('Save config success')
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_wallpaper_toggle', (index, { target }) => {
  index = +index

  chrome.storage.local.get('wallpapers', ({ wallpapers }) => {
    const isActive = target.className.indexOf('active') !== -1

    wallpapers[index].active = !isActive
    _wallpaper__WEBPACK_IMPORTED_MODULE_3__["default"].cache(wallpapers)

    chrome.storage.local.set({
      wallpapers,
    })

    if (isActive) {
      target.removeClass('active')
    } else {
      target.addClass('active')
    }
  })
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_wallpaper_edit', (index, { target }) => {
  index = +index

  const input = document.createElement('input')
  input.type = 'file'

  input.addEventListener(
    'change',
    () => {
      const file = input.files[0]
      const reader = new FileReader()

      reader.addEventListener('load', async () => {
        if (file.type.startsWith('video/')) {
          const video = document.createElement('video')
          const source = document.createElement('source')
          const canvas = document.createElement('canvas')
          const context = canvas.getContext('2d')

          video.className = 'invisible'
          canvas.className = 'invisible'

          source.setAttribute('src', reader.result)
          source.setAttribute('type', file.type)
          video.appendChild(source)
          window.setting_box.appendChild(video)

          video.addEventListener('canplaythrough', () => {
            setTimeout(async () => {
              canvas.width = video.videoWidth
              canvas.height = video.videoHeight
              window.setting_box.appendChild(canvas)

              context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight)

              const { wallpapers } = await chrome.storage.local.get('wallpapers')
              const result = canvas.toDataURL('image/jpeg')

              window.setting_box.removeChild(video)
              window.setting_box.removeChild(canvas)

              wallpapers[index].url = result
              wallpapers[index].video = index

              _wallpaper__WEBPACK_IMPORTED_MODULE_3__["default"].cache(wallpapers)

              chrome.storage.local.set({
                wallpapers,
                [`wallpaper_videos_${index}`]: reader.result,
              })

              const item = target.parentElement
              item.style.backgroundImage = `url(${result})`
            }, 200)
          })

          return
        }

        if (file.type.startsWith('image/')) {
          const { wallpapers } = await chrome.storage.local.get('wallpapers')

          wallpapers[index].url = reader.result

          _wallpaper__WEBPACK_IMPORTED_MODULE_3__["default"].cache(wallpapers)

          chrome.storage.local.set({
            wallpapers,
            [`wallpaper_videos_${index}`]: '',
          })

          const item = target.parentElement
          item.style.backgroundImage = `url(${reader.result})`

          return
        }

        alert('Only accept image or video')
      })

      reader.readAsDataURL(file)
    },
    { once: true },
  )

  input.click()
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setting);


/***/ }),

/***/ "./src/wallpaper.js":
/*!**************************!*\
  !*** ./src/wallpaper.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");


const wallpaper = {
  default: {
    wallpapers: [
      {
        url: `img/w0.jpg`,
        video: 0,
        active: true,
      },
      {
        url: `img/w1.jpg`,
        video: 1,
      },
      {
        url: `img/w2.jpg`,
        video: 2,
      },
    ],
    local: {
      wallpaper_videos_0: 'video/w0.mp4',
      wallpaper_videos_1: 'video/w1.mp4',
      wallpaper_videos_2: 'video/w2.mp4',
    },
  },
}

wallpaper.init = () => {
  const wallpapers = wallpaper.default.wallpapers

  chrome.storage.local.set({
    ...wallpaper.default.local,

    wallpapers: wallpapers.concat(
      Array(9).fill({
        url: `img/placeholder.png`,
        editbale: true,
      }),
    ),
  })

  return wallpaper.cache(wallpapers)
}

wallpaper.cache = (wallpapers) => {
  try {
    const actives = wallpapers.filter((w) => w.active)
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = actives

    return actives
  } catch (error) {
    alert('The value of wallpapers exceeded the quota')
    throw error
  }
}

wallpaper.boot = () => {
  const wallpapers = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers || wallpaper.init()
  const pick = wallpapers[Math.floor(Math.random() * wallpapers.length)]

  if (!pick) {
    return
  }

  window.wall.style.backgroundImage = `url(${pick.url})`

  if (pick.video > -1) {
    setTimeout(() => {
      const key = `wallpaper_videos_${pick.video}`

      chrome.storage.local.get(key, (data) => {
        const source = document.createElement('source')

        source.src = data[key]
        source.type = 'video/mp4'

        window.wall_video.appendChild(source)
      })
    })
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (wallpaper);


/***/ }),

/***/ "./src/waver.js":
/*!**********************!*\
  !*** ./src/waver.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const waver = {}

waver.add = (x, y) => {
  window.wave_click_box.innerHTML = `
    <div class="wave active" style="transform: translate(${x}px, ${y}px)">
        <div></div>
        <div></div>
        <div></div>
    </div>`
}

window.addEventListener('mouseup', (event) => {
  waver.add(event.clientX, event.clientY)
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (waver);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _prototype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prototype */ "./src/prototype.js");
/* harmony import */ var _prototype__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prototype__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wallpaper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wallpaper */ "./src/wallpaper.js");
/* harmony import */ var _core_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/emitter */ "./src/core/emitter.js");
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/logger */ "./src/core/logger.js");
/* harmony import */ var _noter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./noter */ "./src/noter.js");
/* harmony import */ var _bookmark__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bookmark */ "./src/bookmark.js");
/* harmony import */ var _waver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./waver */ "./src/waver.js");
/* harmony import */ var _setting__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./setting */ "./src/setting.js");










window.holder = {
  w_w: window.document.documentElement.clientWidth,
  w_h: window.document.documentElement.clientHeight,

  code_tables: [
    { code: 'date==', value: new Date().toLocaleDateString() },
    { code: 'time==', value: new Date().toLocaleTimeString() },
    { code: 'now==', value: new Date().toLocaleString() },
    { code: 'name_(.+?)==', value: 'Hi sir, $ <3' },
  ],
}

window.addEventListener('resize', () => {
  holder.w_w = window.document.documentElement.clientWidth
  holder.w_h = window.document.documentElement.clientHeight
})

_wallpaper__WEBPACK_IMPORTED_MODULE_1__["default"].boot()
_noter__WEBPACK_IMPORTED_MODULE_5__["default"].boot()
_bookmark__WEBPACK_IMPORTED_MODULE_6__["default"].boot()
_core_emitter__WEBPACK_IMPORTED_MODULE_2__["default"].click()

_core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].config = Object.assign(
  {
    log_level: 'error',
    number_of_workspace: 2,
  },
  _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].config,
)

if (_core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].workspace) {
  if (_core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].workspace === -1) {
    _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].workspace++
  }

  window.switch_workspace_btn.innerHTML = _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].workspace
} else {
  window.switch_workspace_btn.innerHTML = '0'
}

_core_logger__WEBPACK_IMPORTED_MODULE_4__["default"].log_level = _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].config.log_level

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUQsdURBQWM7QUFDZCxtREFBVTtBQUNWLHNEQUFhO0FBQ2IsMkRBQWE7O0FBRWIsNERBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0REFBYztBQUNoQjs7QUFFQSxJQUFJLCtEQUFpQjtBQUNyQixNQUFNLCtEQUFpQjtBQUN2QixJQUFJLCtEQUFpQjtBQUNyQjs7QUFFQSwwQ0FBMEMsK0RBQWlCO0FBQzNELEVBQUU7QUFDRjtBQUNBOztBQUVBLDhEQUFnQixHQUFHLHNFQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NlaW4vLi9zcmMvYm9va21hcmsuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9jb3JlL2VtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9jb3JlL2V2ZW50LmpzIiwid2VicGFjazovL3NlaW4vLi9zcmMvY29yZS9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9jb3JlL3N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9jb3JlL3V0aWwuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9tb2RhbC5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL25vdGVyLmpzIiwid2VicGFjazovL3NlaW4vLi9zcmMvcHJvdG90eXBlLmpzIiwid2VicGFjazovL3NlaW4vLi9zcmMvc2V0dGluZy5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL3dhbGxwYXBlci5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL3dhdmVyLmpzIiwid2VicGFjazovL3NlaW4vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vc2Vpbi93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9zZWluL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9zZWluL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vc2Vpbi93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3NlaW4vLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0b3JhZ2UgZnJvbSAnLi9jb3JlL3N0b3JhZ2UnXG5cbmNvbnN0IGJvb2ttYXJrID0ge1xuICBib29rbWFya0JhckVsZW1lbnQ6IHdpbmRvdy5ib29rbWFya19iYXIsXG59XG5cbi8qKlxuICogQ3JlYXRlIGJvb2ttYXJrIGl0ZW0gZnJvbSBib29rbWFyayBub2Rlc1xuICogQHBhcmFtICB7T2JqZWN0fSBub2RlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgZ2VuZXJhdGVkIGJ5IGJvb2ttYXJrIG5vZGVcbiAqL1xuYm9va21hcmsuY3JlYXRlID0gKG5vZGUpID0+IHtcbiAgY29uc3QgeyB1cmwsIHRpdGxlLCBjaGlsZHJlbiB9ID0gbm9kZVxuXG4gIGlmIChjaGlsZHJlbikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gYm9va21hcmsucmVuZGVyKG5vZGUpKVxuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICA8YSBjbGFzcz1cIml0ZW1cIiBocmVmPVwiJHt1cmx9XCI+XG4gICAgICAgIDxpbWcgc3JjPVwiJHtjaHJvbWUucnVudGltZS5nZXRVUkwoJy9fZmF2aWNvbi8nKX0/cGFnZVVybD0ke3VybH1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+JHt0aXRsZX08L2Rpdj5cbiAgICA8L2E+YFxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhcmVudCBvZiBib29rbWFyaywgdGhpcyBpcyBhIGdyb3VwIG9mIGJvb2ttYXJrIGl0ZW1zXG4gKiBAcGFyYW0gIHtPYmplY3R9IG5vZGVcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICBIVE1MIGdlbmVyYXRlZCBieSBib29rbWFyayBub2Rlc1xuICovXG5ib29rbWFyay5jcmVhdGVQYXJlbnQgPSAobm9kZSkgPT4ge1xuICBjb25zdCBsYWJlbCA9IG5vZGUudGl0bGVcbiAgY29uc3Qgbm9kZXMgPSBub2RlLmNoaWxkcmVuXG4gIGNvbnN0IGNoaWxkcyA9IG5vZGVzLm1hcCgobm9kZSkgPT4gYm9va21hcmsuY3JlYXRlKG5vZGUpKS5qb2luKCcnKVxuICBjb25zdCBwYXJlbnRJZCA9IGAke2xhYmVsfS0ke25vZGUucGFyZW50SWQgfHwgJ3Jvb3QnfWBcbiAgY29uc3Qgc3RhdHVzID0gc3RvcmFnZVtgYm9va21hcms6cGFyZW50OiR7cGFyZW50SWR9YF0gfHwgJ29wZW4nXG5cbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwicGFyZW50ICR7c3RhdHVzfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFyZW50LWhlYWRlclwiIGRhdGEtcGFyZW50LWlkPVwiJHtwYXJlbnRJZH1cIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpY29uLWZvbGRlclwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsYWJlbFwiPiR7bGFiZWx9PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwic3RvcGdyYXBcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhcmVudC1jaGlsZHNcIj4ke2NoaWxkc308L2Rpdj5cbiAgICA8L2Rpdj5gXG59XG5cbi8qKlxuICogUmVuZGVyIGJvb2ttYXJrIGZyb20gYm9va21hcmsgbm9kZVxuICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gW2NsZWFyPWZhbHNlXSBjbGVhbiBib29rbWFyayBiYXIgYmVmb3JlIHJlbmRlclxuICovXG5ib29rbWFyay5yZW5kZXIgPSAobm9kZSwgY2xlYXIgPSBmYWxzZSkgPT4ge1xuICBpZiAoY2xlYXIpIHtcbiAgICBib29rbWFyay5ib29rbWFya0JhckVsZW1lbnQuaW5uZXJIVE1MID0gJydcbiAgfVxuXG4gIGJvb2ttYXJrLmJvb2ttYXJrQmFyRWxlbWVudC5pbm5lckhUTUwgKz0gYm9va21hcmsuY3JlYXRlUGFyZW50KG5vZGUpXG59XG5cbi8qKlxuICogVG9nZ2xlIG9wZW4gcGFyZW50XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGlkXG4gKi9cbmJvb2ttYXJrLnRvZ2dsZU9wZW5QYXJlbnQgPSAoaWQpID0+IHtcbiAgY29uc3Qgb3BlbiA9IHN0b3JhZ2VbYGJvb2ttYXJrOnBhcmVudDoke2lkfWBdID09PSAnY2xvc2UnID8gJ29wZW4nIDogJ2Nsb3NlJ1xuICBzdG9yYWdlW2Bib29rbWFyazpwYXJlbnQ6JHtpZH1gXSA9IG9wZW5cbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcGFyZW50LWlkPVwiJHtpZH1cIl1gKS5wYXJlbnROb2RlLmNsYXNzTmFtZSA9IGBwYXJlbnQgJHtvcGVufWBcbn1cblxuYm9va21hcmsuZmV0Y2ggPSAoKSA9PiB7XG4gIGNocm9tZS50b3BTaXRlcy5nZXQoKHRvcHMpID0+IHtcbiAgICBib29rbWFyay5yZW5kZXIoeyBjaGlsZHJlbjogdG9wcywgdGl0bGU6ICdNb3N0IHZpc2l0ZWQnIH0sIHRydWUpXG5cbiAgICBjaHJvbWUuYm9va21hcmtzLmdldFRyZWUoKGJvb2ttYXJrcykgPT4ge1xuICAgICAgYm9va21hcmsucmVuZGVyKGJvb2ttYXJrc1swXS5jaGlsZHJlblswXSlcbiAgICB9KVxuICB9KVxufVxuXG5ib29rbWFyay5ib290ID0gKCkgPT4ge1xuICBib29rbWFyay5ib29rbWFya0JhckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoeyB0YXJnZXQgfSkgPT4ge1xuICAgIGNvbnN0IGlkID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1wYXJlbnQtaWQnKSB8fCB0YXJnZXQucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFyZW50LWlkJylcblxuICAgIGlmIChpZCkge1xuICAgICAgYm9va21hcmsudG9nZ2xlT3BlblBhcmVudChpZClcbiAgICB9XG4gIH0pXG5cbiAgY2hyb21lLmJvb2ttYXJrcy5vbkNyZWF0ZWQuYWRkTGlzdGVuZXIoYm9va21hcmsuZmV0Y2gpXG4gIGNocm9tZS5ib29rbWFya3Mub25SZW1vdmVkLmFkZExpc3RlbmVyKGJvb2ttYXJrLmZldGNoKVxuICBjaHJvbWUuYm9va21hcmtzLm9uQ2hhbmdlZC5hZGRMaXN0ZW5lcihib29rbWFyay5mZXRjaClcbiAgY2hyb21lLmJvb2ttYXJrcy5vbk1vdmVkLmFkZExpc3RlbmVyKGJvb2ttYXJrLmZldGNoKVxuXG4gIGJvb2ttYXJrLmZldGNoKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgYm9va21hcmtcbiIsImltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInXG5pbXBvcnQgZXZlbnQgZnJvbSAnLi9ldmVudCdcblxuY29uc3QgZW1pdHRlciA9IHtcbiAgbW91bnRlZDoge30sXG59XG5cbi8qKlxuICogRW1pdHRlciBnZW5lcmF0b3JcbiAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IEVtaXR0ZXIgbmFtZVxuICogQHBhcmFtIGhhbmRsZSB7ZnVuY3Rpb259IENhbGwgb25lIHRpbWUgZm9yIHNldHVwIGVtaXR0ZXJcbiAqL1xuZW1pdHRlci5nZW4gPSAobmFtZSwgaGFuZGxlKSA9PiB7XG4gIGlmIChlbWl0dGVyW25hbWVdIHx8ICEvXlthLXpBLVpdW2EtekEtWjAtOV9dezAsNjN9JC8udGVzdChuYW1lKSkge1xuICAgIHJldHVybiBsb2dnZXIuZXJyb3IoYGVtaXR0ZXI6IE5hbWUgXCIke25hbWV9XCIgZXhpc3RlZCBvciBpbnZhbGlkYClcbiAgfVxuXG4gIGVtaXR0ZXJbbmFtZV0gPSAoKSA9PiB7XG4gICAgaWYgKGVtaXR0ZXIubW91bnRlZFtuYW1lXSkge1xuICAgICAgcmV0dXJuIGxvZ2dlci5lcnJvcihgZW1pdHRlcjogRHVwbGljYXRlIG1vdW50IGVtaXR0ZXIgJHtuYW1lfWApXG4gICAgfVxuXG4gICAgaGFuZGxlKClcblxuICAgIGVtaXR0ZXIubW91bnRlZFtuYW1lXSA9IHRydWVcbiAgfVxufVxuXG4vKipcbiAqIERlZmluZSBlbWl0dGVyXG4gKiA9PT09PT09PT09PT09PVxuICovXG5cbmVtaXR0ZXIuZ2VuKCdjbGljaycsICgpID0+IHtcbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tSKHRhcmdldCwgZG9tRXZlbnQsIHVwID0gMCkge1xuICAgIGlmICh1cCA+IDUgfHwgIXRhcmdldCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgY2xpY2tFbWl0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnY2xpY2stZW1pdCcpXG5cbiAgICBpZiAoIWNsaWNrRW1pdCkge1xuICAgICAgcmV0dXJuIGhhbmRsZUNsaWNrUih0YXJnZXQucGFyZW50RWxlbWVudCwgZG9tRXZlbnQsIHVwICsgMSlcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gY2xpY2tFbWl0LnNwbGl0KCc6JylbMF1cblxuICAgIGxldCBwYXlsb2FkID0gY2xpY2tFbWl0LnNwbGl0KCc6Jykuc2xpY2UoMSkuam9pbignOicpXG5cbiAgICAvLyBoYW5kbGUgb2JqZWN0IHBheWxvYWRcbiAgICBpZiAocGF5bG9hZFswXSA9PT0gJz8nKSB7XG4gICAgICBjb25zdCBwYXlsb2FkT2JqZWN0ID0ge31cbiAgICAgIHBheWxvYWRcbiAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgIC5zcGxpdCgnJicpXG4gICAgICAgIC5mb3JFYWNoKChxKSA9PiB7XG4gICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcS5zcGxpdCgnPScpXG4gICAgICAgICAgaWYgKGtleSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXlsb2FkT2JqZWN0W2tleV0gPSB2YWx1ZVxuICAgICAgICB9KVxuICAgICAgcGF5bG9hZCA9IHBheWxvYWRPYmplY3RcbiAgICB9XG5cbiAgICBldmVudC5uZXh0KG5hbWUsIHBheWxvYWQsIHsgdGFyZ2V0LCBkb21FdmVudCB9KVxuICB9XG5cbiAgd2luZG93LmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZG9tRXZlbnQpID0+IHtcbiAgICBoYW5kbGVDbGlja1IoZG9tRXZlbnQudGFyZ2V0LCBkb21FdmVudClcbiAgfSlcblxuICBsb2dnZXIuaW5mbygnZW1pdGVyOiBDbGljayBlbWl0ZXIgbW91bnRlZCcpXG59KVxuXG5leHBvcnQgZGVmYXVsdCBlbWl0dGVyXG4iLCJjb25zdCBldmVudCA9IHtcbiAgcG9vbDoge30sXG59XG5cbmV2ZW50LmVtaXQgPSAobmFtZSwgLi4ucGF5bG9hZCkgPT4ge1xuICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBldmVudC5wb29sW25hbWVdID8/IFtdKSB7XG4gICAgaGFuZGxlKC4uLnBheWxvYWQpXG4gIH1cbn1cblxuZXZlbnQub24gPSAobmFtZSwgaGFuZGxlKSA9PiB7XG4gIGV2ZW50LnBvb2xbbmFtZV0/LnB1c2goaGFuZGxlKSB8fCAoZXZlbnQucG9vbFtuYW1lXSA9IFtoYW5kbGVdKVxufVxuXG5ldmVudC5uZXh0ID0gKG5hbWUsIC4uLnBheWxvYWQpID0+IHtcbiAgc2V0VGltZW91dChldmVudC5lbWl0LCAwLCBuYW1lLCAuLi5wYXlsb2FkKVxufVxuXG5leHBvcnQgZGVmYXVsdCBldmVudFxuIiwiY29uc3QgTEVWRUwgPSBbJ2RlYnVnJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvciddXG5cbmNvbnN0IGxvZ2dlciA9IHtcbiAgbG9nX2xldmVsOiAnZGVidWcnLFxuXG4gIGdldCBkZWJ1ZygpIHtcbiAgICBpZiAoTEVWRUwuaW5kZXhPZih0aGlzLmxvZ19sZXZlbC50b0xvd2VyQ2FzZSgpKSA8PSBMRVZFTC5pbmRleE9mKCdkZWJ1ZycpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5kZWJ1Zy5iaW5kKHdpbmRvdy5jb25zb2xlLCAnJWNERUJVRyAgOicsICdjb2xvcjogIzZjNzU3ZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZFxuICB9LFxuXG4gIGdldCBpbmZvKCkge1xuICAgIGlmIChMRVZFTC5pbmRleE9mKHRoaXMubG9nX2xldmVsLnRvTG93ZXJDYXNlKCkpIDw9IExFVkVMLmluZGV4T2YoJ2luZm8nKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuaW5mby5iaW5kKHdpbmRvdy5jb25zb2xlLCAnJWNJTkZPICAgOicsICdjb2xvcjogIzE3YTJiOCcpXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZFxuICB9LFxuXG4gIGdldCB3YXJuaW5nKCkge1xuICAgIGlmIChMRVZFTC5pbmRleE9mKHRoaXMubG9nX2xldmVsLnRvTG93ZXJDYXNlKCkpIDw9IExFVkVMLmluZGV4T2YoJ3dhcm5pbmcnKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2Fybi5iaW5kKHdpbmRvdy5jb25zb2xlLCAnJWNXQVJOSU5HOicsICdjb2xvcjogI2ZmYzEwNycpXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZFxuICB9LFxuXG4gIGdldCBlcnJvcigpIHtcbiAgICBpZiAoTEVWRUwuaW5kZXhPZih0aGlzLmxvZ19sZXZlbC50b0xvd2VyQ2FzZSgpKSA8PSBMRVZFTC5pbmRleE9mKCdlcnJvcicpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvci5iaW5kKHdpbmRvdy5lcnJvciwgJyVjRVJST1IgIDonLCAnY29sb3I6ICNkYzM1NDUnKVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB1bmRlZmluZWRcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgbG9nZ2VyXG4iLCJpbXBvcnQgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJ1xuXG5jb25zdCBzdG9yYWdlID0ge31cbmNvbnN0IGhhbmRsZXIgPSB7fVxuXG5oYW5kbGVyLmdldCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICBpZiAoa2V5ID09PSAnb3JpZ2luJykge1xuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIGNvbnN0IHJhdyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vba2V5XVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHJhdyAmJiBKU09OLnBhcnNlKHJhdylcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbG9nZ2VyLmVycm9yKCdzdG9yYWdlOiBQYXJzZSBqc29uIGZhaWwsIGtleTogJywga2V5KVxuICB9XG59XG5cbmhhbmRsZXIuc2V0ID0gKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4ge1xuICB3aW5kb3cubG9jYWxTdG9yYWdlW2tleV0gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgUHJveHkoc3RvcmFnZSwgaGFuZGxlcilcbiIsImNvbnN0IHV0aWwgPSB7fVxuXG51dGlsLnRocm90dGxlID0gKHdhaXQgPSAyMDAsIHRyYWlsbGluZyA9IHRydWUpID0+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgbG9jazogZmFsc2UsXG4gICAgaGFuZGxlOiBudWxsLFxuICB9XG5cbiAgaW5zdGFuY2UuZXhlY3V0ZSA9IChoYW5kbGUsIC4uLmFyZ3MpID0+IHtcbiAgICBpbnN0YW5jZS5oYW5kbGUgPSBoYW5kbGVcblxuICAgIGlmIChpbnN0YW5jZS5sb2NrKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpbnN0YW5jZS5sb2NrID0gdHJ1ZVxuICAgIGluc3RhbmNlLmhhbmRsZSguLi5hcmdzKVxuICAgIGluc3RhbmNlLmhhbmRsZSA9IG51bGxcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaW5zdGFuY2UubG9jayA9IGZhbHNlXG5cbiAgICAgIGlmICh0cmFpbGxpbmcgJiYgaW5zdGFuY2UuaGFuZGxlKSB7XG4gICAgICAgIGluc3RhbmNlLmV4ZWN1dGUoaW5zdGFuY2UuaGFuZGxlLCAuLi5hcmdzKVxuICAgICAgfVxuICAgIH0sIHdhaXQpXG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxudXRpbC5kZWJvdW5jZSA9ICh3YWl0ID0gMjAwKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlID0ge1xuICAgIHRpbWVvdXQ6IG51bGwsXG4gIH1cblxuICBpbnN0YW5jZS5leGVjdXRlID0gKGhhbmRsZSwgLi4uYXJncykgPT4ge1xuICAgIGNsZWFyVGltZW91dChpbnN0YW5jZS50aW1lb3V0KVxuICAgIGluc3RhbmNlLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGhhbmRsZSwgd2FpdCwgLi4uYXJncylcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG51dGlsLnJhZiA9ICgpID0+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgbG9jazogZmFsc2UsXG4gICAgaGFuZGxlOiBudWxsLFxuICB9XG5cbiAgaW5zdGFuY2UuZXhlY3V0ZSA9IChoYW5kbGUsIC4uLmFyZ3MpID0+IHtcbiAgICBpbnN0YW5jZS5oYW5kbGUgPSBoYW5kbGVcblxuICAgIGlmIChpbnN0YW5jZS5sb2NrKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpbnN0YW5jZS5sb2NrID0gdHJ1ZVxuXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5sb2NrID0gZmFsc2VcbiAgICAgIGluc3RhbmNlLmhhbmRsZSguLi5hcmdzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgdXRpbFxuIiwiY29uc3QgbW9kYWwgPSB7fVxuXG5tb2RhbC5oaWRlID0gKCkgPT4ge1xuICB3aW5kb3cubW9kYWwucmVtb3ZlQ2xhc3MoJ21vZGFsLXNob3cnKVxufVxuXG5tb2RhbC5zaG93ID0gKGNvbnRlbnQpID0+IHtcbiAgd2luZG93Lm1vZGFsX2NvbnRlbnQuaW5uZXJIVE1MID0gY29udGVudFxuICB3aW5kb3cubW9kYWwuYWRkQ2xhc3MoJ21vZGFsLXNob3cnKVxufVxuXG53aW5kb3cubW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoeyB0YXJnZXQgfSkgPT4ge1xuICBpZiAodGFyZ2V0LmlkID09PSAnbW9kYWwnKSB7XG4gICAgbW9kYWwuaGlkZSgpXG4gIH1cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IG1vZGFsXG4iLCJpbXBvcnQgc3RvcmFnZSBmcm9tICcuL2NvcmUvc3RvcmFnZSdcbmltcG9ydCBsb2dnZXIgZnJvbSAnLi9jb3JlL2xvZ2dlcidcbmltcG9ydCBldmVudCBmcm9tICcuL2NvcmUvZXZlbnQnXG5pbXBvcnQgdXRpbCBmcm9tICcuL2NvcmUvdXRpbCdcbmltcG9ydCBtb2RhbCBmcm9tICcuL21vZGFsJ1xuXG5jb25zdCBub3RlciA9IHtcbiAgcHVsbF9jb29sZG93bjogMTAwMDAsXG5cbiAgY2FsbDoge1xuICAgIG1vdmU6IHV0aWwucmFmKCksXG4gICAgc3luYzogdXRpbC50aHJvdHRsZSgpLFxuICAgIHB1c2g6IHV0aWwuZGVib3VuY2UoMTAwMCksXG4gIH0sXG5cbiAgdmVyc2lvbjogbnVsbCxcbiAgZXFDb2RlUmVhZHk6IG51bGwsXG4gIG5vdGVzOiBbXSxcbn1cblxubm90ZXIuZmV0Y2ggPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGxvY2FsID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KFsnbm90ZXMnLCAndmVyc2lvbiddKVxuXG4gIG5vdGVyLm5vdGVzID0gbG9jYWwubm90ZXMgfHwgW11cbiAgbm90ZXIudmVyc2lvbiA9IGxvY2FsLnZlcnNpb25cbiAgbm90ZXIucmVuZGVyKClcbn1cblxubm90ZXIuc2F2ZSA9ICgpID0+IHtcbiAgY29uc3QgdmVyc2lvbiA9IERhdGUubm93KClcblxuICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe1xuICAgIG5vdGVzOiBub3Rlci5ub3RlcyxcbiAgICB2ZXJzaW9uLFxuICB9KVxuXG4gIG5vdGVyLnZlcnNpb24gPSB2ZXJzaW9uXG4gIG5vdGVyLmNhbGwucHVzaC5leGVjdXRlKG5vdGVyLnB1c2gpXG5cbiAgbG9nZ2VyLmRlYnVnKCdub3RlcjogTm90ZXIgc2F2ZTonLCBub3Rlci5ub3Rlcylcbn1cblxubm90ZXIuY3JlYXRlT2JqZWN0ID0gKG5vdGUpID0+IHtcbiAgY29uc3QgZGVmYXVsdERhdGEgPSB7XG4gICAgbXNnOiAnJyxcbiAgICB4OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaG9sZGVyLndfdyAtIDUwMCkpLFxuICAgIHk6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChob2xkZXIud19oIC0gMjUwKSksXG4gICAgdzogMzAwLFxuICAgIGg6IDEwMCxcbiAgICB3b3Jrc3BhY2U6IHN0b3JhZ2Uud29ya3NwYWNlIHx8IDAsXG4gICAgc3RhdHVzOiAnZGVmYXVsdCcsXG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0RGF0YSwgbm90ZSlcbn1cblxubm90ZXIuY3JlYXRlRWxlbWVudCA9IChub3RlKSA9PiB7XG4gIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgZG9tLnNldEF0dHJpYnV0ZSgnaWQnLCBgbm90ZWlkXyR7bm90ZS5pZH1gKVxuICBkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsICdub3RlJylcbiAgZG9tLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHtub3RlLnh9cHgsICR7bm90ZS55fXB4KWApXG4gIGRvbS5zZXRBdHRyaWJ1dGUoJ25vdGUtc3RhdHVzJywgbm90ZS5zdGF0dXMgfHwgJ2RlZmF1bHQnKVxuXG4gIGRvbS5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cIm5vdGUtY29udHJvbHNcIiBub3RlLW1vdmUtaWQ9XCIke25vdGUuaWR9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJub3RlLXJlbW92ZVwiIGNsaWNrLWVtaXQ9XCJub3RlX3JlbW92ZToke25vdGUuaWR9XCI+JnRpbWVzOzwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJub3RlLXJhaW5ib3dcIj5cbiAgICAgICAgPGRpdiBjbGljay1lbWl0PVwibm90ZV9tYXJrOiR7bm90ZS5pZH0scHJpbWFyeVwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsaWNrLWVtaXQ9XCJub3RlX21hcms6JHtub3RlLmlkfSxzdWNjZXNzXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xpY2stZW1pdD1cIm5vdGVfbWFyazoke25vdGUuaWR9LGRhbmdlclwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJub3RlLWVkaXRvclwiXG4gICAgICAgIGNvbnRlbnRlZGl0YWJsZT1cInRydWVcIlxuICAgICAgICBzcGVsbGNoZWNrPVwiZmFsc2VcIlxuICAgICAgICBub3RlLWVkaXRvci1pZD1cIiR7bm90ZS5pZH1cIlxuICAgICAgICBzdHlsZT1cIndpZHRoOiR7bm90ZS53fXB4O2hlaWdodDoke25vdGUuaCAtIDIwfXB4XCJcbiAgICA+JHtub3RlLm1zZ308L2Rpdj5gXG5cbiAgbm90ZXIuaGFuZGxlSGFzaHRhZyhkb20pXG5cbiAgcmV0dXJuIGRvbVxufVxuXG5ub3Rlci5hZGQgPSAobm90ZSkgPT4ge1xuICAvLyBOZXcgbm90ZSBkb24ndCBoYXZlIGEgaWQsIHB1c2ggaXQgdG8gbm90ZXIubm90ZXNcbiAgaWYgKG5vdGUuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vdGUuaWQgPSBEYXRlLm5vdygpLnRvU3RyaW5nKClcbiAgICBub3RlLnVwZGF0ZWRBdCA9IERhdGUubm93KClcbiAgICBub3Rlci5ub3Rlcy5wdXNoKG5vdGUpXG4gIH1cblxuICAvLyBSZW5kZXIgaHRtbFxuICB3aW5kb3cubm90ZV9ib3guYXBwZW5kQ2hpbGQobm90ZXIuY3JlYXRlRWxlbWVudChub3RlKSlcbn1cblxubm90ZXIucmVuZGVyID0gKGNsZWFyID0gdHJ1ZSwgd29ya3NwYWNlID0gK3N0b3JhZ2Uud29ya3NwYWNlIHx8IDApID0+IHtcbiAgLy8gQ2xlYXIgYmVmb3JlIHJlbmRlclxuICBpZiAoY2xlYXIpIHtcbiAgICB3aW5kb3cubm90ZV9ib3guaW5uZXJIVE1MID0gJydcbiAgfVxuXG4gIC8vIExvb3AgYWRkaW5nXG4gIGZvciAoY29uc3Qgbm90ZSBvZiBub3Rlci5ub3Rlcykge1xuICAgIGlmICh3b3Jrc3BhY2UgPT09IG5vdGUud29ya3NwYWNlKSB7XG4gICAgICBub3Rlci5hZGQobm90ZSlcbiAgICB9XG4gIH1cblxuICBsb2dnZXIuZGVidWcoJ25vdGVyOiBSZW5kZXIgbm90ZScsIG5vdGVyLm5vdGVzKVxufVxuXG5ub3Rlci5oYW5kbGVFcWNvZGUgPSAoZWRpdG9yKSA9PiB7XG4gIC8vIEluc2VydCBtYXJrZXJcbiAgY29uc3Qgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpXG4gIGNvbnN0IHJhbmdlID0gc2VsLmdldFJhbmdlQXQoMClcbiAgY29uc3QgbWFya2VyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgbWFya2VyRWwuaWQgPSAnY2FyZXQtbWFya2VyJ1xuICBtYXJrZXJFbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjAwQicpKVxuICByYW5nZS5pbnNlcnROb2RlKG1hcmtlckVsKVxuXG4gIGNvbnN0IHN0cmluZyA9IGVkaXRvci5pbm5lckhUTUxcblxuICBob2xkZXIuY29kZV90YWJsZXMuZm9yRWFjaCgoY29kZSkgPT4ge1xuICAgIGNvbnN0IGNyZWdleCA9IG5ldyBSZWdFeHAoY29kZS5jb2RlKVxuICAgIGNvbnN0IHJlc3VsdCA9IHN0cmluZy5tYXRjaChjcmVnZXgpXG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAvLyBEYXRhIGVtYmVkZGVkIGluIGNvbW1hbmQgY29kZSBleC4gJ25hbWVfKC4rPyk9PSdcbiAgICAgIGNvbnN0IHJlcGxhY2VzID0gcmVzdWx0LnNsaWNlKDEpXG4gICAgICBsZXQgY29kZVZhbHVlID0gY29kZS52YWx1ZVxuXG4gICAgICBmb3IgKGNvbnN0IHJlcGxhY2Ugb2YgcmVwbGFjZXMpIHtcbiAgICAgICAgY29kZVZhbHVlID0gY29kZVZhbHVlLnJlcGxhY2UoJyQnLCByZXBsYWNlKVxuICAgICAgfVxuXG4gICAgICBlZGl0b3IuaW5uZXJIVE1MID0gc3RyaW5nLnJlcGxhY2UoY3JlZ2V4LCBjb2RlVmFsdWUpXG4gICAgfVxuICB9KVxuXG4gIC8vIFJlc3RvcmUgY2FydGUgYW5kIHJlbW92ZSBtYXJrZXJcbiAgY29uc3QgbmV3TWFya2VyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhcmV0LW1hcmtlcicpXG5cbiAgaWYgKG5ld01hcmtlcikge1xuICAgIGNvbnN0IG5ld1JhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKVxuICAgIG5ld1JhbmdlLnNldFN0YXJ0QWZ0ZXIobmV3TWFya2VyKVxuICAgIG5ld1JhbmdlLmNvbGxhcHNlKHRydWUpXG4gICAgbmV3TWFya2VyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobmV3TWFya2VyKVxuICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKVxuICAgIHNlbC5hZGRSYW5nZShuZXdSYW5nZSlcbiAgfVxufVxuXG5ub3Rlci5oYW5kbGVIYXNodGFnID0gKGRvbSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBkb20ucXVlcnlTZWxlY3RvcignLm5vdGUtZWRpdG9yJylcbiAgY29uc3QgaGVhZCA9IGVkaXRvci5pbm5lckhUTUwuc2xpY2UoMCwgMjU2KVxuXG4gIGNvbnN0IGhhc2h0YWdzID0gaGVhZC5tYXRjaCgvI1thLXowLTlfXXsxLDEyfS9naSkgfHwgW11cbiAgY29uc3QgY2xhc3NlcyA9IFsnbm90ZSddXG5cbiAgaWYgKGhhc2h0YWdzLmluY2x1ZGVzKCcjbW9ubycpKSB7XG4gICAgY2xhc3Nlcy5wdXNoKCdub3RlLWZmbScpXG4gIH1cblxuICBkb20uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJylcbn1cblxubm90ZXIucmVtb3ZlID0gKGlkKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gbm90ZXIubm90ZXMuZmluZEluZGV4KChub3RlKSA9PiBub3RlLmlkID09IGlkKVxuXG4gIGlmIChzdG9yYWdlLndvcmtzcGFjZSA9PT0gLTEgfHwgIW5vdGVyLm5vdGVzW2luZGV4XS5tc2cpIHtcbiAgICBub3Rlci5ub3Rlcy5zcGxpY2UoaW5kZXgsIDEpXG4gIH0gZWxzZSB7XG4gICAgbm90ZXIubm90ZXNbaW5kZXhdLndvcmtzcGFjZSA9IC0xXG4gICAgbm90ZXIubm90ZXNbaW5kZXhdLnJlbW92ZUF0ID0gRGF0ZS5ub3coKVxuICAgIG5vdGVyLm5vdGVzW2luZGV4XS51cGRhdGVkQXQgPSBEYXRlLm5vdygpXG4gIH1cblxuICAvLyBSZW1vdmUgZG9tXG4gIGNvbnN0IGRvbSA9IHdpbmRvd1tgbm90ZWlkXyR7aWR9YF1cbiAgZG9tLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZG9tKVxuXG4gIG5vdGVyLnNhdmUoKVxufVxuXG5ub3Rlci5tYXJrID0gKGlkLCBzdGF0dXMpID0+IHtcbiAgY29uc3Qgbm90ZSA9IG5vdGVyLm5vdGVzLmZpbmQoKG4pID0+IG4uaWQgPT0gaWQpXG5cbiAgaWYgKG5vdGUuc3RhdHVzID09PSBzdGF0dXMpIHtcbiAgICBub3RlLnN0YXR1cyA9ICdkZWZhdWx0J1xuICB9IGVsc2Uge1xuICAgIG5vdGUuc3RhdHVzID0gc3RhdHVzXG4gIH1cblxuICB3aW5kb3dbYG5vdGVpZF8ke2lkfWBdLnNldEF0dHJpYnV0ZSgnbm90ZS1zdGF0dXMnLCBub3RlLnN0YXR1cylcbiAgbm90ZXIuc2F2ZSgpXG59XG5cbm5vdGVyLmhhbmRsZU9uQ2hhbmdlID0gKHsgdGFyZ2V0LCBrZXkgfSkgPT4ge1xuICBjb25zdCBpZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ25vdGUtZWRpdG9yLWlkJylcblxuICBpZiAoaWQpIHtcbiAgICBjb25zdCBpbmRleCA9IG5vdGVyLm5vdGVzLmZpbmRJbmRleCgobm90ZSkgPT4gbm90ZS5pZCA9PSBpZClcblxuICAgIC8vIENoZWNrIGNoYW5nZWRcbiAgICBpZiAobm90ZXIubm90ZXNbaW5kZXhdLm1zZyA9PT0gdGFyZ2V0LmlubmVySFRNTCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG5vdGUgaGFzaHRhZ1xuICAgIG5vdGVyLmhhbmRsZUhhc2h0YWcodGFyZ2V0LnBhcmVudEVsZW1lbnQpXG5cbiAgICAvLyBIYW5kbGUgbm90ZSBjb2RlXG4gICAgaWYgKGtleSA9PT0gJz0nKSB7XG4gICAgICBpZiAobm90ZXIuZXFDb2RlUmVhZHkpIHtcbiAgICAgICAgbm90ZXIuaGFuZGxlRXFjb2RlKHRhcmdldClcbiAgICAgICAgbm90ZXIuZXFDb2RlUmVhZHkgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm90ZXIuZXFDb2RlUmVhZHkgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgbm90ZXIubm90ZXNbaW5kZXhdLm1zZyA9IHRhcmdldC5pbm5lckhUTUxcbiAgICBub3Rlci5ub3Rlc1tpbmRleF0udXBkYXRlZEF0ID0gRGF0ZS5ub3coKVxuXG4gICAgbm90ZXIuc2F2ZSgpXG4gIH1cbn1cblxubm90ZXIucHVsbCA9IGFzeW5jICgpID0+IHtcbiAgaWYgKCFzdG9yYWdlLmNvbmZpZy5zeW5jX3VybCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHN0b3JhZ2UucHVsbF9kYXRlID4gRGF0ZS5ub3coKSAtIG5vdGVyLnB1bGxfY29vbGRvd24pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IFt1cmwsIHNlY3JldF0gPSBzdG9yYWdlLmNvbmZpZy5zeW5jX3VybC5zcGxpdCgnIycpXG5cbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dXJsfT9kYXRlPSR7c3RvcmFnZS5wdWxsX2RhdGUgfHwgMH1gLCB7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnWC1TZWNyZXQnOiBzZWNyZXQsXG4gICAgfSxcbiAgfSlcblxuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gIGlmIChkYXRhPy5sZW5ndGgpIHtcbiAgICBjb25zdCBtYXAgPSB7fVxuICAgIGxldCBzaG91bGRSZW5kZXIgPSBmYWxzZVxuXG4gICAgZm9yIChjb25zdCBub3RlIG9mIG5vdGVyLm5vdGVzKSB7XG4gICAgICBtYXBbbm90ZS5pZF0gPSBub3RlXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7IHJhdzogbm90ZSB9IG9mIGRhdGEpIHtcbiAgICAgIGlmICghbWFwW25vdGUuaWRdPy51cGRhdGVkQXQgfHwgbWFwW25vdGUuaWRdLnVwZGF0ZWRBdCA8IG5vdGUudXBkYXRlZEF0KSB7XG4gICAgICAgIG1hcFtub3RlLmlkXSA9IG5vdGVcbiAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRSZW5kZXIpIHtcbiAgICAgIG5vdGVyLm5vdGVzID0gT2JqZWN0LnZhbHVlcyhtYXApXG4gICAgICBub3Rlci5yZW5kZXIoKVxuICAgICAgbm90ZXIuc2F2ZSgpXG4gICAgfVxuICB9XG5cbiAgc3RvcmFnZS5wdWxsX2RhdGUgPSBub3dcbn1cblxubm90ZXIucHVzaCA9IGFzeW5jICgpID0+IHtcbiAgaWYgKCFzdG9yYWdlLmNvbmZpZy5zeW5jX3VybCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qgbm90ZXMgPSBub3Rlci5ub3Rlcy5maWx0ZXIoKG5vdGUpID0+IHtcbiAgICByZXR1cm4gK25vdGUudXBkYXRlZEF0ID4gKCtzdG9yYWdlLnB1c2hfZGF0ZSB8fCAwKSAmJiBub3RlLm1zZ1xuICB9KVxuXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgY29uc3QgW3VybCwgc2VjcmV0XSA9IHN0b3JhZ2UuY29uZmlnLnN5bmNfdXJsLnNwbGl0KCcjJylcblxuICBpZiAobm90ZXMubGVuZ3RoKSB7XG4gICAgYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbm90ZXMgfSksXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdYLVNlY3JldCc6IHNlY3JldCxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIHN0b3JhZ2UucHVzaF9kYXRlID0gbm93XG59XG5cbm5vdGVyLmNsZWFyVHJhc2ggPSAoKSA9PiB7XG4gIGlmIChzdG9yYWdlLmxhc3RfY2xlYXJfdHJhc2ggPiBEYXRlLm5vdygpIC0gOGU3KSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBzdG9yYWdlLmxhc3RfY2xlYXJfdHJhc2ggPSBEYXRlLm5vdygpXG5cbiAgbm90ZXIubm90ZXMgPSBub3Rlci5ub3Rlcy5maWx0ZXIoKG5vdGUpID0+IHtcbiAgICBpZiAobm90ZS53b3Jrc3BhY2UgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChub3RlLnJlbW92ZUF0ID4gRGF0ZS5ub3coKSAtIDg2NGU1ICogMzApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9KVxuXG4gIG5vdGVyLnNhdmUoKVxufVxuXG5ub3Rlci5ib290ID0gKCkgPT4ge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICByZXNpemU6IGZhbHNlLFxuICAgIG1vdmU6IGZhbHNlLFxuICAgIGRlbHRhWDogMCxcbiAgICBkZWx0YVk6IDAsXG4gIH1cblxuICBldmVudC5vbignbm90ZV9yZW1vdmUnLCAoaWQpID0+IHtcbiAgICBub3Rlci5yZW1vdmUoaWQpXG4gIH0pXG5cbiAgZXZlbnQub24oJ25vdGVfbWFyaycsIChtYXJrKSA9PiB7XG4gICAgY29uc3QgW2lkLCBzdGF0dXNdID0gbWFyay5zcGxpdCgnLCcpXG4gICAgbm90ZXIubWFyayhpZCwgc3RhdHVzKVxuICB9KVxuXG4gIC8vIEhhbmRsZSBtb3ZlXG4gIHdpbmRvdy5ub3RlX2JveC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAvLyBQcmV2ZW50IHJpZ2h0IG1vdXNlXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gZXZlbnRcblxuICAgIC8vIERldGVjdCByZXNpemVcbiAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZSgnbm90ZS1lZGl0b3ItaWQnKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY3ggPSBldmVudC5jbGllbnRYXG4gICAgICBjb25zdCBjeSA9IGV2ZW50LmNsaWVudFlcbiAgICAgIGNvbnN0IG5vdGVJZCA9ICt0YXJnZXQuZ2V0QXR0cmlidXRlKCdub3RlLWVkaXRvci1pZCcpXG4gICAgICBjb25zdCBub3RlSW5kZXggPSBub3Rlci5ub3Rlcy5maW5kSW5kZXgoKG5vdGUpID0+IG5vdGUuaWQgPT0gbm90ZUlkKVxuICAgICAgY29uc3Qgbm90ZSA9IG5vdGVyLm5vdGVzW25vdGVJbmRleF1cblxuICAgICAgLy8gRGV0ZWN0IG1vdXNlIGRvd24gb3ZlciByZXNpemUgYnRuXG4gICAgICBpZiAobm90ZS54ICsgbm90ZS53IC0gY3ggPCAxNSAmJiBub3RlLnkgKyBub3RlLmggLSBjeSA8IDE1KSB7XG4gICAgICAgIHN0YXRlLnJlc2l6ZSA9IG5vdGVJZFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKCdub3RlLW1vdmUtaWQnKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgbm90ZUlkID0gK3RhcmdldC5nZXRBdHRyaWJ1dGUoJ25vdGUtbW92ZS1pZCcpXG4gICAgICBjb25zdCBub3RlSW5kZXggPSBub3Rlci5ub3Rlcy5maW5kSW5kZXgoKG5vdGUpID0+IG5vdGUuaWQgPT0gbm90ZUlkKVxuXG4gICAgICAvLyBGaXggcG9zaXRpb24gbW91c2UgdnMgbm90ZVxuICAgICAgc3RhdGUuZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIG5vdGVyLm5vdGVzW25vdGVJbmRleF0ueFxuICAgICAgc3RhdGUuZGVsdGFZID0gZXZlbnQuY2xpZW50WSAtIG5vdGVyLm5vdGVzW25vdGVJbmRleF0ueVxuXG4gICAgICAvLyBTdGFydCBtb3ZlIGhhbmRsZVxuICAgICAgc3RhdGUubW92ZSA9IG5vdGVJZFxuICAgIH1cbiAgfSlcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGV2ZW50KSA9PiB7XG4gICAgaWYgKHN0YXRlLm1vdmUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBub3Rlci5jYWxsLm1vdmUuZXhlY3V0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSB3aW5kb3dbYG5vdGVpZF8ke3N0YXRlLm1vdmV9YF1cblxuICAgICAgaWYgKGRvbSkge1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oaG9sZGVyLndfdyAtIDIwLCBNYXRoLm1heChldmVudC5jbGllbnRYIC0gc3RhdGUuZGVsdGFYLCAwKSlcbiAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKGhvbGRlci53X2ggLSAyMCwgTWF0aC5tYXgoZXZlbnQuY2xpZW50WSAtIHN0YXRlLmRlbHRhWSwgMCkpXG4gICAgICAgIGRvbS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KWBcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKGV2ZW50KSA9PiB7XG4gICAgaWYgKHN0YXRlLm1vdmUgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WCAtIHN0YXRlLmRlbHRhWFxuICAgICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFkgLSBzdGF0ZS5kZWx0YVlcbiAgICAgIGNvbnN0IG5vdGUgPSBub3Rlci5ub3Rlcy5maW5kKChlKSA9PiBlLmlkID09IHN0YXRlLm1vdmUpXG5cbiAgICAgIGlmIChub3RlKSB7XG4gICAgICAgIG5vdGUueCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGhvbGRlci53X3csIHgpKVxuICAgICAgICBub3RlLnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihob2xkZXIud19oLCB5KSlcbiAgICAgICAgbm90ZS51cGRhdGVkQXQgPSBEYXRlLm5vdygpXG4gICAgICB9XG5cbiAgICAgIC8vIEVuZCBtb3ZlIGhhbmRsZVxuICAgICAgc3RhdGUubW92ZSA9IGZhbHNlXG5cbiAgICAgIC8vIFNhdmUgd2hlbiBkb25lIG1vdmUgYSBub3RlXG4gICAgICBub3Rlci5zYXZlKClcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnJlc2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IG5vdGUgPSBub3Rlci5ub3Rlcy5maW5kKChlKSA9PiBlLmlkID09IHN0YXRlLnJlc2l6ZSlcblxuICAgICAgaWYgKG5vdGUpIHtcbiAgICAgICAgbm90ZS53ID0gd2luZG93Wydub3RlaWRfJyArIHN0YXRlLnJlc2l6ZV0ub2Zmc2V0V2lkdGhcbiAgICAgICAgbm90ZS5oID0gd2luZG93Wydub3RlaWRfJyArIHN0YXRlLnJlc2l6ZV0ub2Zmc2V0SGVpZ2h0XG4gICAgICB9XG5cbiAgICAgIC8vIEVuZCByZXNpemUgaGFuZGxlXG4gICAgICBzdGF0ZS5yZXNpemUgPSBmYWxzZVxuXG4gICAgICAvLyBTYXZlIHdoZW4gZG9uZSBtb3ZlIGEgbm90ZVxuICAgICAgbm90ZXIuc2F2ZSgpXG4gICAgfVxuICB9KVxuXG4gIHdpbmRvdy5ub3RlX2JveC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIG5vdGVyLmhhbmRsZU9uQ2hhbmdlKVxuICB3aW5kb3cubm90ZV9ib3guYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBub3Rlci5oYW5kbGVPbkNoYW5nZSlcblxuICB3aW5kb3cubm90ZV9ib3guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoeyB0YXJnZXQgfSkgPT4ge1xuICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgIG1vZGFsLnNob3coYDxpbWcgc3JjPVwiJHt0YXJnZXQuc3JjfVwiIHN0eWxlPVwibWF4LXdpZHRoOiBjYWxjKDEwMHZ3IC0gNTBweClcIj5gKVxuICAgIH1cbiAgfSlcblxuICAvLyBMaXN0ZW4gYWRkIG5vdGVcbiAgZXZlbnQub24oJ25vdGVyX2FkZCcsICgpID0+IHtcbiAgICBub3Rlci5hZGQobm90ZXIuY3JlYXRlT2JqZWN0KCkpXG4gICAgbm90ZXIuc2F2ZSgpXG4gIH0pXG5cbiAgLy8gTGlzdGVuIHN3aXRjaCB3b3Jrc3BhY2VcbiAgZXZlbnQub24oJ25vdGVyX3N3aXRjaF93b3Jrc3BhY2UnLCAoKSA9PiB7XG4gICAgbGV0IHdvcmtzcGFjZSA9ICtzdG9yYWdlLndvcmtzcGFjZSB8fCAwXG5cbiAgICBpZiAod29ya3NwYWNlID4gc3RvcmFnZS5jb25maWcubnVtYmVyX29mX3dvcmtzcGFjZSAtIDIpIHtcbiAgICAgIHdvcmtzcGFjZSA9IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtzcGFjZSsrXG4gICAgfVxuXG4gICAgd2luZG93LnN3aXRjaF93b3Jrc3BhY2VfYnRuLmlubmVySFRNTCA9IHdvcmtzcGFjZSA9PT0gLTEgPyAn8J+Xke+4jycgOiB3b3Jrc3BhY2VcbiAgICBzdG9yYWdlLndvcmtzcGFjZSA9IHdvcmtzcGFjZVxuXG4gICAgbm90ZXIuc2F2ZSgpXG4gICAgbm90ZXIucmVuZGVyKClcbiAgfSlcblxuICAvLyBMaXN0ZW4gc3luYyBub3RlcyBjcm9zcyB0YWJcbiAgY2hyb21lLnN0b3JhZ2Uub25DaGFuZ2VkLmFkZExpc3RlbmVyKChjaGFuZ2UsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmIChuYW1lc3BhY2UgIT09ICdsb2NhbCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIG5vdGVyLmNhbGwuc3luYy5leGVjdXRlKCgpID0+IHtcbiAgICAgIGlmIChjaGFuZ2Uubm90ZXMgJiYgY2hhbmdlLnZlcnNpb24/Lm5ld1ZhbHVlID4gbm90ZXIudmVyc2lvbikge1xuICAgICAgICBub3Rlci5ub3RlcyA9IGNoYW5nZS5ub3Rlcy5uZXdWYWx1ZVxuICAgICAgICBub3Rlci5yZW5kZXIoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgbm90ZXIuZmV0Y2goKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICBub3Rlci5jbGVhclRyYXNoKClcbiAgICBhd2FpdCBub3Rlci5wdXNoKClcbiAgICBhd2FpdCBub3Rlci5wdWxsKClcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90ZXJcbiIsIkFycmF5LnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlZHVjZSgoYWNjLCBlKSA9PiBhY2MgKyBlKVxufVxuXG5IVE1MRWxlbWVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7Y2xhc3NOYW1lfSR8XiR7Y2xhc3NOYW1lfSB8ICR7Y2xhc3NOYW1lfSR8ICR7Y2xhc3NOYW1lfSggKWAsICdnJylcbiAgaWYgKCFyZWdleC50ZXN0KHRoaXMuY2xhc3NOYW1lKSkge1xuICAgIHRoaXMuY2xhc3NOYW1lID0gYCR7dGhpcy5jbGFzc05hbWV9ICR7Y2xhc3NOYW1lfWAudHJpbSgpXG4gIH1cbn1cblxuSFRNTEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4ke2NsYXNzTmFtZX0kfF4ke2NsYXNzTmFtZX0gfCAke2NsYXNzTmFtZX0kfCAke2NsYXNzTmFtZX0oIClgLCAnZycpXG4gIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUucmVwbGFjZShyZWdleCwgJyQxJykudHJpbSgpXG59XG5cbkhUTUxDb2xsZWN0aW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gWy4uLnRoaXNdXG59XG5cbk5vZGVMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gWy4uLnRoaXNdXG59XG4iLCJpbXBvcnQgc3RvcmFnZSBmcm9tICcuL2NvcmUvc3RvcmFnZSdcbmltcG9ydCBldmVudCBmcm9tICcuL2NvcmUvZXZlbnQnXG5pbXBvcnQgbm90ZXIgZnJvbSAnLi9ub3RlcidcbmltcG9ydCB3YWxscGFwZXIgZnJvbSAnLi93YWxscGFwZXInXG5cbmNvbnN0IHNldHRpbmcgPSB7XG4gIGlzT3BlbjogZmFsc2UsXG4gIGJsb2JfYnVmZmVyX3VybDogbnVsbCxcbn1cblxuc2V0dGluZy5yZW5kZXIgPSAoKSA9PiB7XG4gIC8vIFJlbmRlciB3YWxscGFwZXJcbiAgY29uc3Qgd2FsVyA9IE1hdGguZmxvb3Iod2luZG93LnNldHRpbmdzX3dhbGxwYXBlcnMuY2xpZW50V2lkdGggLyA2IC0gMTEpXG4gIGNvbnN0IHdhbEggPSBNYXRoLmZsb29yKCh3YWxXICogaG9sZGVyLndfaCkgLyBob2xkZXIud193KVxuXG4gIHdpbmRvdy5zZXR0aW5nc193YWxscGFwZXJzLmlubmVySFRNTCA9IEFycmF5KDEyKVxuICAgIC5maWxsKDEpXG4gICAgLm1hcCgoKSA9PiB7XG4gICAgICByZXR1cm4gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNldHRpbmdzLXdhbGwtcHJlXCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cIndpZHRoOiAke3dhbFd9cHg7IGhlaWdodDogJHt3YWxIfXB4OyBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoL2ltZy9wbGFjZWhvbGRlci5wbmcpXCJcbiAgICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgICAgIGBcbiAgICB9KVxuICAgIC5qb2luKCcnKVxuXG4gIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldCgnd2FsbHBhcGVycycsICh7IHdhbGxwYXBlcnMgfSkgPT4ge1xuICAgIHdpbmRvdy5zZXR0aW5nc193YWxscGFwZXJzLmlubmVySFRNTCA9IHdhbGxwYXBlcnNcbiAgICAgIC5tYXAoKHdhbGwsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCBjbGFzc05hbWUgPSAnc2V0dGluZ3Mtd2FsbC1wcmUnXG5cbiAgICAgICAgaWYgKHdhbGwuYWN0aXZlKSB7XG4gICAgICAgICAgY2xhc3NOYW1lICs9ICcgYWN0aXZlJ1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlubmVyID0gJydcblxuICAgICAgICBpZiAod2FsbC5lZGl0YmFsZSkge1xuICAgICAgICAgIGlubmVyICs9IGA8c3BhbiBjbGljay1lbWl0PVwic2V0dGluZ193YWxscGFwZXJfZWRpdDoke2luZGV4fVwiPkVESVQ8L3NwYW4+YFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWV9XCJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJ3aWR0aDogJHt3YWxXfXB4OyBoZWlnaHQ6ICR7d2FsSH1weDsgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7d2FsbC51cmx9KVwiXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrLWVtaXQ9XCJzZXR0aW5nX3dhbGxwYXBlcl90b2dnbGU6JHtpbmRleH1cIlxuICAgICAgICAgICAgICAgID4ke2lubmVyfTwvZGl2PlxuICAgICAgICAgICAgICAgIGBcbiAgICAgIH0pXG4gICAgICAuam9pbignJylcbiAgfSlcblxuICAvLyBSZW5kZXIgY29uZmlnXG4gIHdpbmRvdy5zZXR0aW5nX2NvbmZpZ19pbnB1dC52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHN0b3JhZ2UuY29uZmlnLCBudWxsLCAyKVxufVxuXG5zZXR0aW5nLnRvZ2dsZSA9IChzdGF0ZSkgPT4ge1xuICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXRlID0gIXNldHRpbmcuaXNPcGVuXG4gIH1cblxuICBzZXR0aW5nLmlzT3BlbiA9IHN0YXRlXG5cbiAgaWYgKHN0YXRlKSB7XG4gICAgd2luZG93LnNldHRpbmdfYm94LnJlbW92ZUNsYXNzKCdoaWRkZW4nKVxuICAgIHNldHRpbmcucmVuZGVyKClcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuc2V0dGluZ19ib3guYWRkQ2xhc3MoJ2hpZGRlbicpXG4gIH1cbn1cblxuZXZlbnQub24oJ3NldHRpbmdfY2xvc2UnLCAoKSA9PiB7XG4gIHNldHRpbmcudG9nZ2xlKGZhbHNlKVxufSlcblxuZXZlbnQub24oJ3NldHRpbmdfb3BlbicsICgpID0+IHtcbiAgc2V0dGluZy50b2dnbGUodHJ1ZSlcbn0pXG5cbmV2ZW50Lm9uKCdzZXR0aW5nX2JhY2t1cCcsIGFzeW5jICgpID0+IHtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICBjb25zdCBsb2NhbCA9IGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldCgpXG4gIGNvbnN0IGRhdGEgPSB7fVxuXG4gIGRhdGEubG9jYWwgPSBsb2NhbFxuICBkYXRhLnN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlXG5cbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShkYXRhKV0sIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pXG4gIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgY29uc3QgYW5jID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG5cbiAgYW5jLmhyZWYgPSB1cmxcbiAgYW5jLmRvd25sb2FkID0gJ3NlaW4tYmFja3VwLScgKyBub3cudG9Mb2NhbGVEYXRlU3RyaW5nKCkucmVwbGFjZSgvXFwvL2csICctJykgKyAnLmpzb24nXG5cbiAgYW5jLmNsaWNrKClcbiAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpXG59KVxuXG5ldmVudC5vbignc2V0dGluZ19yZXN0b3JlJywgKCkgPT4ge1xuICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgaW5wdXQudHlwZSA9ICdmaWxlJ1xuXG4gIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgJ2NoYW5nZScsXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IGlucHV0LmZpbGVzWzBdXG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGxvY2FsLCBzdG9yYWdlLCBub3RlcyB9ID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KVxuXG4gICAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3RvcmFnZSkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vba2V5XSA9IHN0b3JhZ2Vba2V5XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldChsb2NhbClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub3Rlcykge1xuICAgICAgICAgIG5vdGVyLm5vdGVzID0gbm90ZXNcbiAgICAgICAgICBub3Rlci5zYXZlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5hbGVydCgnUmVzdG9yZSBjb21wbGV0ZWQnKVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH0pXG5cbiAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpXG4gICAgfSxcbiAgICB7IG9uY2U6IHRydWUgfSxcbiAgKVxuXG4gIGlucHV0LmNsaWNrKClcbn0pXG5cbmV2ZW50Lm9uKCdzZXR0aW5nX2NvbmZpZ19zYXZlJywgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNvbmZpZyA9IEpTT04ucGFyc2Uod2luZG93LnNldHRpbmdfY29uZmlnX2lucHV0LnZhbHVlKVxuICAgIHN0b3JhZ2UuY29uZmlnID0gY29uZmlnXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgICByZXR1cm4gd2luZG93LmFsZXJ0KCdQYXJzZSBhbmQgc2F2ZSBjb25maWcgZXJyb3InKVxuICB9XG5cbiAgd2luZG93LmFsZXJ0KCdTYXZlIGNvbmZpZyBzdWNjZXNzJylcbn0pXG5cbmV2ZW50Lm9uKCdzZXR0aW5nX3dhbGxwYXBlcl90b2dnbGUnLCAoaW5kZXgsIHsgdGFyZ2V0IH0pID0+IHtcbiAgaW5kZXggPSAraW5kZXhcblxuICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoJ3dhbGxwYXBlcnMnLCAoeyB3YWxscGFwZXJzIH0pID0+IHtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHRhcmdldC5jbGFzc05hbWUuaW5kZXhPZignYWN0aXZlJykgIT09IC0xXG5cbiAgICB3YWxscGFwZXJzW2luZGV4XS5hY3RpdmUgPSAhaXNBY3RpdmVcbiAgICB3YWxscGFwZXIuY2FjaGUod2FsbHBhcGVycylcblxuICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7XG4gICAgICB3YWxscGFwZXJzLFxuICAgIH0pXG5cbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgIHRhcmdldC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LmFkZENsYXNzKCdhY3RpdmUnKVxuICAgIH1cbiAgfSlcbn0pXG5cbmV2ZW50Lm9uKCdzZXR0aW5nX3dhbGxwYXBlcl9lZGl0JywgKGluZGV4LCB7IHRhcmdldCB9KSA9PiB7XG4gIGluZGV4ID0gK2luZGV4XG5cbiAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gIGlucHV0LnR5cGUgPSAnZmlsZSdcblxuICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFxuICAgICdjaGFuZ2UnLFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSBpbnB1dC5maWxlc1swXVxuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuXG4gICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGZpbGUudHlwZS5zdGFydHNXaXRoKCd2aWRlby8nKSkge1xuICAgICAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpXG4gICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgICAgICAgIHZpZGVvLmNsYXNzTmFtZSA9ICdpbnZpc2libGUnXG4gICAgICAgICAgY2FudmFzLmNsYXNzTmFtZSA9ICdpbnZpc2libGUnXG5cbiAgICAgICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKCdzcmMnLCByZWFkZXIucmVzdWx0KVxuICAgICAgICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCBmaWxlLnR5cGUpXG4gICAgICAgICAgdmlkZW8uYXBwZW5kQ2hpbGQoc291cmNlKVxuICAgICAgICAgIHdpbmRvdy5zZXR0aW5nX2JveC5hcHBlbmRDaGlsZCh2aWRlbylcblxuICAgICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgKCkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGhcbiAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHZpZGVvLnZpZGVvSGVpZ2h0XG4gICAgICAgICAgICAgIHdpbmRvdy5zZXR0aW5nX2JveC5hcHBlbmRDaGlsZChjYW52YXMpXG5cbiAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodmlkZW8sIDAsIDAsIHZpZGVvLnZpZGVvV2lkdGgsIHZpZGVvLnZpZGVvSGVpZ2h0KVxuXG4gICAgICAgICAgICAgIGNvbnN0IHsgd2FsbHBhcGVycyB9ID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KCd3YWxscGFwZXJzJylcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycpXG5cbiAgICAgICAgICAgICAgd2luZG93LnNldHRpbmdfYm94LnJlbW92ZUNoaWxkKHZpZGVvKVxuICAgICAgICAgICAgICB3aW5kb3cuc2V0dGluZ19ib3gucmVtb3ZlQ2hpbGQoY2FudmFzKVxuXG4gICAgICAgICAgICAgIHdhbGxwYXBlcnNbaW5kZXhdLnVybCA9IHJlc3VsdFxuICAgICAgICAgICAgICB3YWxscGFwZXJzW2luZGV4XS52aWRlbyA9IGluZGV4XG5cbiAgICAgICAgICAgICAgd2FsbHBhcGVyLmNhY2hlKHdhbGxwYXBlcnMpXG5cbiAgICAgICAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHtcbiAgICAgICAgICAgICAgICB3YWxscGFwZXJzLFxuICAgICAgICAgICAgICAgIFtgd2FsbHBhcGVyX3ZpZGVvc18ke2luZGV4fWBdOiByZWFkZXIucmVzdWx0LFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXQucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgICBpdGVtLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtyZXN1bHR9KWBcbiAgICAgICAgICAgIH0sIDIwMClcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgICAgICAgY29uc3QgeyB3YWxscGFwZXJzIH0gPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoJ3dhbGxwYXBlcnMnKVxuXG4gICAgICAgICAgd2FsbHBhcGVyc1tpbmRleF0udXJsID0gcmVhZGVyLnJlc3VsdFxuXG4gICAgICAgICAgd2FsbHBhcGVyLmNhY2hlKHdhbGxwYXBlcnMpXG5cbiAgICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe1xuICAgICAgICAgICAgd2FsbHBhcGVycyxcbiAgICAgICAgICAgIFtgd2FsbHBhcGVyX3ZpZGVvc18ke2luZGV4fWBdOiAnJyxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc3QgaXRlbSA9IHRhcmdldC5wYXJlbnRFbGVtZW50XG4gICAgICAgICAgaXRlbS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7cmVhZGVyLnJlc3VsdH0pYFxuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBhbGVydCgnT25seSBhY2NlcHQgaW1hZ2Ugb3IgdmlkZW8nKVxuICAgICAgfSlcblxuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSlcbiAgICB9LFxuICAgIHsgb25jZTogdHJ1ZSB9LFxuICApXG5cbiAgaW5wdXQuY2xpY2soKVxufSlcblxuZXhwb3J0IGRlZmF1bHQgc2V0dGluZ1xuIiwiaW1wb3J0IHN0b3JhZ2UgZnJvbSAnLi9jb3JlL3N0b3JhZ2UnXG5cbmNvbnN0IHdhbGxwYXBlciA9IHtcbiAgZGVmYXVsdDoge1xuICAgIHdhbGxwYXBlcnM6IFtcbiAgICAgIHtcbiAgICAgICAgdXJsOiBgaW1nL3cwLmpwZ2AsXG4gICAgICAgIHZpZGVvOiAwLFxuICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IGBpbWcvdzEuanBnYCxcbiAgICAgICAgdmlkZW86IDEsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IGBpbWcvdzIuanBnYCxcbiAgICAgICAgdmlkZW86IDIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgbG9jYWw6IHtcbiAgICAgIHdhbGxwYXBlcl92aWRlb3NfMDogJ3ZpZGVvL3cwLm1wNCcsXG4gICAgICB3YWxscGFwZXJfdmlkZW9zXzE6ICd2aWRlby93MS5tcDQnLFxuICAgICAgd2FsbHBhcGVyX3ZpZGVvc18yOiAndmlkZW8vdzIubXA0JyxcbiAgICB9LFxuICB9LFxufVxuXG53YWxscGFwZXIuaW5pdCA9ICgpID0+IHtcbiAgY29uc3Qgd2FsbHBhcGVycyA9IHdhbGxwYXBlci5kZWZhdWx0LndhbGxwYXBlcnNcblxuICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe1xuICAgIC4uLndhbGxwYXBlci5kZWZhdWx0LmxvY2FsLFxuXG4gICAgd2FsbHBhcGVyczogd2FsbHBhcGVycy5jb25jYXQoXG4gICAgICBBcnJheSg5KS5maWxsKHtcbiAgICAgICAgdXJsOiBgaW1nL3BsYWNlaG9sZGVyLnBuZ2AsXG4gICAgICAgIGVkaXRiYWxlOiB0cnVlLFxuICAgICAgfSksXG4gICAgKSxcbiAgfSlcblxuICByZXR1cm4gd2FsbHBhcGVyLmNhY2hlKHdhbGxwYXBlcnMpXG59XG5cbndhbGxwYXBlci5jYWNoZSA9ICh3YWxscGFwZXJzKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYWN0aXZlcyA9IHdhbGxwYXBlcnMuZmlsdGVyKCh3KSA9PiB3LmFjdGl2ZSlcbiAgICBzdG9yYWdlLndhbGxwYXBlcnMgPSBhY3RpdmVzXG5cbiAgICByZXR1cm4gYWN0aXZlc1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGFsZXJ0KCdUaGUgdmFsdWUgb2Ygd2FsbHBhcGVycyBleGNlZWRlZCB0aGUgcXVvdGEnKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxud2FsbHBhcGVyLmJvb3QgPSAoKSA9PiB7XG4gIGNvbnN0IHdhbGxwYXBlcnMgPSBzdG9yYWdlLndhbGxwYXBlcnMgfHwgd2FsbHBhcGVyLmluaXQoKVxuICBjb25zdCBwaWNrID0gd2FsbHBhcGVyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB3YWxscGFwZXJzLmxlbmd0aCldXG5cbiAgaWYgKCFwaWNrKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB3aW5kb3cud2FsbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7cGljay51cmx9KWBcblxuICBpZiAocGljay52aWRlbyA+IC0xKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBgd2FsbHBhcGVyX3ZpZGVvc18ke3BpY2sudmlkZW99YFxuXG4gICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoa2V5LCAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKVxuXG4gICAgICAgIHNvdXJjZS5zcmMgPSBkYXRhW2tleV1cbiAgICAgICAgc291cmNlLnR5cGUgPSAndmlkZW8vbXA0J1xuXG4gICAgICAgIHdpbmRvdy53YWxsX3ZpZGVvLmFwcGVuZENoaWxkKHNvdXJjZSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3YWxscGFwZXJcbiIsImNvbnN0IHdhdmVyID0ge31cblxud2F2ZXIuYWRkID0gKHgsIHkpID0+IHtcbiAgd2luZG93LndhdmVfY2xpY2tfYm94LmlubmVySFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPVwid2F2ZSBhY3RpdmVcIiBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KVwiPlxuICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8ZGl2PjwvZGl2PlxuICAgIDwvZGl2PmBcbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoZXZlbnQpID0+IHtcbiAgd2F2ZXIuYWRkKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpXG59KVxuXG5leHBvcnQgZGVmYXVsdCB3YXZlclxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCAnLi9wcm90b3R5cGUnXG5pbXBvcnQgd2FsbHBhcGVyIGZyb20gJy4vd2FsbHBhcGVyJ1xuaW1wb3J0IGVtaXR0ZXIgZnJvbSAnLi9jb3JlL2VtaXR0ZXInXG5pbXBvcnQgc3RvcmFnZSBmcm9tICcuL2NvcmUvc3RvcmFnZSdcbmltcG9ydCBsb2dnZXIgZnJvbSAnLi9jb3JlL2xvZ2dlcidcbmltcG9ydCBub3RlciBmcm9tICcuL25vdGVyJ1xuaW1wb3J0IGJvb2ttYXJrIGZyb20gJy4vYm9va21hcmsnXG5pbXBvcnQgJy4vd2F2ZXInXG5pbXBvcnQgJy4vc2V0dGluZydcblxud2luZG93LmhvbGRlciA9IHtcbiAgd193OiB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuICB3X2g6IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LFxuXG4gIGNvZGVfdGFibGVzOiBbXG4gICAgeyBjb2RlOiAnZGF0ZT09JywgdmFsdWU6IG5ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCkgfSxcbiAgICB7IGNvZGU6ICd0aW1lPT0nLCB2YWx1ZTogbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKSB9LFxuICAgIHsgY29kZTogJ25vdz09JywgdmFsdWU6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSB9LFxuICAgIHsgY29kZTogJ25hbWVfKC4rPyk9PScsIHZhbHVlOiAnSGkgc2lyLCAkIDwzJyB9LFxuICBdLFxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xuICBob2xkZXIud193ID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuICBob2xkZXIud19oID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbn0pXG5cbndhbGxwYXBlci5ib290KClcbm5vdGVyLmJvb3QoKVxuYm9va21hcmsuYm9vdCgpXG5lbWl0dGVyLmNsaWNrKClcblxuc3RvcmFnZS5jb25maWcgPSBPYmplY3QuYXNzaWduKFxuICB7XG4gICAgbG9nX2xldmVsOiAnZXJyb3InLFxuICAgIG51bWJlcl9vZl93b3Jrc3BhY2U6IDIsXG4gIH0sXG4gIHN0b3JhZ2UuY29uZmlnLFxuKVxuXG5pZiAoc3RvcmFnZS53b3Jrc3BhY2UpIHtcbiAgaWYgKHN0b3JhZ2Uud29ya3NwYWNlID09PSAtMSkge1xuICAgIHN0b3JhZ2Uud29ya3NwYWNlKytcbiAgfVxuXG4gIHdpbmRvdy5zd2l0Y2hfd29ya3NwYWNlX2J0bi5pbm5lckhUTUwgPSBzdG9yYWdlLndvcmtzcGFjZVxufSBlbHNlIHtcbiAgd2luZG93LnN3aXRjaF93b3Jrc3BhY2VfYnRuLmlubmVySFRNTCA9ICcwJ1xufVxuXG5sb2dnZXIubG9nX2xldmVsID0gc3RvcmFnZS5jb25maWcubG9nX2xldmVsXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=