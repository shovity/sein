/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/bookmark.js":
/*!*************************!*\
  !*** ./src/bookmark.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");


const bookmark = {
  bookmarkBarElement: window.bookmark_bar,
}

/**
 * Create bookmark item from bookmark nodes
 * @param  {Object} node
 * @return {string} HTML generated by bookmark node
 */
bookmark.create = (node) => {
  const { url, title, children } = node

  if (children) {
    setTimeout(() => bookmark.render(node))
    return ''
  }

  return `
    <a class="item" href="${url}">
        <img src="${chrome.runtime.getURL('/_favicon/')}?pageUrl=${url}">
        <div class="title">${title}</div>
    </a>`
}

/**
 * Create a parent of bookmark, this is a group of bookmark items
 * @param  {Object} node
 * @return {string}      HTML generated by bookmark nodes
 */
bookmark.createParent = (node) => {
  const label = node.title
  const nodes = node.children
  const childs = nodes.map((node) => bookmark.create(node)).join('')
  const parentId = `${label}-${node.parentId || 'root'}`
  const status = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][`bookmark:parent:${parentId}`] || 'open'

  return `
    <div class="parent ${status}">
        <div class="parent-header" data-parent-id="${parentId}">
            <span class="icon icon-folder"></span>
            <div class="label">${label}</div>
        </div>
        <div class="stopgrap"></div>
        <div class="parent-childs">${childs}</div>
    </div>`
}

/**
 * Render bookmark from bookmark node
 * @param  {Object}  node
 * @param  {Boolean} [clear=false] clean bookmark bar before render
 */
bookmark.render = (node, clear = false) => {
  if (clear) {
    bookmark.bookmarkBarElement.innerHTML = ''
  }

  bookmark.bookmarkBarElement.innerHTML += bookmark.createParent(node)
}

/**
 * Toggle open parent
 * @param  {string} id
 */
bookmark.toggleOpenParent = (id) => {
  const open = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][`bookmark:parent:${id}`] === 'close' ? 'open' : 'close'
  _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][`bookmark:parent:${id}`] = open
  document.querySelector(`[data-parent-id="${id}"]`).parentNode.className = `parent ${open}`
}

bookmark.fetch = () => {
  chrome.topSites.get((tops) => {
    bookmark.render({ children: tops, title: 'Most visited' }, true)

    chrome.bookmarks.getTree((bookmarks) => {
      bookmark.render(bookmarks[0].children[0])
    })
  })
}

bookmark.boot = () => {
  bookmark.bookmarkBarElement.addEventListener('click', ({ target }) => {
    const id = target.getAttribute('data-parent-id') || target.parentNode.getAttribute('data-parent-id')

    if (id) {
      bookmark.toggleOpenParent(id)
    }
  })

  chrome.bookmarks.onCreated.addListener(bookmark.fetch)
  chrome.bookmarks.onRemoved.addListener(bookmark.fetch)
  chrome.bookmarks.onChanged.addListener(bookmark.fetch)
  chrome.bookmarks.onMoved.addListener(bookmark.fetch)

  bookmark.fetch()
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bookmark);


/***/ }),

/***/ "./src/core/emitter.js":
/*!*****************************!*\
  !*** ./src/core/emitter.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/core/logger.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event */ "./src/core/event.js");



const emitter = {
  mounted: {},
}

/**
 * Emitter generator
 * @param name {string} Emitter name
 * @param handle {function} Call one time for setup emitter
 */
emitter.gen = (name, handle) => {
  if (emitter[name] || !/^[a-zA-Z][a-zA-Z0-9_]{0,63}$/.test(name)) {
    return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error(`emitter: Name "${name}" existed or invalid`)
  }

  emitter[name] = () => {
    if (emitter.mounted[name]) {
      return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error(`emitter: Duplicate mount emitter ${name}`)
    }

    handle()

    emitter.mounted[name] = true
  }
}

/**
 * Define emitter
 * ==============
 */

emitter.gen('click', () => {
  function handleClickR(target, domEvent, up = 0) {
    if (up > 5 || !target) {
      return
    }

    const clickEmit = target.getAttribute('click-emit')

    if (!clickEmit) {
      return handleClickR(target.parentElement, domEvent, up + 1)
    }

    const name = clickEmit.split(':')[0]

    let payload = clickEmit.split(':').slice(1).join(':')

    // handle object payload
    if (payload[0] === '?') {
      const payloadObject = {}
      payload
        .slice(1)
        .split('&')
        .forEach((q) => {
          const [key, value] = q.split('=')
          if (key === '') {
            return
          }
          payloadObject[key] = value
        })
      payload = payloadObject
    }

    _event__WEBPACK_IMPORTED_MODULE_1__["default"].next(name, payload, { target, domEvent })
  }

  window.document.body.addEventListener('click', (domEvent) => {
    handleClickR(domEvent.target, domEvent)
  })

  _logger__WEBPACK_IMPORTED_MODULE_0__["default"].info('emiter: Click emiter mounted')
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (emitter);


/***/ }),

/***/ "./src/core/event.js":
/*!***************************!*\
  !*** ./src/core/event.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const event = {
  pool: {},
}

event.emit = (name, ...payload) => {
  for (const handle of event.pool[name] ?? []) {
    handle(...payload)
  }
}

event.on = (name, handle) => {
  event.pool[name]?.push(handle) || (event.pool[name] = [handle])
}

event.next = (name, ...payload) => {
  setTimeout(event.emit, 0, name, ...payload)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (event);


/***/ }),

/***/ "./src/core/logger.js":
/*!****************************!*\
  !*** ./src/core/logger.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const LEVEL = ['debug', 'info', 'warning', 'error']

const logger = {
  log_level: 'debug',

  get debug() {
    if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('debug')) {
      return console.debug.bind(window.console, '%cDEBUG  :', 'color: #6c757d')
    }

    return () => undefined
  },

  get info() {
    if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('info')) {
      return console.info.bind(window.console, '%cINFO   :', 'color: #17a2b8')
    }

    return () => undefined
  },

  get warning() {
    if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('warning')) {
      return console.warn.bind(window.console, '%cWARNING:', 'color: #ffc107')
    }

    return () => undefined
  },

  get error() {
    if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('error')) {
      return console.error.bind(window.error, '%cERROR  :', 'color: #dc3545')
    }

    return () => undefined
  },
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (logger);


/***/ }),

/***/ "./src/core/storage.js":
/*!*****************************!*\
  !*** ./src/core/storage.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/core/logger.js");


const storage = {}
const handler = {}

handler.get = (target, key) => {
  if (key === 'origin') {
    return target
  }

  const raw = window.localStorage[key]

  try {
    return raw && JSON.parse(raw)
  } catch (error) {
    return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error('storage: Parse json fail, key: ', key)
  }
}

handler.set = (target, key, value) => {
  window.localStorage[key] = JSON.stringify(value)
  target[key] = value
  return true
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Proxy(storage, handler));


/***/ }),

/***/ "./src/core/util.js":
/*!**************************!*\
  !*** ./src/core/util.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const util = {}

util.throttle = (wait = 200, trailling = true) => {
  const instance = {
    lock: false,
    handle: null,
  }

  instance.execute = (handle, ...args) => {
    instance.handle = handle

    if (instance.lock) {
      return
    }

    instance.lock = true
    instance.handle(...args)
    instance.handle = null

    setTimeout(() => {
      instance.lock = false

      if (trailling && instance.handle) {
        instance.execute(instance.handle, ...args)
      }
    }, wait)
  }

  return instance
}

util.debounce = (wait = 200) => {
  const instance = {
    timeout: null,
  }

  instance.execute = (handle, ...args) => {
    clearTimeout(instance.timeout)
    instance.timeout = setTimeout(handle, wait, ...args)
  }

  return instance
}

util.raf = () => {
  const instance = {
    lock: false,
    handle: null,
  }

  instance.execute = (handle, ...args) => {
    instance.handle = handle

    if (instance.lock) {
      return
    }

    instance.lock = true

    window.requestAnimationFrame(() => {
      instance.lock = false
      instance.handle(...args)
    })
  }

  return instance
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (util);


/***/ }),

/***/ "./src/modal.js":
/*!**********************!*\
  !*** ./src/modal.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const modal = {}

modal.hide = () => {
  window.modal.removeClass('modal-show')
}

modal.show = (content) => {
  window.modal_content.innerHTML = content
  window.modal.addClass('modal-show')
}

window.modal.addEventListener('click', ({ target }) => {
  if (target.id === 'modal') {
    modal.hide()
  }
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (modal);


/***/ }),

/***/ "./src/noter.js":
/*!**********************!*\
  !*** ./src/noter.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/logger */ "./src/core/logger.js");
/* harmony import */ var _core_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/event */ "./src/core/event.js");
/* harmony import */ var _core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/util */ "./src/core/util.js");
/* harmony import */ var _modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modal */ "./src/modal.js");






const noter = {
  pull_cooldown: 10000,

  call: {
    move: _core_util__WEBPACK_IMPORTED_MODULE_3__["default"].raf(),
    sync: _core_util__WEBPACK_IMPORTED_MODULE_3__["default"].throttle(),
    push: _core_util__WEBPACK_IMPORTED_MODULE_3__["default"].debounce(1000),
  },

  version: null,
  eqCodeReady: null,
  notes: [],
}

noter.fetch = async () => {
  const local = await chrome.storage.local.get(['notes', 'version'])

  noter.notes = local.notes || []
  noter.version = local.version
  noter.render()
}

noter.save = () => {
  const version = Date.now()

  chrome.storage.local.set({
    notes: noter.notes,
    version,
  })

  noter.version = version
  noter.call.push.execute(noter.push)

  _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('noter: Noter save:', noter.notes)
}

noter.createObject = (note) => {
  const defaultData = {
    msg: '',
    x: Math.floor(Math.random() * (holder.w_w - 500)),
    y: Math.floor(Math.random() * (holder.w_h - 250)),
    w: 300,
    h: 100,
    workspace: _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0,
    status: 'default',
  }

  return Object.assign(defaultData, note)
}

noter.createElement = (note) => {
  const dom = document.createElement('div')

  dom.setAttribute('id', `noteid_${note.id}`)
  dom.setAttribute('class', 'note')
  dom.setAttribute('style', `transform: translate(${note.x}px, ${note.y}px)`)
  dom.setAttribute('note-status', note.status || 'default')

  dom.innerHTML = `
    <div class="note-controls" note-move-id="${note.id}">
        <div class="note-remove" click-emit="note_remove:${note.id}">&times;</div>
    </div>
    <div class="note-rainbow">
        <div click-emit="note_mark:${note.id},primary"></div>
        <div click-emit="note_mark:${note.id},success"></div>
        <div click-emit="note_mark:${note.id},danger"></div>
    </div>
    <div class="note-editor"
        contenteditable="true"
        spellcheck="false"
        note-editor-id="${note.id}"
        style="width:${note.w}px;height:${note.h - 20}px"
    >${note.msg}</div>`

  noter.handleHashtag(dom)

  return dom
}

noter.add = (note) => {
  // New note don't have a id, push it to noter.notes
  if (note.id === undefined) {
    note.id = Date.now().toString()
    note.updatedAt = Date.now()
    noter.notes.push(note)
  }

  // Render html
  window.note_box.appendChild(noter.createElement(note))
}

noter.render = (clear = true, workspace = +_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0) => {
  // Clear before render
  if (clear) {
    window.note_box.innerHTML = ''
  }

  // Loop adding
  for (const note of noter.notes) {
    if (workspace === note.workspace) {
      noter.add(note)
    }
  }

  _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('noter: Render note', noter.notes)
}

noter.handleEqcode = (editor) => {
  // Insert marker
  const sel = window.getSelection()
  const range = sel.getRangeAt(0)
  const markerEl = document.createElement('span')
  markerEl.id = 'caret-marker'
  markerEl.appendChild(document.createTextNode('\u200B'))
  range.insertNode(markerEl)

  const string = editor.innerHTML

  holder.code_tables.forEach((code) => {
    const cregex = new RegExp(code.code)
    const result = string.match(cregex)

    if (result) {
      // Data embedded in command code ex. 'name_(.+?)=='
      const replaces = result.slice(1)
      let codeValue = code.value

      for (const replace of replaces) {
        codeValue = codeValue.replace('$', replace)
      }

      editor.innerHTML = string.replace(cregex, codeValue)
    }
  })

  // Restore carte and remove marker
  const newMarker = document.getElementById('caret-marker')

  if (newMarker) {
    const newRange = document.createRange()
    newRange.setStartAfter(newMarker)
    newRange.collapse(true)
    newMarker.parentNode.removeChild(newMarker)
    sel.removeAllRanges()
    sel.addRange(newRange)
  }
}

noter.handleHashtag = (dom) => {
  const editor = dom.querySelector('.note-editor')
  const head = editor.innerHTML.slice(0, 256)

  const hashtags = head.match(/#[a-z0-9_]{1,12}/gi) || []
  const classes = ['note']

  if (hashtags.includes('#mono')) {
    classes.push('note-ffm')
  }

  dom.className = classes.join(' ')
}

noter.remove = (id) => {
  const index = noter.notes.findIndex((note) => note.id == id)

  if (_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace === -1 || !noter.notes[index].msg.replace(/(<br>)| /g, '')) {
    noter.notes.splice(index, 1)
  } else {
    noter.notes[index].workspace = -1
    noter.notes[index].removeAt = Date.now()
    noter.notes[index].updatedAt = Date.now()
  }

  // Remove dom
  const dom = window[`noteid_${id}`]
  dom.parentElement.removeChild(dom)

  noter.save()
}

noter.mark = (id, status) => {
  const note = noter.notes.find((n) => n.id == id)

  if (note.status === status) {
    note.status = 'default'
  } else {
    note.status = status
  }

  window[`noteid_${id}`].setAttribute('note-status', note.status)
  noter.save()
}

noter.handleOnChange = ({ target, key }) => {
  const id = target.getAttribute('note-editor-id')

  if (id) {
    const index = noter.notes.findIndex((note) => note.id == id)

    // Check changed
    if (noter.notes[index].msg === target.innerHTML) {
      return
    }

    // Handle note hashtag
    noter.handleHashtag(target.parentElement)

    // Handle note code
    if (key === '=') {
      if (noter.eqCodeReady) {
        noter.handleEqcode(target)
        noter.eqCodeReady = false
      } else {
        noter.eqCodeReady = true
      }
    }

    noter.notes[index].msg = target.innerHTML
    noter.notes[index].updatedAt = Date.now()

    noter.save()
  }
}

noter.pull = async () => {
  if (!_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config.sync_url) {
    return
  }

  if (_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].pull_date > Date.now() - noter.pull_cooldown) {
    return
  }

  const [url, secret] = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config.sync_url.split('#')

  const now = Date.now()

  const excludes = noter.notes.filter((note) => {
    return note.updatedAt >= +_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].pull_date
  })

  const exclude = excludes
    .map((note) => {
      return `${note.id}:${note.updatedAt}`
    })
    .join(',')

  const response = await fetch(`${url}?date=${_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].pull_date || 0}&exclude=${exclude}`, {
    method: 'GET',
    headers: {
      'X-Secret': secret,
    },
  })

  const { data } = await response.json()

  if (data?.length) {
    const map = {}
    let shouldRender = false

    for (const note of noter.notes) {
      map[note.id] = note
    }

    for (const { raw: note } of data) {
      if (!map[note.id]?.updatedAt || map[note.id].updatedAt < note.updatedAt) {
        map[note.id] = note
        shouldRender = true
      }
    }

    if (shouldRender) {
      noter.notes = Object.values(map)
      noter.render()
      noter.save()
    }
  }

  _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].pull_date = now
}

noter.push = async () => {
  if (!_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config.sync_url) {
    return
  }

  const notes = noter.notes.filter((note) => {
    return +note.updatedAt > (+_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].push_date || 0) && note.msg
  })

  const now = Date.now()
  const [url, secret] = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config.sync_url.split('#')

  if (notes.length) {
    await fetch(url, {
      method: 'POST',
      body: JSON.stringify({ notes }),
      headers: {
        'Content-Type': 'application/json',
        'X-Secret': secret,
      },
    })
  }

  _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].push_date = now
}

noter.clearTrash = () => {
  if (_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].last_clear_trash > Date.now() - 8e7) {
    return
  }

  _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].last_clear_trash = Date.now()

  noter.notes = noter.notes.filter((note) => {
    if (note.workspace !== -1) {
      return true
    }

    if (note.removeAt > Date.now() - 864e5 * 30) {
      return true
    }
  })

  noter.save()
}

noter.sort = (screenWidth, screenHeight) => {
  if (!noter.notes.length) return

  // Get current workspace notes
  const workspace = +_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0
  const workspaceNotes = noter.notes.filter((note) => note.workspace === workspace)

  if (!workspaceNotes.length) return

  // Available screen dimensions
  if (!screenWidth) {
    screenWidth = holder.w_w - 50
  }

  if (!screenHeight) {
    screenHeight = holder.w_h
  }

  const spacing = 10
  const leftMargin = 10
  const topMargin = 10

  // Sort notes by height (tallest first) for better column packing
  const sortedNotes = [...workspaceNotes].sort((a, b) => b.h - a.h)

  // Column-based packing algorithm (top to bottom, left to right)
  const placedNotes = []
  const unplacedNotes = [...sortedNotes]
  let currentX = leftMargin
  let currentY = topMargin
  let columnWidth = 0
  let maxY = topMargin

  // Helper function to check if two notes overlap
  const doNotesOverlap = (note1, note2) => {
    return (
      note1.x < note2.x + note2.w + spacing &&
      note1.x + note1.w + spacing > note2.x &&
      note1.y < note2.y + note2.h + spacing &&
      note1.y + note1.h + spacing > note2.y
    )
  }

  // Helper function to shift overlapping notes to the right
  const shiftOverlappingNotes = (newNote, placedNotes) => {
    let maxShift = 0

    for (const placedNote of placedNotes) {
      if (doNotesOverlap(newNote, placedNote)) {
        // Calculate how much we need to shift the new note to the right
        const requiredShift = placedNote.x + placedNote.w + spacing - newNote.x
        maxShift = Math.max(maxShift, requiredShift)
      }
    }

    return maxShift
  }

  while (unplacedNotes.length > 0) {
    let notePlaced = false

    // Try to find the tallest note that fits in current column
    for (let i = 0; i < unplacedNotes.length; i++) {
      const note = unplacedNotes[i]

      // Check if note fits in current column
      if (currentY + note.h + spacing <= screenHeight) {
        // Place note in current column
        note.x = currentX
        note.y = currentY

        // Check for overlaps and shift if necessary
        const shiftAmount = shiftOverlappingNotes(note, placedNotes)
        if (shiftAmount > 0) {
          note.x += shiftAmount

          // Check if shifted position still fits within screen bounds
          if (note.x + note.w > screenWidth) {
            // If it doesn't fit, try to find a better position
            continue
          }
        }

        currentY += note.h + spacing
        columnWidth = Math.max(columnWidth, note.w)

        // Remove note from unplaced list
        unplacedNotes.splice(i, 1)
        placedNotes.push(note)
        notePlaced = true
        break
      }
    }

    // If no note fits in current column, find best position for next note
    if (!notePlaced) {
      // Find the best available position for the tallest remaining note
      let bestX = leftMargin
      let bestY = topMargin
      let foundPosition = false

      if (unplacedNotes.length > 0) {
        const note = unplacedNotes[0]

        // Try to find a position that fits
        for (let testY = topMargin; testY <= screenHeight - note.h; testY += spacing) {
          for (let testX = leftMargin; testX <= screenWidth - note.w; testX += spacing) {
            // Set temporary position for overlap checking
            note.x = testX
            note.y = testY

            // Check if this position overlaps with any placed notes
            let canPlace = true
            for (const placedNote of placedNotes) {
              if (doNotesOverlap(note, placedNote)) {
                canPlace = false
                break
              }
            }

            if (canPlace) {
              bestX = testX
              bestY = testY
              foundPosition = true
              break
            }
          }
          if (foundPosition) break
        }

        // If no direct position found, try shifting approach
        if (!foundPosition) {
          // Try placing at leftmost position and shift if needed
          note.x = leftMargin
          note.y = topMargin

          const shiftAmount = shiftOverlappingNotes(note, placedNotes)
          if (shiftAmount > 0 && note.x + shiftAmount + note.w <= screenWidth) {
            note.x += shiftAmount
            foundPosition = true
          }
        }

        // Place the note at the best position found
        if (foundPosition) {
          currentX = note.x
          currentY = note.y + note.h + spacing
          columnWidth = note.w

          unplacedNotes.splice(0, 1)
          placedNotes.push(note)
        } else {
          // If still can't place, place it at a random position on screen
          const randomX = Math.floor(Math.random() * (screenWidth - note.w - leftMargin)) + leftMargin
          const randomY = Math.floor(Math.random() * (screenHeight - note.h - topMargin)) + topMargin

          note.x = randomX
          note.y = randomY

          // Update current position for next iteration
          currentX = leftMargin
          currentY = maxY + spacing
          columnWidth = Math.max(columnWidth, note.w)

          unplacedNotes.splice(0, 1)
          placedNotes.push(note)
        }
      }
    }

    // Update maxY
    for (const note of placedNotes) {
      maxY = Math.max(maxY, note.y + note.h)
    }
  }

  // Update all notes with new positions
  for (const note of workspaceNotes) {
    const index = noter.notes.findIndex((n) => n.id === note.id)
    if (index !== -1) {
      noter.notes[index].x = note.x
      noter.notes[index].y = note.y
      noter.notes[index].updatedAt = Date.now()
    }
  }

  // Re-render and save
  noter.render()
  noter.save()

  _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('noter: Sorted notes using column-based packing algorithm with overlap shifting')
}

noter.boot = () => {
  const state = {
    resize: false,
    move: false,
    deltaX: 0,
    deltaY: 0,
  }

  _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('note_remove', (id) => {
    noter.remove(id)
  })

  _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('note_mark', (mark) => {
    const [id, status] = mark.split(',')
    noter.mark(id, status)
  })

  // Handle move
  window.note_box.addEventListener('mousedown', (event) => {
    // Prevent right mouse
    if (event.which === 3) {
      return
    }

    const { target } = event

    // Detect resize
    if (target.getAttribute('note-editor-id') !== null) {
      // TODO: Handle disable select when resize
      const cx = event.clientX
      const cy = event.clientY
      const noteId = +target.getAttribute('note-editor-id')
      const noteIndex = noter.notes.findIndex((note) => note.id == noteId)
      const note = noter.notes[noteIndex]

      // Detect mouse down over resize btn
      if (note.x + note.w - cx < 15 && note.y + note.h - cy < 15) {
        state.resize = noteId
      }
    }

    if (target.getAttribute('note-move-id') !== null) {
      // Disable text selection
      document.body.style.userSelect = 'none'

      const noteId = +target.getAttribute('note-move-id')
      const noteIndex = noter.notes.findIndex((note) => note.id == noteId)

      // Fix position mouse vs note
      state.deltaX = event.clientX - noter.notes[noteIndex].x
      state.deltaY = event.clientY - noter.notes[noteIndex].y

      // Start move handle
      state.move = noteId
    }
  })

  window.addEventListener('mousemove', (event) => {
    if (state.move === false) {
      return
    }

    event.preventDefault()

    noter.call.move.execute(() => {
      const dom = window[`noteid_${state.move}`]

      if (dom) {
        const x = Math.min(holder.w_w - 20, Math.max(event.clientX - state.deltaX, 0))
        const y = Math.min(holder.w_h - 20, Math.max(event.clientY - state.deltaY, 0))
        dom.style.transform = `translate(${x}px, ${y}px)`
      }
    })
  })

  window.addEventListener('mouseup', (event) => {
    // Recover text selection
    document.body.style.userSelect = ''

    if (state.move !== false) {
      const x = event.clientX - state.deltaX
      const y = event.clientY - state.deltaY
      const note = noter.notes.find((e) => e.id == state.move)

      if (note) {
        note.x = Math.max(0, Math.min(holder.w_w, x))
        note.y = Math.max(0, Math.min(holder.w_h, y))
        note.updatedAt = Date.now()
      }

      // End move handle
      state.move = false

      // Save when done move a note
      noter.save()
    } else if (state.resize !== false) {
      const note = noter.notes.find((e) => e.id == state.resize)

      if (note) {
        note.w = window['noteid_' + state.resize].offsetWidth
        note.h = window['noteid_' + state.resize].offsetHeight
        note.updatedAt = Date.now()
      }

      // End resize handle
      state.resize = false

      // Save when done move a note
      noter.save()
    }
  })

  window.note_box.addEventListener('keyup', noter.handleOnChange)
  window.note_box.addEventListener('paste', noter.handleOnChange)

  window.note_box.addEventListener('click', ({ target }) => {
    if (target.tagName === 'IMG') {
      _modal__WEBPACK_IMPORTED_MODULE_4__["default"].show(`<img src="${target.src}" style="max-width: calc(100vw - 50px)">`)
    }
  })

  // Listen add note
  _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('noter_add', () => {
    noter.add(noter.createObject())
    noter.save()
  })

  // Listen switch workspace
  _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('noter_switch_workspace', () => {
    let workspace = +_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0

    if (workspace > _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config.number_of_workspace - 2) {
      workspace = -1
    } else {
      workspace++
    }

    window.btn_switch_workspace.innerHTML = workspace === -1 ? '🗑️' : workspace
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace = workspace

    noter.save()
    noter.render()
  })

  // Handle drag to sort
  if (window.btn_sort_note) {
    let resizing = false

    const caller = _core_util__WEBPACK_IMPORTED_MODULE_3__["default"].throttle(100)

    window.btn_sort_note.addEventListener('mousedown', (event) => {
      resizing = true

      caller.execute(() => {
        noter.sort()
      })
    })

    window.addEventListener('mousemove', (event) => {
      if (!event.buttons || !resizing) {
        return
      }

      caller.execute(() => {
        noter.sort(event.clientX, event.clientY)
      })
    })

    window.addEventListener('mouseup', () => {
      resizing = false
    })
  }

  // Listen sync notes cross tab
  chrome.storage.onChanged.addListener((change, namespace) => {
    if (namespace !== 'local') {
      return
    }

    noter.call.sync.execute(() => {
      if (change.notes && change.version?.newValue > noter.version) {
        noter.notes = change.notes.newValue
        noter.render()
      }
    })
  })

  noter.fetch().then(async () => {
    noter.clearTrash()
    await noter.push()
    await noter.pull()
  })
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (noter);


/***/ }),

/***/ "./src/prototype.js":
/*!**************************!*\
  !*** ./src/prototype.js ***!
  \**************************/
/***/ (() => {

Array.prototype.sum = function () {
  return this.reduce((acc, e) => acc + e)
}

HTMLElement.prototype.addClass = function (className) {
  const regex = new RegExp(`^${className}$|^${className} | ${className}$| ${className}( )`, 'g')
  if (!regex.test(this.className)) {
    this.className = `${this.className} ${className}`.trim()
  }
}

HTMLElement.prototype.removeClass = function (className) {
  const regex = new RegExp(`^${className}$|^${className} | ${className}$| ${className}( )`, 'g')
  this.className = this.className.replace(regex, '$1').trim()
}

HTMLCollection.prototype.toArray = function () {
  return [...this]
}

NodeList.prototype.toArray = function () {
  return [...this]
}


/***/ }),

/***/ "./src/setting.js":
/*!************************!*\
  !*** ./src/setting.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/event */ "./src/core/event.js");
/* harmony import */ var _noter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noter */ "./src/noter.js");
/* harmony import */ var _wallpaper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wallpaper */ "./src/wallpaper.js");





const setting = {
  isOpen: false,
  blob_buffer_url: null,
}

setting.render = () => {
  // Render wallpaper
  const walW = Math.floor(window.settings_wallpapers.clientWidth / 6 - 11)
  const walH = Math.floor((walW * holder.w_h) / holder.w_w)

  window.settings_wallpapers.innerHTML = Array(12)
    .fill(1)
    .map(() => {
      return `
            <div class="settings-wall-pre"
                style="width: ${walW}px; height: ${walH}px; background-image: url(/img/placeholder.png)"
            ></div>
            `
    })
    .join('')

  chrome.storage.local.get('wallpapers', ({ wallpapers }) => {
    window.settings_wallpapers.innerHTML = wallpapers
      .map((wall, index) => {
        let className = 'settings-wall-pre'

        if (wall.active) {
          className += ' active'
        }

        let inner = ''

        if (wall.editbale) {
          inner += `<span click-emit="setting_wallpaper_edit:${index}">EDIT</span>`
        }

        return `
                <div class="${className}"
                    style="width: ${walW}px; height: ${walH}px; background-image: url(${wall.url})"
                    click-emit="setting_wallpaper_toggle:${index}"
                >${inner}</div>
                `
      })
      .join('')
  })

  // Render config
  window.setting_config_input.value = JSON.stringify(_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config, null, 2)
}

setting.toggle = (state) => {
  if (state === undefined) {
    state = !setting.isOpen
  }

  setting.isOpen = state

  if (state) {
    window.setting_box.removeClass('hidden')
    setting.render()
  } else {
    window.setting_box.addClass('hidden')
  }
}

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_close', () => {
  setting.toggle(false)
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_open', () => {
  setting.toggle(true)
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_backup', async () => {
  const now = new Date()
  const local = await chrome.storage.local.get()
  const data = {}

  data.local = local
  data.storage = window.localStorage

  const blob = new Blob([JSON.stringify(data)], { type: 'text/plain' })
  const url = URL.createObjectURL(blob)
  const anc = document.createElement('a')

  anc.href = url
  anc.download = 'sein-backup-' + now.toLocaleDateString().replace(/\//g, '-') + '.json'

  anc.click()
  URL.revokeObjectURL(url)
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_restore', () => {
  const input = document.createElement('input')
  input.type = 'file'

  input.addEventListener(
    'change',
    () => {
      const file = input.files[0]
      const reader = new FileReader()

      reader.addEventListener('load', async () => {
        const { local, storage, notes } = JSON.parse(reader.result)

        if (storage) {
          for (const key of Object.keys(storage)) {
            window.localStorage[key] = storage[key]
          }
        }

        if (local) {
          await chrome.storage.local.set(local)
        }

        if (notes) {
          _noter__WEBPACK_IMPORTED_MODULE_2__["default"].notes = notes
          _noter__WEBPACK_IMPORTED_MODULE_2__["default"].save()
        }

        window.alert('Restore completed')
        window.location.reload()
      })

      reader.readAsText(file)
    },
    { once: true },
  )

  input.click()
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_config_save', () => {
  try {
    const config = JSON.parse(window.setting_config_input.value)
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config = config
  } catch (error) {
    console.error(error)
    return window.alert('Parse and save config error')
  }

  window.alert('Save config success')
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_wallpaper_toggle', (index, { target }) => {
  index = +index

  chrome.storage.local.get('wallpapers', ({ wallpapers }) => {
    const isActive = target.className.indexOf('active') !== -1

    wallpapers[index].active = !isActive
    _wallpaper__WEBPACK_IMPORTED_MODULE_3__["default"].cache(wallpapers)

    chrome.storage.local.set({
      wallpapers,
    })

    if (isActive) {
      target.removeClass('active')
    } else {
      target.addClass('active')
    }
  })
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_wallpaper_edit', (index, { target }) => {
  index = +index

  const input = document.createElement('input')
  input.type = 'file'

  input.addEventListener(
    'change',
    () => {
      const file = input.files[0]
      const reader = new FileReader()

      reader.addEventListener('load', async () => {
        if (file.type.startsWith('video/')) {
          const video = document.createElement('video')
          const source = document.createElement('source')
          const canvas = document.createElement('canvas')
          const context = canvas.getContext('2d')

          video.className = 'invisible'
          canvas.className = 'invisible'

          source.setAttribute('src', reader.result)
          source.setAttribute('type', file.type)
          video.appendChild(source)
          window.setting_box.appendChild(video)

          video.addEventListener('canplaythrough', () => {
            setTimeout(async () => {
              canvas.width = video.videoWidth
              canvas.height = video.videoHeight
              window.setting_box.appendChild(canvas)

              context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight)

              const { wallpapers } = await chrome.storage.local.get('wallpapers')
              const result = canvas.toDataURL('image/jpeg')

              window.setting_box.removeChild(video)
              window.setting_box.removeChild(canvas)

              wallpapers[index].url = result
              wallpapers[index].video = index

              _wallpaper__WEBPACK_IMPORTED_MODULE_3__["default"].cache(wallpapers)

              chrome.storage.local.set({
                wallpapers,
                [`wallpaper_videos_${index}`]: reader.result,
              })

              const item = target.parentElement
              item.style.backgroundImage = `url(${result})`
            }, 200)
          })

          return
        }

        if (file.type.startsWith('image/')) {
          const { wallpapers } = await chrome.storage.local.get('wallpapers')

          wallpapers[index].url = reader.result

          _wallpaper__WEBPACK_IMPORTED_MODULE_3__["default"].cache(wallpapers)

          chrome.storage.local.set({
            wallpapers,
            [`wallpaper_videos_${index}`]: '',
          })

          const item = target.parentElement
          item.style.backgroundImage = `url(${reader.result})`

          return
        }

        alert('Only accept image or video')
      })

      reader.readAsDataURL(file)
    },
    { once: true },
  )

  input.click()
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setting);


/***/ }),

/***/ "./src/wallpaper.js":
/*!**************************!*\
  !*** ./src/wallpaper.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");


const wallpaper = {
  default: {
    wallpapers: [
      {
        url: `img/w0.jpg`,
        video: 0,
        active: true,
      },
      {
        url: `img/w1.jpg`,
        video: 1,
      },
      {
        url: `img/w2.jpg`,
        video: 2,
      },
    ],
    local: {
      wallpaper_videos_0: 'video/w0.mp4',
      wallpaper_videos_1: 'video/w1.mp4',
      wallpaper_videos_2: 'video/w2.mp4',
    },
  },
}

wallpaper.init = () => {
  const wallpapers = wallpaper.default.wallpapers

  chrome.storage.local.set({
    ...wallpaper.default.local,

    wallpapers: wallpapers.concat(
      Array(9).fill({
        url: `img/placeholder.png`,
        editbale: true,
      }),
    ),
  })

  return wallpaper.cache(wallpapers)
}

wallpaper.cache = (wallpapers) => {
  try {
    const actives = wallpapers.filter((w) => w.active)
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = actives

    return actives
  } catch (error) {
    alert('The value of wallpapers exceeded the quota')
    throw error
  }
}

wallpaper.boot = () => {
  const wallpapers = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers || wallpaper.init()
  const pick = wallpapers[Math.floor(Math.random() * wallpapers.length)]

  if (!pick) {
    return
  }

  window.wall.style.backgroundImage = `url(${pick.url})`

  if (pick.video > -1) {
    setTimeout(() => {
      const key = `wallpaper_videos_${pick.video}`

      chrome.storage.local.get(key, (data) => {
        const source = document.createElement('source')

        source.src = data[key]
        source.type = 'video/mp4'

        window.wall_video.appendChild(source)
      })
    })
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (wallpaper);


/***/ }),

/***/ "./src/waver.js":
/*!**********************!*\
  !*** ./src/waver.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const waver = {}

waver.add = (x, y) => {
  window.wave_click_box.innerHTML = `
    <div class="wave active" style="transform: translate(${x}px, ${y}px)">
        <div></div>
        <div></div>
        <div></div>
    </div>`
}

window.addEventListener('mouseup', (event) => {
  waver.add(event.clientX, event.clientY)
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (waver);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _prototype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prototype */ "./src/prototype.js");
/* harmony import */ var _prototype__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prototype__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wallpaper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wallpaper */ "./src/wallpaper.js");
/* harmony import */ var _core_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/emitter */ "./src/core/emitter.js");
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/logger */ "./src/core/logger.js");
/* harmony import */ var _noter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./noter */ "./src/noter.js");
/* harmony import */ var _bookmark__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bookmark */ "./src/bookmark.js");
/* harmony import */ var _waver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./waver */ "./src/waver.js");
/* harmony import */ var _setting__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./setting */ "./src/setting.js");










window.holder = {
  w_w: window.document.documentElement.clientWidth,
  w_h: window.document.documentElement.clientHeight,

  code_tables: [
    { code: 'date==', value: new Date().toLocaleDateString() },
    { code: 'time==', value: new Date().toLocaleTimeString() },
    { code: 'now==', value: new Date().toLocaleString() },
    { code: 'name_(.+?)==', value: 'Hi sir, $ <3' },
  ],
}

window.addEventListener('resize', () => {
  holder.w_w = window.document.documentElement.clientWidth
  holder.w_h = window.document.documentElement.clientHeight
})

_wallpaper__WEBPACK_IMPORTED_MODULE_1__["default"].boot()
_noter__WEBPACK_IMPORTED_MODULE_5__["default"].boot()
_bookmark__WEBPACK_IMPORTED_MODULE_6__["default"].boot()
_core_emitter__WEBPACK_IMPORTED_MODULE_2__["default"].click()

_core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].config = Object.assign(
  {
    log_level: 'error',
    number_of_workspace: 2,
  },
  _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].config,
)

if (_core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].workspace) {
  if (_core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].workspace === -1) {
    _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].workspace++
  }

  window.btn_switch_workspace.innerHTML = _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].workspace
} else {
  window.btn_switch_workspace.innerHTML = '0'
}

_core_logger__WEBPACK_IMPORTED_MODULE_4__["default"].log_level = _core_storage__WEBPACK_IMPORTED_MODULE_3__["default"].config.log_level

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTm9CO0FBQ2U7QUFDQztBQUNBO0FBQ0Y7QUFDUDtBQUNNO0FBQ2pCO0FBQ0U7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sd0RBQXdEO0FBQzlELE1BQU0sd0RBQXdEO0FBQzlELE1BQU0sbURBQW1EO0FBQ3pELE1BQU0sNkNBQTZDO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1REFBYztBQUNkLG1EQUFVO0FBQ1Ysc0RBQWE7QUFDYiwyREFBYTs7QUFFYiw0REFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDREQUFjO0FBQ2hCOztBQUVBLElBQUksK0RBQWlCO0FBQ3JCLE1BQU0sK0RBQWlCO0FBQ3ZCLElBQUksK0RBQWlCO0FBQ3JCOztBQUVBLDBDQUEwQywrREFBaUI7QUFDM0QsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsOERBQWdCLEdBQUcsc0VBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9ib29rbWFyay5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL2NvcmUvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL2NvcmUvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9jb3JlL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL2NvcmUvc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL21vZGFsLmpzIiwid2VicGFjazovL3NlaW4vLi9zcmMvbm90ZXIuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9wcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9zZXR0aW5nLmpzIiwid2VicGFjazovL3NlaW4vLi9zcmMvd2FsbHBhcGVyLmpzIiwid2VicGFjazovL3NlaW4vLi9zcmMvd2F2ZXIuanMiLCJ3ZWJwYWNrOi8vc2Vpbi93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9zZWluL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3NlaW4vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3NlaW4vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9zZWluL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3RvcmFnZSBmcm9tICcuL2NvcmUvc3RvcmFnZSdcblxuY29uc3QgYm9va21hcmsgPSB7XG4gIGJvb2ttYXJrQmFyRWxlbWVudDogd2luZG93LmJvb2ttYXJrX2Jhcixcbn1cblxuLyoqXG4gKiBDcmVhdGUgYm9va21hcmsgaXRlbSBmcm9tIGJvb2ttYXJrIG5vZGVzXG4gKiBAcGFyYW0gIHtPYmplY3R9IG5vZGVcbiAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCBnZW5lcmF0ZWQgYnkgYm9va21hcmsgbm9kZVxuICovXG5ib29rbWFyay5jcmVhdGUgPSAobm9kZSkgPT4ge1xuICBjb25zdCB7IHVybCwgdGl0bGUsIGNoaWxkcmVuIH0gPSBub2RlXG5cbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiBib29rbWFyay5yZW5kZXIobm9kZSkpXG4gICAgcmV0dXJuICcnXG4gIH1cblxuICByZXR1cm4gYFxuICAgIDxhIGNsYXNzPVwiaXRlbVwiIGhyZWY9XCIke3VybH1cIj5cbiAgICAgICAgPGltZyBzcmM9XCIke2Nocm9tZS5ydW50aW1lLmdldFVSTCgnL19mYXZpY29uLycpfT9wYWdlVXJsPSR7dXJsfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj4ke3RpdGxlfTwvZGl2PlxuICAgIDwvYT5gXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGFyZW50IG9mIGJvb2ttYXJrLCB0aGlzIGlzIGEgZ3JvdXAgb2YgYm9va21hcmsgaXRlbXNcbiAqIEBwYXJhbSAge09iamVjdH0gbm9kZVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgIEhUTUwgZ2VuZXJhdGVkIGJ5IGJvb2ttYXJrIG5vZGVzXG4gKi9cbmJvb2ttYXJrLmNyZWF0ZVBhcmVudCA9IChub2RlKSA9PiB7XG4gIGNvbnN0IGxhYmVsID0gbm9kZS50aXRsZVxuICBjb25zdCBub2RlcyA9IG5vZGUuY2hpbGRyZW5cbiAgY29uc3QgY2hpbGRzID0gbm9kZXMubWFwKChub2RlKSA9PiBib29rbWFyay5jcmVhdGUobm9kZSkpLmpvaW4oJycpXG4gIGNvbnN0IHBhcmVudElkID0gYCR7bGFiZWx9LSR7bm9kZS5wYXJlbnRJZCB8fCAncm9vdCd9YFxuICBjb25zdCBzdGF0dXMgPSBzdG9yYWdlW2Bib29rbWFyazpwYXJlbnQ6JHtwYXJlbnRJZH1gXSB8fCAnb3BlbidcblxuICByZXR1cm4gYFxuICAgIDxkaXYgY2xhc3M9XCJwYXJlbnQgJHtzdGF0dXN9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYXJlbnQtaGVhZGVyXCIgZGF0YS1wYXJlbnQtaWQ9XCIke3BhcmVudElkfVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGljb24tZm9sZGVyXCI+PC9zcGFuPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxhYmVsXCI+JHtsYWJlbH08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzdG9wZ3JhcFwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFyZW50LWNoaWxkc1wiPiR7Y2hpbGRzfTwvZGl2PlxuICAgIDwvZGl2PmBcbn1cblxuLyoqXG4gKiBSZW5kZXIgYm9va21hcmsgZnJvbSBib29rbWFyayBub2RlXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbY2xlYXI9ZmFsc2VdIGNsZWFuIGJvb2ttYXJrIGJhciBiZWZvcmUgcmVuZGVyXG4gKi9cbmJvb2ttYXJrLnJlbmRlciA9IChub2RlLCBjbGVhciA9IGZhbHNlKSA9PiB7XG4gIGlmIChjbGVhcikge1xuICAgIGJvb2ttYXJrLmJvb2ttYXJrQmFyRWxlbWVudC5pbm5lckhUTUwgPSAnJ1xuICB9XG5cbiAgYm9va21hcmsuYm9va21hcmtCYXJFbGVtZW50LmlubmVySFRNTCArPSBib29rbWFyay5jcmVhdGVQYXJlbnQobm9kZSlcbn1cblxuLyoqXG4gKiBUb2dnbGUgb3BlbiBwYXJlbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAqL1xuYm9va21hcmsudG9nZ2xlT3BlblBhcmVudCA9IChpZCkgPT4ge1xuICBjb25zdCBvcGVuID0gc3RvcmFnZVtgYm9va21hcms6cGFyZW50OiR7aWR9YF0gPT09ICdjbG9zZScgPyAnb3BlbicgOiAnY2xvc2UnXG4gIHN0b3JhZ2VbYGJvb2ttYXJrOnBhcmVudDoke2lkfWBdID0gb3BlblxuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYXJlbnQtaWQ9XCIke2lkfVwiXWApLnBhcmVudE5vZGUuY2xhc3NOYW1lID0gYHBhcmVudCAke29wZW59YFxufVxuXG5ib29rbWFyay5mZXRjaCA9ICgpID0+IHtcbiAgY2hyb21lLnRvcFNpdGVzLmdldCgodG9wcykgPT4ge1xuICAgIGJvb2ttYXJrLnJlbmRlcih7IGNoaWxkcmVuOiB0b3BzLCB0aXRsZTogJ01vc3QgdmlzaXRlZCcgfSwgdHJ1ZSlcblxuICAgIGNocm9tZS5ib29rbWFya3MuZ2V0VHJlZSgoYm9va21hcmtzKSA9PiB7XG4gICAgICBib29rbWFyay5yZW5kZXIoYm9va21hcmtzWzBdLmNoaWxkcmVuWzBdKVxuICAgIH0pXG4gIH0pXG59XG5cbmJvb2ttYXJrLmJvb3QgPSAoKSA9PiB7XG4gIGJvb2ttYXJrLmJvb2ttYXJrQmFyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICh7IHRhcmdldCB9KSA9PiB7XG4gICAgY29uc3QgaWQgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXBhcmVudC1pZCcpIHx8IHRhcmdldC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXJlbnQtaWQnKVxuXG4gICAgaWYgKGlkKSB7XG4gICAgICBib29rbWFyay50b2dnbGVPcGVuUGFyZW50KGlkKVxuICAgIH1cbiAgfSlcblxuICBjaHJvbWUuYm9va21hcmtzLm9uQ3JlYXRlZC5hZGRMaXN0ZW5lcihib29rbWFyay5mZXRjaClcbiAgY2hyb21lLmJvb2ttYXJrcy5vblJlbW92ZWQuYWRkTGlzdGVuZXIoYm9va21hcmsuZmV0Y2gpXG4gIGNocm9tZS5ib29rbWFya3Mub25DaGFuZ2VkLmFkZExpc3RlbmVyKGJvb2ttYXJrLmZldGNoKVxuICBjaHJvbWUuYm9va21hcmtzLm9uTW92ZWQuYWRkTGlzdGVuZXIoYm9va21hcmsuZmV0Y2gpXG5cbiAgYm9va21hcmsuZmV0Y2goKVxufVxuXG5leHBvcnQgZGVmYXVsdCBib29rbWFya1xuIiwiaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcidcbmltcG9ydCBldmVudCBmcm9tICcuL2V2ZW50J1xuXG5jb25zdCBlbWl0dGVyID0ge1xuICBtb3VudGVkOiB7fSxcbn1cblxuLyoqXG4gKiBFbWl0dGVyIGdlbmVyYXRvclxuICogQHBhcmFtIG5hbWUge3N0cmluZ30gRW1pdHRlciBuYW1lXG4gKiBAcGFyYW0gaGFuZGxlIHtmdW5jdGlvbn0gQ2FsbCBvbmUgdGltZSBmb3Igc2V0dXAgZW1pdHRlclxuICovXG5lbWl0dGVyLmdlbiA9IChuYW1lLCBoYW5kbGUpID0+IHtcbiAgaWYgKGVtaXR0ZXJbbmFtZV0gfHwgIS9eW2EtekEtWl1bYS16QS1aMC05X117MCw2M30kLy50ZXN0KG5hbWUpKSB7XG4gICAgcmV0dXJuIGxvZ2dlci5lcnJvcihgZW1pdHRlcjogTmFtZSBcIiR7bmFtZX1cIiBleGlzdGVkIG9yIGludmFsaWRgKVxuICB9XG5cbiAgZW1pdHRlcltuYW1lXSA9ICgpID0+IHtcbiAgICBpZiAoZW1pdHRlci5tb3VudGVkW25hbWVdKSB7XG4gICAgICByZXR1cm4gbG9nZ2VyLmVycm9yKGBlbWl0dGVyOiBEdXBsaWNhdGUgbW91bnQgZW1pdHRlciAke25hbWV9YClcbiAgICB9XG5cbiAgICBoYW5kbGUoKVxuXG4gICAgZW1pdHRlci5tb3VudGVkW25hbWVdID0gdHJ1ZVxuICB9XG59XG5cbi8qKlxuICogRGVmaW5lIGVtaXR0ZXJcbiAqID09PT09PT09PT09PT09XG4gKi9cblxuZW1pdHRlci5nZW4oJ2NsaWNrJywgKCkgPT4ge1xuICBmdW5jdGlvbiBoYW5kbGVDbGlja1IodGFyZ2V0LCBkb21FdmVudCwgdXAgPSAwKSB7XG4gICAgaWYgKHVwID4gNSB8fCAhdGFyZ2V0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjbGlja0VtaXQgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdjbGljay1lbWl0JylcblxuICAgIGlmICghY2xpY2tFbWl0KSB7XG4gICAgICByZXR1cm4gaGFuZGxlQ2xpY2tSKHRhcmdldC5wYXJlbnRFbGVtZW50LCBkb21FdmVudCwgdXAgKyAxKVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBjbGlja0VtaXQuc3BsaXQoJzonKVswXVxuXG4gICAgbGV0IHBheWxvYWQgPSBjbGlja0VtaXQuc3BsaXQoJzonKS5zbGljZSgxKS5qb2luKCc6JylcblxuICAgIC8vIGhhbmRsZSBvYmplY3QgcGF5bG9hZFxuICAgIGlmIChwYXlsb2FkWzBdID09PSAnPycpIHtcbiAgICAgIGNvbnN0IHBheWxvYWRPYmplY3QgPSB7fVxuICAgICAgcGF5bG9hZFxuICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgLnNwbGl0KCcmJylcbiAgICAgICAgLmZvckVhY2goKHEpID0+IHtcbiAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBxLnNwbGl0KCc9JylcbiAgICAgICAgICBpZiAoa2V5ID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIHBheWxvYWRPYmplY3Rba2V5XSA9IHZhbHVlXG4gICAgICAgIH0pXG4gICAgICBwYXlsb2FkID0gcGF5bG9hZE9iamVjdFxuICAgIH1cblxuICAgIGV2ZW50Lm5leHQobmFtZSwgcGF5bG9hZCwgeyB0YXJnZXQsIGRvbUV2ZW50IH0pXG4gIH1cblxuICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChkb21FdmVudCkgPT4ge1xuICAgIGhhbmRsZUNsaWNrUihkb21FdmVudC50YXJnZXQsIGRvbUV2ZW50KVxuICB9KVxuXG4gIGxvZ2dlci5pbmZvKCdlbWl0ZXI6IENsaWNrIGVtaXRlciBtb3VudGVkJylcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IGVtaXR0ZXJcbiIsImNvbnN0IGV2ZW50ID0ge1xuICBwb29sOiB7fSxcbn1cblxuZXZlbnQuZW1pdCA9IChuYW1lLCAuLi5wYXlsb2FkKSA9PiB7XG4gIGZvciAoY29uc3QgaGFuZGxlIG9mIGV2ZW50LnBvb2xbbmFtZV0gPz8gW10pIHtcbiAgICBoYW5kbGUoLi4ucGF5bG9hZClcbiAgfVxufVxuXG5ldmVudC5vbiA9IChuYW1lLCBoYW5kbGUpID0+IHtcbiAgZXZlbnQucG9vbFtuYW1lXT8ucHVzaChoYW5kbGUpIHx8IChldmVudC5wb29sW25hbWVdID0gW2hhbmRsZV0pXG59XG5cbmV2ZW50Lm5leHQgPSAobmFtZSwgLi4ucGF5bG9hZCkgPT4ge1xuICBzZXRUaW1lb3V0KGV2ZW50LmVtaXQsIDAsIG5hbWUsIC4uLnBheWxvYWQpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGV2ZW50XG4iLCJjb25zdCBMRVZFTCA9IFsnZGVidWcnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJ11cblxuY29uc3QgbG9nZ2VyID0ge1xuICBsb2dfbGV2ZWw6ICdkZWJ1ZycsXG5cbiAgZ2V0IGRlYnVnKCkge1xuICAgIGlmIChMRVZFTC5pbmRleE9mKHRoaXMubG9nX2xldmVsLnRvTG93ZXJDYXNlKCkpIDw9IExFVkVMLmluZGV4T2YoJ2RlYnVnJykpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmRlYnVnLmJpbmQod2luZG93LmNvbnNvbGUsICclY0RFQlVHICA6JywgJ2NvbG9yOiAjNmM3NTdkJylcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkXG4gIH0sXG5cbiAgZ2V0IGluZm8oKSB7XG4gICAgaWYgKExFVkVMLmluZGV4T2YodGhpcy5sb2dfbGV2ZWwudG9Mb3dlckNhc2UoKSkgPD0gTEVWRUwuaW5kZXhPZignaW5mbycpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5pbmZvLmJpbmQod2luZG93LmNvbnNvbGUsICclY0lORk8gICA6JywgJ2NvbG9yOiAjMTdhMmI4JylcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkXG4gIH0sXG5cbiAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgaWYgKExFVkVMLmluZGV4T2YodGhpcy5sb2dfbGV2ZWwudG9Mb3dlckNhc2UoKSkgPD0gTEVWRUwuaW5kZXhPZignd2FybmluZycpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuLmJpbmQod2luZG93LmNvbnNvbGUsICclY1dBUk5JTkc6JywgJ2NvbG9yOiAjZmZjMTA3JylcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkXG4gIH0sXG5cbiAgZ2V0IGVycm9yKCkge1xuICAgIGlmIChMRVZFTC5pbmRleE9mKHRoaXMubG9nX2xldmVsLnRvTG93ZXJDYXNlKCkpIDw9IExFVkVMLmluZGV4T2YoJ2Vycm9yJykpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yLmJpbmQod2luZG93LmVycm9yLCAnJWNFUlJPUiAgOicsICdjb2xvcjogI2RjMzU0NScpXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZFxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBsb2dnZXJcbiIsImltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInXG5cbmNvbnN0IHN0b3JhZ2UgPSB7fVxuY29uc3QgaGFuZGxlciA9IHt9XG5cbmhhbmRsZXIuZ2V0ID0gKHRhcmdldCwga2V5KSA9PiB7XG4gIGlmIChrZXkgPT09ICdvcmlnaW4nKSB7XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgY29uc3QgcmF3ID0gd2luZG93LmxvY2FsU3RvcmFnZVtrZXldXG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gcmF3ICYmIEpTT04ucGFyc2UocmF3KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBsb2dnZXIuZXJyb3IoJ3N0b3JhZ2U6IFBhcnNlIGpzb24gZmFpbCwga2V5OiAnLCBrZXkpXG4gIH1cbn1cblxuaGFuZGxlci5zZXQgPSAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiB7XG4gIHdpbmRvdy5sb2NhbFN0b3JhZ2Vba2V5XSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICB0YXJnZXRba2V5XSA9IHZhbHVlXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBQcm94eShzdG9yYWdlLCBoYW5kbGVyKVxuIiwiY29uc3QgdXRpbCA9IHt9XG5cbnV0aWwudGhyb3R0bGUgPSAod2FpdCA9IDIwMCwgdHJhaWxsaW5nID0gdHJ1ZSkgPT4ge1xuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICBsb2NrOiBmYWxzZSxcbiAgICBoYW5kbGU6IG51bGwsXG4gIH1cblxuICBpbnN0YW5jZS5leGVjdXRlID0gKGhhbmRsZSwgLi4uYXJncykgPT4ge1xuICAgIGluc3RhbmNlLmhhbmRsZSA9IGhhbmRsZVxuXG4gICAgaWYgKGluc3RhbmNlLmxvY2spIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGluc3RhbmNlLmxvY2sgPSB0cnVlXG4gICAgaW5zdGFuY2UuaGFuZGxlKC4uLmFyZ3MpXG4gICAgaW5zdGFuY2UuaGFuZGxlID0gbnVsbFxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5sb2NrID0gZmFsc2VcblxuICAgICAgaWYgKHRyYWlsbGluZyAmJiBpbnN0YW5jZS5oYW5kbGUpIHtcbiAgICAgICAgaW5zdGFuY2UuZXhlY3V0ZShpbnN0YW5jZS5oYW5kbGUsIC4uLmFyZ3MpXG4gICAgICB9XG4gICAgfSwgd2FpdClcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG51dGlsLmRlYm91bmNlID0gKHdhaXQgPSAyMDApID0+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgdGltZW91dDogbnVsbCxcbiAgfVxuXG4gIGluc3RhbmNlLmV4ZWN1dGUgPSAoaGFuZGxlLCAuLi5hcmdzKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLnRpbWVvdXQpXG4gICAgaW5zdGFuY2UudGltZW91dCA9IHNldFRpbWVvdXQoaGFuZGxlLCB3YWl0LCAuLi5hcmdzKVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbnV0aWwucmFmID0gKCkgPT4ge1xuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICBsb2NrOiBmYWxzZSxcbiAgICBoYW5kbGU6IG51bGwsXG4gIH1cblxuICBpbnN0YW5jZS5leGVjdXRlID0gKGhhbmRsZSwgLi4uYXJncykgPT4ge1xuICAgIGluc3RhbmNlLmhhbmRsZSA9IGhhbmRsZVxuXG4gICAgaWYgKGluc3RhbmNlLmxvY2spIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGluc3RhbmNlLmxvY2sgPSB0cnVlXG5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGluc3RhbmNlLmxvY2sgPSBmYWxzZVxuICAgICAgaW5zdGFuY2UuaGFuZGxlKC4uLmFyZ3MpXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG5leHBvcnQgZGVmYXVsdCB1dGlsXG4iLCJjb25zdCBtb2RhbCA9IHt9XG5cbm1vZGFsLmhpZGUgPSAoKSA9PiB7XG4gIHdpbmRvdy5tb2RhbC5yZW1vdmVDbGFzcygnbW9kYWwtc2hvdycpXG59XG5cbm1vZGFsLnNob3cgPSAoY29udGVudCkgPT4ge1xuICB3aW5kb3cubW9kYWxfY29udGVudC5pbm5lckhUTUwgPSBjb250ZW50XG4gIHdpbmRvdy5tb2RhbC5hZGRDbGFzcygnbW9kYWwtc2hvdycpXG59XG5cbndpbmRvdy5tb2RhbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICh7IHRhcmdldCB9KSA9PiB7XG4gIGlmICh0YXJnZXQuaWQgPT09ICdtb2RhbCcpIHtcbiAgICBtb2RhbC5oaWRlKClcbiAgfVxufSlcblxuZXhwb3J0IGRlZmF1bHQgbW9kYWxcbiIsImltcG9ydCBzdG9yYWdlIGZyb20gJy4vY29yZS9zdG9yYWdlJ1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2NvcmUvbG9nZ2VyJ1xuaW1wb3J0IGV2ZW50IGZyb20gJy4vY29yZS9ldmVudCdcbmltcG9ydCB1dGlsIGZyb20gJy4vY29yZS91dGlsJ1xuaW1wb3J0IG1vZGFsIGZyb20gJy4vbW9kYWwnXG5cbmNvbnN0IG5vdGVyID0ge1xuICBwdWxsX2Nvb2xkb3duOiAxMDAwMCxcblxuICBjYWxsOiB7XG4gICAgbW92ZTogdXRpbC5yYWYoKSxcbiAgICBzeW5jOiB1dGlsLnRocm90dGxlKCksXG4gICAgcHVzaDogdXRpbC5kZWJvdW5jZSgxMDAwKSxcbiAgfSxcblxuICB2ZXJzaW9uOiBudWxsLFxuICBlcUNvZGVSZWFkeTogbnVsbCxcbiAgbm90ZXM6IFtdLFxufVxuXG5ub3Rlci5mZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgbG9jYWwgPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoWydub3RlcycsICd2ZXJzaW9uJ10pXG5cbiAgbm90ZXIubm90ZXMgPSBsb2NhbC5ub3RlcyB8fCBbXVxuICBub3Rlci52ZXJzaW9uID0gbG9jYWwudmVyc2lvblxuICBub3Rlci5yZW5kZXIoKVxufVxuXG5ub3Rlci5zYXZlID0gKCkgPT4ge1xuICBjb25zdCB2ZXJzaW9uID0gRGF0ZS5ub3coKVxuXG4gIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7XG4gICAgbm90ZXM6IG5vdGVyLm5vdGVzLFxuICAgIHZlcnNpb24sXG4gIH0pXG5cbiAgbm90ZXIudmVyc2lvbiA9IHZlcnNpb25cbiAgbm90ZXIuY2FsbC5wdXNoLmV4ZWN1dGUobm90ZXIucHVzaClcblxuICBsb2dnZXIuZGVidWcoJ25vdGVyOiBOb3RlciBzYXZlOicsIG5vdGVyLm5vdGVzKVxufVxuXG5ub3Rlci5jcmVhdGVPYmplY3QgPSAobm90ZSkgPT4ge1xuICBjb25zdCBkZWZhdWx0RGF0YSA9IHtcbiAgICBtc2c6ICcnLFxuICAgIHg6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChob2xkZXIud193IC0gNTAwKSksXG4gICAgeTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhvbGRlci53X2ggLSAyNTApKSxcbiAgICB3OiAzMDAsXG4gICAgaDogMTAwLFxuICAgIHdvcmtzcGFjZTogc3RvcmFnZS53b3Jrc3BhY2UgfHwgMCxcbiAgICBzdGF0dXM6ICdkZWZhdWx0JyxcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHREYXRhLCBub3RlKVxufVxuXG5ub3Rlci5jcmVhdGVFbGVtZW50ID0gKG5vdGUpID0+IHtcbiAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICBkb20uc2V0QXR0cmlidXRlKCdpZCcsIGBub3RlaWRfJHtub3RlLmlkfWApXG4gIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ25vdGUnKVxuICBkb20uc2V0QXR0cmlidXRlKCdzdHlsZScsIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke25vdGUueH1weCwgJHtub3RlLnl9cHgpYClcbiAgZG9tLnNldEF0dHJpYnV0ZSgnbm90ZS1zdGF0dXMnLCBub3RlLnN0YXR1cyB8fCAnZGVmYXVsdCcpXG5cbiAgZG9tLmlubmVySFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPVwibm90ZS1jb250cm9sc1wiIG5vdGUtbW92ZS1pZD1cIiR7bm90ZS5pZH1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm5vdGUtcmVtb3ZlXCIgY2xpY2stZW1pdD1cIm5vdGVfcmVtb3ZlOiR7bm90ZS5pZH1cIj4mdGltZXM7PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm5vdGUtcmFpbmJvd1wiPlxuICAgICAgICA8ZGl2IGNsaWNrLWVtaXQ9XCJub3RlX21hcms6JHtub3RlLmlkfSxwcmltYXJ5XCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xpY2stZW1pdD1cIm5vdGVfbWFyazoke25vdGUuaWR9LHN1Y2Nlc3NcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGljay1lbWl0PVwibm90ZV9tYXJrOiR7bm90ZS5pZH0sZGFuZ2VyXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm5vdGUtZWRpdG9yXCJcbiAgICAgICAgY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXG4gICAgICAgIHNwZWxsY2hlY2s9XCJmYWxzZVwiXG4gICAgICAgIG5vdGUtZWRpdG9yLWlkPVwiJHtub3RlLmlkfVwiXG4gICAgICAgIHN0eWxlPVwid2lkdGg6JHtub3RlLnd9cHg7aGVpZ2h0OiR7bm90ZS5oIC0gMjB9cHhcIlxuICAgID4ke25vdGUubXNnfTwvZGl2PmBcblxuICBub3Rlci5oYW5kbGVIYXNodGFnKGRvbSlcblxuICByZXR1cm4gZG9tXG59XG5cbm5vdGVyLmFkZCA9IChub3RlKSA9PiB7XG4gIC8vIE5ldyBub3RlIGRvbid0IGhhdmUgYSBpZCwgcHVzaCBpdCB0byBub3Rlci5ub3Rlc1xuICBpZiAobm90ZS5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbm90ZS5pZCA9IERhdGUubm93KCkudG9TdHJpbmcoKVxuICAgIG5vdGUudXBkYXRlZEF0ID0gRGF0ZS5ub3coKVxuICAgIG5vdGVyLm5vdGVzLnB1c2gobm90ZSlcbiAgfVxuXG4gIC8vIFJlbmRlciBodG1sXG4gIHdpbmRvdy5ub3RlX2JveC5hcHBlbmRDaGlsZChub3Rlci5jcmVhdGVFbGVtZW50KG5vdGUpKVxufVxuXG5ub3Rlci5yZW5kZXIgPSAoY2xlYXIgPSB0cnVlLCB3b3Jrc3BhY2UgPSArc3RvcmFnZS53b3Jrc3BhY2UgfHwgMCkgPT4ge1xuICAvLyBDbGVhciBiZWZvcmUgcmVuZGVyXG4gIGlmIChjbGVhcikge1xuICAgIHdpbmRvdy5ub3RlX2JveC5pbm5lckhUTUwgPSAnJ1xuICB9XG5cbiAgLy8gTG9vcCBhZGRpbmdcbiAgZm9yIChjb25zdCBub3RlIG9mIG5vdGVyLm5vdGVzKSB7XG4gICAgaWYgKHdvcmtzcGFjZSA9PT0gbm90ZS53b3Jrc3BhY2UpIHtcbiAgICAgIG5vdGVyLmFkZChub3RlKVxuICAgIH1cbiAgfVxuXG4gIGxvZ2dlci5kZWJ1Zygnbm90ZXI6IFJlbmRlciBub3RlJywgbm90ZXIubm90ZXMpXG59XG5cbm5vdGVyLmhhbmRsZUVxY29kZSA9IChlZGl0b3IpID0+IHtcbiAgLy8gSW5zZXJ0IG1hcmtlclxuICBjb25zdCBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKClcbiAgY29uc3QgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKVxuICBjb25zdCBtYXJrZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICBtYXJrZXJFbC5pZCA9ICdjYXJldC1tYXJrZXInXG4gIG1hcmtlckVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUyMDBCJykpXG4gIHJhbmdlLmluc2VydE5vZGUobWFya2VyRWwpXG5cbiAgY29uc3Qgc3RyaW5nID0gZWRpdG9yLmlubmVySFRNTFxuXG4gIGhvbGRlci5jb2RlX3RhYmxlcy5mb3JFYWNoKChjb2RlKSA9PiB7XG4gICAgY29uc3QgY3JlZ2V4ID0gbmV3IFJlZ0V4cChjb2RlLmNvZGUpXG4gICAgY29uc3QgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKGNyZWdleClcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIC8vIERhdGEgZW1iZWRkZWQgaW4gY29tbWFuZCBjb2RlIGV4LiAnbmFtZV8oLis/KT09J1xuICAgICAgY29uc3QgcmVwbGFjZXMgPSByZXN1bHQuc2xpY2UoMSlcbiAgICAgIGxldCBjb2RlVmFsdWUgPSBjb2RlLnZhbHVlXG5cbiAgICAgIGZvciAoY29uc3QgcmVwbGFjZSBvZiByZXBsYWNlcykge1xuICAgICAgICBjb2RlVmFsdWUgPSBjb2RlVmFsdWUucmVwbGFjZSgnJCcsIHJlcGxhY2UpXG4gICAgICB9XG5cbiAgICAgIGVkaXRvci5pbm5lckhUTUwgPSBzdHJpbmcucmVwbGFjZShjcmVnZXgsIGNvZGVWYWx1ZSlcbiAgICB9XG4gIH0pXG5cbiAgLy8gUmVzdG9yZSBjYXJ0ZSBhbmQgcmVtb3ZlIG1hcmtlclxuICBjb25zdCBuZXdNYXJrZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FyZXQtbWFya2VyJylcblxuICBpZiAobmV3TWFya2VyKSB7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpXG4gICAgbmV3UmFuZ2Uuc2V0U3RhcnRBZnRlcihuZXdNYXJrZXIpXG4gICAgbmV3UmFuZ2UuY29sbGFwc2UodHJ1ZSlcbiAgICBuZXdNYXJrZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuZXdNYXJrZXIpXG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpXG4gICAgc2VsLmFkZFJhbmdlKG5ld1JhbmdlKVxuICB9XG59XG5cbm5vdGVyLmhhbmRsZUhhc2h0YWcgPSAoZG9tKSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IGRvbS5xdWVyeVNlbGVjdG9yKCcubm90ZS1lZGl0b3InKVxuICBjb25zdCBoZWFkID0gZWRpdG9yLmlubmVySFRNTC5zbGljZSgwLCAyNTYpXG5cbiAgY29uc3QgaGFzaHRhZ3MgPSBoZWFkLm1hdGNoKC8jW2EtejAtOV9dezEsMTJ9L2dpKSB8fCBbXVxuICBjb25zdCBjbGFzc2VzID0gWydub3RlJ11cblxuICBpZiAoaGFzaHRhZ3MuaW5jbHVkZXMoJyNtb25vJykpIHtcbiAgICBjbGFzc2VzLnB1c2goJ25vdGUtZmZtJylcbiAgfVxuXG4gIGRvbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKVxufVxuXG5ub3Rlci5yZW1vdmUgPSAoaWQpID0+IHtcbiAgY29uc3QgaW5kZXggPSBub3Rlci5ub3Rlcy5maW5kSW5kZXgoKG5vdGUpID0+IG5vdGUuaWQgPT0gaWQpXG5cbiAgaWYgKHN0b3JhZ2Uud29ya3NwYWNlID09PSAtMSB8fCAhbm90ZXIubm90ZXNbaW5kZXhdLm1zZy5yZXBsYWNlKC8oPGJyPil8IC9nLCAnJykpIHtcbiAgICBub3Rlci5ub3Rlcy5zcGxpY2UoaW5kZXgsIDEpXG4gIH0gZWxzZSB7XG4gICAgbm90ZXIubm90ZXNbaW5kZXhdLndvcmtzcGFjZSA9IC0xXG4gICAgbm90ZXIubm90ZXNbaW5kZXhdLnJlbW92ZUF0ID0gRGF0ZS5ub3coKVxuICAgIG5vdGVyLm5vdGVzW2luZGV4XS51cGRhdGVkQXQgPSBEYXRlLm5vdygpXG4gIH1cblxuICAvLyBSZW1vdmUgZG9tXG4gIGNvbnN0IGRvbSA9IHdpbmRvd1tgbm90ZWlkXyR7aWR9YF1cbiAgZG9tLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZG9tKVxuXG4gIG5vdGVyLnNhdmUoKVxufVxuXG5ub3Rlci5tYXJrID0gKGlkLCBzdGF0dXMpID0+IHtcbiAgY29uc3Qgbm90ZSA9IG5vdGVyLm5vdGVzLmZpbmQoKG4pID0+IG4uaWQgPT0gaWQpXG5cbiAgaWYgKG5vdGUuc3RhdHVzID09PSBzdGF0dXMpIHtcbiAgICBub3RlLnN0YXR1cyA9ICdkZWZhdWx0J1xuICB9IGVsc2Uge1xuICAgIG5vdGUuc3RhdHVzID0gc3RhdHVzXG4gIH1cblxuICB3aW5kb3dbYG5vdGVpZF8ke2lkfWBdLnNldEF0dHJpYnV0ZSgnbm90ZS1zdGF0dXMnLCBub3RlLnN0YXR1cylcbiAgbm90ZXIuc2F2ZSgpXG59XG5cbm5vdGVyLmhhbmRsZU9uQ2hhbmdlID0gKHsgdGFyZ2V0LCBrZXkgfSkgPT4ge1xuICBjb25zdCBpZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ25vdGUtZWRpdG9yLWlkJylcblxuICBpZiAoaWQpIHtcbiAgICBjb25zdCBpbmRleCA9IG5vdGVyLm5vdGVzLmZpbmRJbmRleCgobm90ZSkgPT4gbm90ZS5pZCA9PSBpZClcblxuICAgIC8vIENoZWNrIGNoYW5nZWRcbiAgICBpZiAobm90ZXIubm90ZXNbaW5kZXhdLm1zZyA9PT0gdGFyZ2V0LmlubmVySFRNTCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG5vdGUgaGFzaHRhZ1xuICAgIG5vdGVyLmhhbmRsZUhhc2h0YWcodGFyZ2V0LnBhcmVudEVsZW1lbnQpXG5cbiAgICAvLyBIYW5kbGUgbm90ZSBjb2RlXG4gICAgaWYgKGtleSA9PT0gJz0nKSB7XG4gICAgICBpZiAobm90ZXIuZXFDb2RlUmVhZHkpIHtcbiAgICAgICAgbm90ZXIuaGFuZGxlRXFjb2RlKHRhcmdldClcbiAgICAgICAgbm90ZXIuZXFDb2RlUmVhZHkgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm90ZXIuZXFDb2RlUmVhZHkgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgbm90ZXIubm90ZXNbaW5kZXhdLm1zZyA9IHRhcmdldC5pbm5lckhUTUxcbiAgICBub3Rlci5ub3Rlc1tpbmRleF0udXBkYXRlZEF0ID0gRGF0ZS5ub3coKVxuXG4gICAgbm90ZXIuc2F2ZSgpXG4gIH1cbn1cblxubm90ZXIucHVsbCA9IGFzeW5jICgpID0+IHtcbiAgaWYgKCFzdG9yYWdlLmNvbmZpZy5zeW5jX3VybCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHN0b3JhZ2UucHVsbF9kYXRlID4gRGF0ZS5ub3coKSAtIG5vdGVyLnB1bGxfY29vbGRvd24pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IFt1cmwsIHNlY3JldF0gPSBzdG9yYWdlLmNvbmZpZy5zeW5jX3VybC5zcGxpdCgnIycpXG5cbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuXG4gIGNvbnN0IGV4Y2x1ZGVzID0gbm90ZXIubm90ZXMuZmlsdGVyKChub3RlKSA9PiB7XG4gICAgcmV0dXJuIG5vdGUudXBkYXRlZEF0ID49ICtzdG9yYWdlLnB1bGxfZGF0ZVxuICB9KVxuXG4gIGNvbnN0IGV4Y2x1ZGUgPSBleGNsdWRlc1xuICAgIC5tYXAoKG5vdGUpID0+IHtcbiAgICAgIHJldHVybiBgJHtub3RlLmlkfToke25vdGUudXBkYXRlZEF0fWBcbiAgICB9KVxuICAgIC5qb2luKCcsJylcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3VybH0/ZGF0ZT0ke3N0b3JhZ2UucHVsbF9kYXRlIHx8IDB9JmV4Y2x1ZGU9JHtleGNsdWRlfWAsIHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdYLVNlY3JldCc6IHNlY3JldCxcbiAgICB9LFxuICB9KVxuXG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgaWYgKGRhdGE/Lmxlbmd0aCkge1xuICAgIGNvbnN0IG1hcCA9IHt9XG4gICAgbGV0IHNob3VsZFJlbmRlciA9IGZhbHNlXG5cbiAgICBmb3IgKGNvbnN0IG5vdGUgb2Ygbm90ZXIubm90ZXMpIHtcbiAgICAgIG1hcFtub3RlLmlkXSA9IG5vdGVcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHsgcmF3OiBub3RlIH0gb2YgZGF0YSkge1xuICAgICAgaWYgKCFtYXBbbm90ZS5pZF0/LnVwZGF0ZWRBdCB8fCBtYXBbbm90ZS5pZF0udXBkYXRlZEF0IDwgbm90ZS51cGRhdGVkQXQpIHtcbiAgICAgICAgbWFwW25vdGUuaWRdID0gbm90ZVxuICAgICAgICBzaG91bGRSZW5kZXIgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFJlbmRlcikge1xuICAgICAgbm90ZXIubm90ZXMgPSBPYmplY3QudmFsdWVzKG1hcClcbiAgICAgIG5vdGVyLnJlbmRlcigpXG4gICAgICBub3Rlci5zYXZlKClcbiAgICB9XG4gIH1cblxuICBzdG9yYWdlLnB1bGxfZGF0ZSA9IG5vd1xufVxuXG5ub3Rlci5wdXNoID0gYXN5bmMgKCkgPT4ge1xuICBpZiAoIXN0b3JhZ2UuY29uZmlnLnN5bmNfdXJsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBub3RlcyA9IG5vdGVyLm5vdGVzLmZpbHRlcigobm90ZSkgPT4ge1xuICAgIHJldHVybiArbm90ZS51cGRhdGVkQXQgPiAoK3N0b3JhZ2UucHVzaF9kYXRlIHx8IDApICYmIG5vdGUubXNnXG4gIH0pXG5cbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICBjb25zdCBbdXJsLCBzZWNyZXRdID0gc3RvcmFnZS5jb25maWcuc3luY191cmwuc3BsaXQoJyMnKVxuXG4gIGlmIChub3Rlcy5sZW5ndGgpIHtcbiAgICBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBub3RlcyB9KSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ1gtU2VjcmV0Jzogc2VjcmV0LFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgc3RvcmFnZS5wdXNoX2RhdGUgPSBub3dcbn1cblxubm90ZXIuY2xlYXJUcmFzaCA9ICgpID0+IHtcbiAgaWYgKHN0b3JhZ2UubGFzdF9jbGVhcl90cmFzaCA+IERhdGUubm93KCkgLSA4ZTcpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHN0b3JhZ2UubGFzdF9jbGVhcl90cmFzaCA9IERhdGUubm93KClcblxuICBub3Rlci5ub3RlcyA9IG5vdGVyLm5vdGVzLmZpbHRlcigobm90ZSkgPT4ge1xuICAgIGlmIChub3RlLndvcmtzcGFjZSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKG5vdGUucmVtb3ZlQXQgPiBEYXRlLm5vdygpIC0gODY0ZTUgKiAzMCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0pXG5cbiAgbm90ZXIuc2F2ZSgpXG59XG5cbm5vdGVyLnNvcnQgPSAoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkgPT4ge1xuICBpZiAoIW5vdGVyLm5vdGVzLmxlbmd0aCkgcmV0dXJuXG5cbiAgLy8gR2V0IGN1cnJlbnQgd29ya3NwYWNlIG5vdGVzXG4gIGNvbnN0IHdvcmtzcGFjZSA9ICtzdG9yYWdlLndvcmtzcGFjZSB8fCAwXG4gIGNvbnN0IHdvcmtzcGFjZU5vdGVzID0gbm90ZXIubm90ZXMuZmlsdGVyKChub3RlKSA9PiBub3RlLndvcmtzcGFjZSA9PT0gd29ya3NwYWNlKVxuXG4gIGlmICghd29ya3NwYWNlTm90ZXMubGVuZ3RoKSByZXR1cm5cblxuICAvLyBBdmFpbGFibGUgc2NyZWVuIGRpbWVuc2lvbnNcbiAgaWYgKCFzY3JlZW5XaWR0aCkge1xuICAgIHNjcmVlbldpZHRoID0gaG9sZGVyLndfdyAtIDUwXG4gIH1cblxuICBpZiAoIXNjcmVlbkhlaWdodCkge1xuICAgIHNjcmVlbkhlaWdodCA9IGhvbGRlci53X2hcbiAgfVxuXG4gIGNvbnN0IHNwYWNpbmcgPSAxMFxuICBjb25zdCBsZWZ0TWFyZ2luID0gMTBcbiAgY29uc3QgdG9wTWFyZ2luID0gMTBcblxuICAvLyBTb3J0IG5vdGVzIGJ5IGhlaWdodCAodGFsbGVzdCBmaXJzdCkgZm9yIGJldHRlciBjb2x1bW4gcGFja2luZ1xuICBjb25zdCBzb3J0ZWROb3RlcyA9IFsuLi53b3Jrc3BhY2VOb3Rlc10uc29ydCgoYSwgYikgPT4gYi5oIC0gYS5oKVxuXG4gIC8vIENvbHVtbi1iYXNlZCBwYWNraW5nIGFsZ29yaXRobSAodG9wIHRvIGJvdHRvbSwgbGVmdCB0byByaWdodClcbiAgY29uc3QgcGxhY2VkTm90ZXMgPSBbXVxuICBjb25zdCB1bnBsYWNlZE5vdGVzID0gWy4uLnNvcnRlZE5vdGVzXVxuICBsZXQgY3VycmVudFggPSBsZWZ0TWFyZ2luXG4gIGxldCBjdXJyZW50WSA9IHRvcE1hcmdpblxuICBsZXQgY29sdW1uV2lkdGggPSAwXG4gIGxldCBtYXhZID0gdG9wTWFyZ2luXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHR3byBub3RlcyBvdmVybGFwXG4gIGNvbnN0IGRvTm90ZXNPdmVybGFwID0gKG5vdGUxLCBub3RlMikgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICBub3RlMS54IDwgbm90ZTIueCArIG5vdGUyLncgKyBzcGFjaW5nICYmXG4gICAgICBub3RlMS54ICsgbm90ZTEudyArIHNwYWNpbmcgPiBub3RlMi54ICYmXG4gICAgICBub3RlMS55IDwgbm90ZTIueSArIG5vdGUyLmggKyBzcGFjaW5nICYmXG4gICAgICBub3RlMS55ICsgbm90ZTEuaCArIHNwYWNpbmcgPiBub3RlMi55XG4gICAgKVxuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHNoaWZ0IG92ZXJsYXBwaW5nIG5vdGVzIHRvIHRoZSByaWdodFxuICBjb25zdCBzaGlmdE92ZXJsYXBwaW5nTm90ZXMgPSAobmV3Tm90ZSwgcGxhY2VkTm90ZXMpID0+IHtcbiAgICBsZXQgbWF4U2hpZnQgPSAwXG5cbiAgICBmb3IgKGNvbnN0IHBsYWNlZE5vdGUgb2YgcGxhY2VkTm90ZXMpIHtcbiAgICAgIGlmIChkb05vdGVzT3ZlcmxhcChuZXdOb3RlLCBwbGFjZWROb3RlKSkge1xuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byBzaGlmdCB0aGUgbmV3IG5vdGUgdG8gdGhlIHJpZ2h0XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkU2hpZnQgPSBwbGFjZWROb3RlLnggKyBwbGFjZWROb3RlLncgKyBzcGFjaW5nIC0gbmV3Tm90ZS54XG4gICAgICAgIG1heFNoaWZ0ID0gTWF0aC5tYXgobWF4U2hpZnQsIHJlcXVpcmVkU2hpZnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heFNoaWZ0XG4gIH1cblxuICB3aGlsZSAodW5wbGFjZWROb3Rlcy5sZW5ndGggPiAwKSB7XG4gICAgbGV0IG5vdGVQbGFjZWQgPSBmYWxzZVxuXG4gICAgLy8gVHJ5IHRvIGZpbmQgdGhlIHRhbGxlc3Qgbm90ZSB0aGF0IGZpdHMgaW4gY3VycmVudCBjb2x1bW5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVucGxhY2VkTm90ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vdGUgPSB1bnBsYWNlZE5vdGVzW2ldXG5cbiAgICAgIC8vIENoZWNrIGlmIG5vdGUgZml0cyBpbiBjdXJyZW50IGNvbHVtblxuICAgICAgaWYgKGN1cnJlbnRZICsgbm90ZS5oICsgc3BhY2luZyA8PSBzY3JlZW5IZWlnaHQpIHtcbiAgICAgICAgLy8gUGxhY2Ugbm90ZSBpbiBjdXJyZW50IGNvbHVtblxuICAgICAgICBub3RlLnggPSBjdXJyZW50WFxuICAgICAgICBub3RlLnkgPSBjdXJyZW50WVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybGFwcyBhbmQgc2hpZnQgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGNvbnN0IHNoaWZ0QW1vdW50ID0gc2hpZnRPdmVybGFwcGluZ05vdGVzKG5vdGUsIHBsYWNlZE5vdGVzKVxuICAgICAgICBpZiAoc2hpZnRBbW91bnQgPiAwKSB7XG4gICAgICAgICAgbm90ZS54ICs9IHNoaWZ0QW1vdW50XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBzaGlmdGVkIHBvc2l0aW9uIHN0aWxsIGZpdHMgd2l0aGluIHNjcmVlbiBib3VuZHNcbiAgICAgICAgICBpZiAobm90ZS54ICsgbm90ZS53ID4gc2NyZWVuV2lkdGgpIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgZml0LCB0cnkgdG8gZmluZCBhIGJldHRlciBwb3NpdGlvblxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50WSArPSBub3RlLmggKyBzcGFjaW5nXG4gICAgICAgIGNvbHVtbldpZHRoID0gTWF0aC5tYXgoY29sdW1uV2lkdGgsIG5vdGUudylcblxuICAgICAgICAvLyBSZW1vdmUgbm90ZSBmcm9tIHVucGxhY2VkIGxpc3RcbiAgICAgICAgdW5wbGFjZWROb3Rlcy5zcGxpY2UoaSwgMSlcbiAgICAgICAgcGxhY2VkTm90ZXMucHVzaChub3RlKVxuICAgICAgICBub3RlUGxhY2VkID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIG5vdGUgZml0cyBpbiBjdXJyZW50IGNvbHVtbiwgZmluZCBiZXN0IHBvc2l0aW9uIGZvciBuZXh0IG5vdGVcbiAgICBpZiAoIW5vdGVQbGFjZWQpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGJlc3QgYXZhaWxhYmxlIHBvc2l0aW9uIGZvciB0aGUgdGFsbGVzdCByZW1haW5pbmcgbm90ZVxuICAgICAgbGV0IGJlc3RYID0gbGVmdE1hcmdpblxuICAgICAgbGV0IGJlc3RZID0gdG9wTWFyZ2luXG4gICAgICBsZXQgZm91bmRQb3NpdGlvbiA9IGZhbHNlXG5cbiAgICAgIGlmICh1bnBsYWNlZE5vdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgbm90ZSA9IHVucGxhY2VkTm90ZXNbMF1cblxuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIHBvc2l0aW9uIHRoYXQgZml0c1xuICAgICAgICBmb3IgKGxldCB0ZXN0WSA9IHRvcE1hcmdpbjsgdGVzdFkgPD0gc2NyZWVuSGVpZ2h0IC0gbm90ZS5oOyB0ZXN0WSArPSBzcGFjaW5nKSB7XG4gICAgICAgICAgZm9yIChsZXQgdGVzdFggPSBsZWZ0TWFyZ2luOyB0ZXN0WCA8PSBzY3JlZW5XaWR0aCAtIG5vdGUudzsgdGVzdFggKz0gc3BhY2luZykge1xuICAgICAgICAgICAgLy8gU2V0IHRlbXBvcmFyeSBwb3NpdGlvbiBmb3Igb3ZlcmxhcCBjaGVja2luZ1xuICAgICAgICAgICAgbm90ZS54ID0gdGVzdFhcbiAgICAgICAgICAgIG5vdGUueSA9IHRlc3RZXG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgcG9zaXRpb24gb3ZlcmxhcHMgd2l0aCBhbnkgcGxhY2VkIG5vdGVzXG4gICAgICAgICAgICBsZXQgY2FuUGxhY2UgPSB0cnVlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBsYWNlZE5vdGUgb2YgcGxhY2VkTm90ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGRvTm90ZXNPdmVybGFwKG5vdGUsIHBsYWNlZE5vdGUpKSB7XG4gICAgICAgICAgICAgICAgY2FuUGxhY2UgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhblBsYWNlKSB7XG4gICAgICAgICAgICAgIGJlc3RYID0gdGVzdFhcbiAgICAgICAgICAgICAgYmVzdFkgPSB0ZXN0WVxuICAgICAgICAgICAgICBmb3VuZFBvc2l0aW9uID0gdHJ1ZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm91bmRQb3NpdGlvbikgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGRpcmVjdCBwb3NpdGlvbiBmb3VuZCwgdHJ5IHNoaWZ0aW5nIGFwcHJvYWNoXG4gICAgICAgIGlmICghZm91bmRQb3NpdGlvbikge1xuICAgICAgICAgIC8vIFRyeSBwbGFjaW5nIGF0IGxlZnRtb3N0IHBvc2l0aW9uIGFuZCBzaGlmdCBpZiBuZWVkZWRcbiAgICAgICAgICBub3RlLnggPSBsZWZ0TWFyZ2luXG4gICAgICAgICAgbm90ZS55ID0gdG9wTWFyZ2luXG5cbiAgICAgICAgICBjb25zdCBzaGlmdEFtb3VudCA9IHNoaWZ0T3ZlcmxhcHBpbmdOb3Rlcyhub3RlLCBwbGFjZWROb3RlcylcbiAgICAgICAgICBpZiAoc2hpZnRBbW91bnQgPiAwICYmIG5vdGUueCArIHNoaWZ0QW1vdW50ICsgbm90ZS53IDw9IHNjcmVlbldpZHRoKSB7XG4gICAgICAgICAgICBub3RlLnggKz0gc2hpZnRBbW91bnRcbiAgICAgICAgICAgIGZvdW5kUG9zaXRpb24gPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGxhY2UgdGhlIG5vdGUgYXQgdGhlIGJlc3QgcG9zaXRpb24gZm91bmRcbiAgICAgICAgaWYgKGZvdW5kUG9zaXRpb24pIHtcbiAgICAgICAgICBjdXJyZW50WCA9IG5vdGUueFxuICAgICAgICAgIGN1cnJlbnRZID0gbm90ZS55ICsgbm90ZS5oICsgc3BhY2luZ1xuICAgICAgICAgIGNvbHVtbldpZHRoID0gbm90ZS53XG5cbiAgICAgICAgICB1bnBsYWNlZE5vdGVzLnNwbGljZSgwLCAxKVxuICAgICAgICAgIHBsYWNlZE5vdGVzLnB1c2gobm90ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBzdGlsbCBjYW4ndCBwbGFjZSwgcGxhY2UgaXQgYXQgYSByYW5kb20gcG9zaXRpb24gb24gc2NyZWVuXG4gICAgICAgICAgY29uc3QgcmFuZG9tWCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChzY3JlZW5XaWR0aCAtIG5vdGUudyAtIGxlZnRNYXJnaW4pKSArIGxlZnRNYXJnaW5cbiAgICAgICAgICBjb25zdCByYW5kb21ZID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHNjcmVlbkhlaWdodCAtIG5vdGUuaCAtIHRvcE1hcmdpbikpICsgdG9wTWFyZ2luXG5cbiAgICAgICAgICBub3RlLnggPSByYW5kb21YXG4gICAgICAgICAgbm90ZS55ID0gcmFuZG9tWVxuXG4gICAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgcG9zaXRpb24gZm9yIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgY3VycmVudFggPSBsZWZ0TWFyZ2luXG4gICAgICAgICAgY3VycmVudFkgPSBtYXhZICsgc3BhY2luZ1xuICAgICAgICAgIGNvbHVtbldpZHRoID0gTWF0aC5tYXgoY29sdW1uV2lkdGgsIG5vdGUudylcblxuICAgICAgICAgIHVucGxhY2VkTm90ZXMuc3BsaWNlKDAsIDEpXG4gICAgICAgICAgcGxhY2VkTm90ZXMucHVzaChub3RlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIG1heFlcbiAgICBmb3IgKGNvbnN0IG5vdGUgb2YgcGxhY2VkTm90ZXMpIHtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBub3RlLnkgKyBub3RlLmgpXG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIGFsbCBub3RlcyB3aXRoIG5ldyBwb3NpdGlvbnNcbiAgZm9yIChjb25zdCBub3RlIG9mIHdvcmtzcGFjZU5vdGVzKSB7XG4gICAgY29uc3QgaW5kZXggPSBub3Rlci5ub3Rlcy5maW5kSW5kZXgoKG4pID0+IG4uaWQgPT09IG5vdGUuaWQpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbm90ZXIubm90ZXNbaW5kZXhdLnggPSBub3RlLnhcbiAgICAgIG5vdGVyLm5vdGVzW2luZGV4XS55ID0gbm90ZS55XG4gICAgICBub3Rlci5ub3Rlc1tpbmRleF0udXBkYXRlZEF0ID0gRGF0ZS5ub3coKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlLXJlbmRlciBhbmQgc2F2ZVxuICBub3Rlci5yZW5kZXIoKVxuICBub3Rlci5zYXZlKClcblxuICBsb2dnZXIuZGVidWcoJ25vdGVyOiBTb3J0ZWQgbm90ZXMgdXNpbmcgY29sdW1uLWJhc2VkIHBhY2tpbmcgYWxnb3JpdGhtIHdpdGggb3ZlcmxhcCBzaGlmdGluZycpXG59XG5cbm5vdGVyLmJvb3QgPSAoKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHJlc2l6ZTogZmFsc2UsXG4gICAgbW92ZTogZmFsc2UsXG4gICAgZGVsdGFYOiAwLFxuICAgIGRlbHRhWTogMCxcbiAgfVxuXG4gIGV2ZW50Lm9uKCdub3RlX3JlbW92ZScsIChpZCkgPT4ge1xuICAgIG5vdGVyLnJlbW92ZShpZClcbiAgfSlcblxuICBldmVudC5vbignbm90ZV9tYXJrJywgKG1hcmspID0+IHtcbiAgICBjb25zdCBbaWQsIHN0YXR1c10gPSBtYXJrLnNwbGl0KCcsJylcbiAgICBub3Rlci5tYXJrKGlkLCBzdGF0dXMpXG4gIH0pXG5cbiAgLy8gSGFuZGxlIG1vdmVcbiAgd2luZG93Lm5vdGVfYm94LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChldmVudCkgPT4ge1xuICAgIC8vIFByZXZlbnQgcmlnaHQgbW91c2VcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudFxuXG4gICAgLy8gRGV0ZWN0IHJlc2l6ZVxuICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKCdub3RlLWVkaXRvci1pZCcpICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBIYW5kbGUgZGlzYWJsZSBzZWxlY3Qgd2hlbiByZXNpemVcbiAgICAgIGNvbnN0IGN4ID0gZXZlbnQuY2xpZW50WFxuICAgICAgY29uc3QgY3kgPSBldmVudC5jbGllbnRZXG4gICAgICBjb25zdCBub3RlSWQgPSArdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbm90ZS1lZGl0b3ItaWQnKVxuICAgICAgY29uc3Qgbm90ZUluZGV4ID0gbm90ZXIubm90ZXMuZmluZEluZGV4KChub3RlKSA9PiBub3RlLmlkID09IG5vdGVJZClcbiAgICAgIGNvbnN0IG5vdGUgPSBub3Rlci5ub3Rlc1tub3RlSW5kZXhdXG5cbiAgICAgIC8vIERldGVjdCBtb3VzZSBkb3duIG92ZXIgcmVzaXplIGJ0blxuICAgICAgaWYgKG5vdGUueCArIG5vdGUudyAtIGN4IDwgMTUgJiYgbm90ZS55ICsgbm90ZS5oIC0gY3kgPCAxNSkge1xuICAgICAgICBzdGF0ZS5yZXNpemUgPSBub3RlSWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZSgnbm90ZS1tb3ZlLWlkJykgIT09IG51bGwpIHtcbiAgICAgIC8vIERpc2FibGUgdGV4dCBzZWxlY3Rpb25cbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJ1xuXG4gICAgICBjb25zdCBub3RlSWQgPSArdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbm90ZS1tb3ZlLWlkJylcbiAgICAgIGNvbnN0IG5vdGVJbmRleCA9IG5vdGVyLm5vdGVzLmZpbmRJbmRleCgobm90ZSkgPT4gbm90ZS5pZCA9PSBub3RlSWQpXG5cbiAgICAgIC8vIEZpeCBwb3NpdGlvbiBtb3VzZSB2cyBub3RlXG4gICAgICBzdGF0ZS5kZWx0YVggPSBldmVudC5jbGllbnRYIC0gbm90ZXIubm90ZXNbbm90ZUluZGV4XS54XG4gICAgICBzdGF0ZS5kZWx0YVkgPSBldmVudC5jbGllbnRZIC0gbm90ZXIubm90ZXNbbm90ZUluZGV4XS55XG5cbiAgICAgIC8vIFN0YXJ0IG1vdmUgaGFuZGxlXG4gICAgICBzdGF0ZS5tb3ZlID0gbm90ZUlkXG4gICAgfVxuICB9KVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoc3RhdGUubW92ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgIG5vdGVyLmNhbGwubW92ZS5leGVjdXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IHdpbmRvd1tgbm90ZWlkXyR7c3RhdGUubW92ZX1gXVxuXG4gICAgICBpZiAoZG9tKSB7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihob2xkZXIud193IC0gMjAsIE1hdGgubWF4KGV2ZW50LmNsaWVudFggLSBzdGF0ZS5kZWx0YVgsIDApKVxuICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4oaG9sZGVyLndfaCAtIDIwLCBNYXRoLm1heChldmVudC5jbGllbnRZIC0gc3RhdGUuZGVsdGFZLCAwKSlcbiAgICAgICAgZG9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpYFxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoZXZlbnQpID0+IHtcbiAgICAvLyBSZWNvdmVyIHRleHQgc2VsZWN0aW9uXG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS51c2VyU2VsZWN0ID0gJydcblxuICAgIGlmIChzdGF0ZS5tb3ZlICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFggLSBzdGF0ZS5kZWx0YVhcbiAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZIC0gc3RhdGUuZGVsdGFZXG4gICAgICBjb25zdCBub3RlID0gbm90ZXIubm90ZXMuZmluZCgoZSkgPT4gZS5pZCA9PSBzdGF0ZS5tb3ZlKVxuXG4gICAgICBpZiAobm90ZSkge1xuICAgICAgICBub3RlLnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihob2xkZXIud193LCB4KSlcbiAgICAgICAgbm90ZS55ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaG9sZGVyLndfaCwgeSkpXG4gICAgICAgIG5vdGUudXBkYXRlZEF0ID0gRGF0ZS5ub3coKVxuICAgICAgfVxuXG4gICAgICAvLyBFbmQgbW92ZSBoYW5kbGVcbiAgICAgIHN0YXRlLm1vdmUgPSBmYWxzZVxuXG4gICAgICAvLyBTYXZlIHdoZW4gZG9uZSBtb3ZlIGEgbm90ZVxuICAgICAgbm90ZXIuc2F2ZSgpXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5yZXNpemUgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBub3RlID0gbm90ZXIubm90ZXMuZmluZCgoZSkgPT4gZS5pZCA9PSBzdGF0ZS5yZXNpemUpXG5cbiAgICAgIGlmIChub3RlKSB7XG4gICAgICAgIG5vdGUudyA9IHdpbmRvd1snbm90ZWlkXycgKyBzdGF0ZS5yZXNpemVdLm9mZnNldFdpZHRoXG4gICAgICAgIG5vdGUuaCA9IHdpbmRvd1snbm90ZWlkXycgKyBzdGF0ZS5yZXNpemVdLm9mZnNldEhlaWdodFxuICAgICAgICBub3RlLnVwZGF0ZWRBdCA9IERhdGUubm93KClcbiAgICAgIH1cblxuICAgICAgLy8gRW5kIHJlc2l6ZSBoYW5kbGVcbiAgICAgIHN0YXRlLnJlc2l6ZSA9IGZhbHNlXG5cbiAgICAgIC8vIFNhdmUgd2hlbiBkb25lIG1vdmUgYSBub3RlXG4gICAgICBub3Rlci5zYXZlKClcbiAgICB9XG4gIH0pXG5cbiAgd2luZG93Lm5vdGVfYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgbm90ZXIuaGFuZGxlT25DaGFuZ2UpXG4gIHdpbmRvdy5ub3RlX2JveC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIG5vdGVyLmhhbmRsZU9uQ2hhbmdlKVxuXG4gIHdpbmRvdy5ub3RlX2JveC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICh7IHRhcmdldCB9KSA9PiB7XG4gICAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnSU1HJykge1xuICAgICAgbW9kYWwuc2hvdyhgPGltZyBzcmM9XCIke3RhcmdldC5zcmN9XCIgc3R5bGU9XCJtYXgtd2lkdGg6IGNhbGMoMTAwdncgLSA1MHB4KVwiPmApXG4gICAgfVxuICB9KVxuXG4gIC8vIExpc3RlbiBhZGQgbm90ZVxuICBldmVudC5vbignbm90ZXJfYWRkJywgKCkgPT4ge1xuICAgIG5vdGVyLmFkZChub3Rlci5jcmVhdGVPYmplY3QoKSlcbiAgICBub3Rlci5zYXZlKClcbiAgfSlcblxuICAvLyBMaXN0ZW4gc3dpdGNoIHdvcmtzcGFjZVxuICBldmVudC5vbignbm90ZXJfc3dpdGNoX3dvcmtzcGFjZScsICgpID0+IHtcbiAgICBsZXQgd29ya3NwYWNlID0gK3N0b3JhZ2Uud29ya3NwYWNlIHx8IDBcblxuICAgIGlmICh3b3Jrc3BhY2UgPiBzdG9yYWdlLmNvbmZpZy5udW1iZXJfb2Zfd29ya3NwYWNlIC0gMikge1xuICAgICAgd29ya3NwYWNlID0gLTFcbiAgICB9IGVsc2Uge1xuICAgICAgd29ya3NwYWNlKytcbiAgICB9XG5cbiAgICB3aW5kb3cuYnRuX3N3aXRjaF93b3Jrc3BhY2UuaW5uZXJIVE1MID0gd29ya3NwYWNlID09PSAtMSA/ICfwn5eR77iPJyA6IHdvcmtzcGFjZVxuICAgIHN0b3JhZ2Uud29ya3NwYWNlID0gd29ya3NwYWNlXG5cbiAgICBub3Rlci5zYXZlKClcbiAgICBub3Rlci5yZW5kZXIoKVxuICB9KVxuXG4gIC8vIEhhbmRsZSBkcmFnIHRvIHNvcnRcbiAgaWYgKHdpbmRvdy5idG5fc29ydF9ub3RlKSB7XG4gICAgbGV0IHJlc2l6aW5nID0gZmFsc2VcblxuICAgIGNvbnN0IGNhbGxlciA9IHV0aWwudGhyb3R0bGUoMTAwKVxuXG4gICAgd2luZG93LmJ0bl9zb3J0X25vdGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICByZXNpemluZyA9IHRydWVcblxuICAgICAgY2FsbGVyLmV4ZWN1dGUoKCkgPT4ge1xuICAgICAgICBub3Rlci5zb3J0KClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghZXZlbnQuYnV0dG9ucyB8fCAhcmVzaXppbmcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNhbGxlci5leGVjdXRlKCgpID0+IHtcbiAgICAgICAgbm90ZXIuc29ydChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB7XG4gICAgICByZXNpemluZyA9IGZhbHNlXG4gICAgfSlcbiAgfVxuXG4gIC8vIExpc3RlbiBzeW5jIG5vdGVzIGNyb3NzIHRhYlxuICBjaHJvbWUuc3RvcmFnZS5vbkNoYW5nZWQuYWRkTGlzdGVuZXIoKGNoYW5nZSwgbmFtZXNwYWNlKSA9PiB7XG4gICAgaWYgKG5hbWVzcGFjZSAhPT0gJ2xvY2FsJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbm90ZXIuY2FsbC5zeW5jLmV4ZWN1dGUoKCkgPT4ge1xuICAgICAgaWYgKGNoYW5nZS5ub3RlcyAmJiBjaGFuZ2UudmVyc2lvbj8ubmV3VmFsdWUgPiBub3Rlci52ZXJzaW9uKSB7XG4gICAgICAgIG5vdGVyLm5vdGVzID0gY2hhbmdlLm5vdGVzLm5ld1ZhbHVlXG4gICAgICAgIG5vdGVyLnJlbmRlcigpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICBub3Rlci5mZXRjaCgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgIG5vdGVyLmNsZWFyVHJhc2goKVxuICAgIGF3YWl0IG5vdGVyLnB1c2goKVxuICAgIGF3YWl0IG5vdGVyLnB1bGwoKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RlclxuIiwiQXJyYXkucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVkdWNlKChhY2MsIGUpID0+IGFjYyArIGUpXG59XG5cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHtjbGFzc05hbWV9JHxeJHtjbGFzc05hbWV9IHwgJHtjbGFzc05hbWV9JHwgJHtjbGFzc05hbWV9KCApYCwgJ2cnKVxuICBpZiAoIXJlZ2V4LnRlc3QodGhpcy5jbGFzc05hbWUpKSB7XG4gICAgdGhpcy5jbGFzc05hbWUgPSBgJHt0aGlzLmNsYXNzTmFtZX0gJHtjbGFzc05hbWV9YC50cmltKClcbiAgfVxufVxuXG5IVE1MRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7Y2xhc3NOYW1lfSR8XiR7Y2xhc3NOYW1lfSB8ICR7Y2xhc3NOYW1lfSR8ICR7Y2xhc3NOYW1lfSggKWAsICdnJylcbiAgdGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKHJlZ2V4LCAnJDEnKS50cmltKClcbn1cblxuSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbLi4udGhpc11cbn1cblxuTm9kZUxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbLi4udGhpc11cbn1cbiIsImltcG9ydCBzdG9yYWdlIGZyb20gJy4vY29yZS9zdG9yYWdlJ1xuaW1wb3J0IGV2ZW50IGZyb20gJy4vY29yZS9ldmVudCdcbmltcG9ydCBub3RlciBmcm9tICcuL25vdGVyJ1xuaW1wb3J0IHdhbGxwYXBlciBmcm9tICcuL3dhbGxwYXBlcidcblxuY29uc3Qgc2V0dGluZyA9IHtcbiAgaXNPcGVuOiBmYWxzZSxcbiAgYmxvYl9idWZmZXJfdXJsOiBudWxsLFxufVxuXG5zZXR0aW5nLnJlbmRlciA9ICgpID0+IHtcbiAgLy8gUmVuZGVyIHdhbGxwYXBlclxuICBjb25zdCB3YWxXID0gTWF0aC5mbG9vcih3aW5kb3cuc2V0dGluZ3Nfd2FsbHBhcGVycy5jbGllbnRXaWR0aCAvIDYgLSAxMSlcbiAgY29uc3Qgd2FsSCA9IE1hdGguZmxvb3IoKHdhbFcgKiBob2xkZXIud19oKSAvIGhvbGRlci53X3cpXG5cbiAgd2luZG93LnNldHRpbmdzX3dhbGxwYXBlcnMuaW5uZXJIVE1MID0gQXJyYXkoMTIpXG4gICAgLmZpbGwoMSlcbiAgICAubWFwKCgpID0+IHtcbiAgICAgIHJldHVybiBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2V0dGluZ3Mtd2FsbC1wcmVcIlxuICAgICAgICAgICAgICAgIHN0eWxlPVwid2lkdGg6ICR7d2FsV31weDsgaGVpZ2h0OiAke3dhbEh9cHg7IGJhY2tncm91bmQtaW1hZ2U6IHVybCgvaW1nL3BsYWNlaG9sZGVyLnBuZylcIlxuICAgICAgICAgICAgPjwvZGl2PlxuICAgICAgICAgICAgYFxuICAgIH0pXG4gICAgLmpvaW4oJycpXG5cbiAgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KCd3YWxscGFwZXJzJywgKHsgd2FsbHBhcGVycyB9KSA9PiB7XG4gICAgd2luZG93LnNldHRpbmdzX3dhbGxwYXBlcnMuaW5uZXJIVE1MID0gd2FsbHBhcGVyc1xuICAgICAgLm1hcCgod2FsbCwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9ICdzZXR0aW5ncy13YWxsLXByZSdcblxuICAgICAgICBpZiAod2FsbC5hY3RpdmUpIHtcbiAgICAgICAgICBjbGFzc05hbWUgKz0gJyBhY3RpdmUnXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5uZXIgPSAnJ1xuXG4gICAgICAgIGlmICh3YWxsLmVkaXRiYWxlKSB7XG4gICAgICAgICAgaW5uZXIgKz0gYDxzcGFuIGNsaWNrLWVtaXQ9XCJzZXR0aW5nX3dhbGxwYXBlcl9lZGl0OiR7aW5kZXh9XCI+RURJVDwvc3Bhbj5gXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2NsYXNzTmFtZX1cIlxuICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIndpZHRoOiAke3dhbFd9cHg7IGhlaWdodDogJHt3YWxIfXB4OyBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJHt3YWxsLnVybH0pXCJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2stZW1pdD1cInNldHRpbmdfd2FsbHBhcGVyX3RvZ2dsZToke2luZGV4fVwiXG4gICAgICAgICAgICAgICAgPiR7aW5uZXJ9PC9kaXY+XG4gICAgICAgICAgICAgICAgYFxuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKVxuICB9KVxuXG4gIC8vIFJlbmRlciBjb25maWdcbiAgd2luZG93LnNldHRpbmdfY29uZmlnX2lucHV0LnZhbHVlID0gSlNPTi5zdHJpbmdpZnkoc3RvcmFnZS5jb25maWcsIG51bGwsIDIpXG59XG5cbnNldHRpbmcudG9nZ2xlID0gKHN0YXRlKSA9PiB7XG4gIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhdGUgPSAhc2V0dGluZy5pc09wZW5cbiAgfVxuXG4gIHNldHRpbmcuaXNPcGVuID0gc3RhdGVcblxuICBpZiAoc3RhdGUpIHtcbiAgICB3aW5kb3cuc2V0dGluZ19ib3gucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpXG4gICAgc2V0dGluZy5yZW5kZXIoKVxuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5zZXR0aW5nX2JveC5hZGRDbGFzcygnaGlkZGVuJylcbiAgfVxufVxuXG5ldmVudC5vbignc2V0dGluZ19jbG9zZScsICgpID0+IHtcbiAgc2V0dGluZy50b2dnbGUoZmFsc2UpXG59KVxuXG5ldmVudC5vbignc2V0dGluZ19vcGVuJywgKCkgPT4ge1xuICBzZXR0aW5nLnRvZ2dsZSh0cnVlKVxufSlcblxuZXZlbnQub24oJ3NldHRpbmdfYmFja3VwJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IGxvY2FsID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KClcbiAgY29uc3QgZGF0YSA9IHt9XG5cbiAgZGF0YS5sb2NhbCA9IGxvY2FsXG4gIGRhdGEuc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2VcblxuICBjb25zdCBibG9iID0gbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGRhdGEpXSwgeyB0eXBlOiAndGV4dC9wbGFpbicgfSlcbiAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICBjb25zdCBhbmMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcblxuICBhbmMuaHJlZiA9IHVybFxuICBhbmMuZG93bmxvYWQgPSAnc2Vpbi1iYWNrdXAtJyArIG5vdy50b0xvY2FsZURhdGVTdHJpbmcoKS5yZXBsYWNlKC9cXC8vZywgJy0nKSArICcuanNvbidcblxuICBhbmMuY2xpY2soKVxuICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybClcbn0pXG5cbmV2ZW50Lm9uKCdzZXR0aW5nX3Jlc3RvcmUnLCAoKSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICBpbnB1dC50eXBlID0gJ2ZpbGUnXG5cbiAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAnY2hhbmdlJyxcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gaW5wdXQuZmlsZXNbMF1cbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcblxuICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbG9jYWwsIHN0b3JhZ2UsIG5vdGVzIH0gPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpXG5cbiAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzdG9yYWdlKSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtrZXldID0gc3RvcmFnZVtrZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KGxvY2FsKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vdGVzKSB7XG4gICAgICAgICAgbm90ZXIubm90ZXMgPSBub3Rlc1xuICAgICAgICAgIG5vdGVyLnNhdmUoKVxuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LmFsZXJ0KCdSZXN0b3JlIGNvbXBsZXRlZCcpXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfSlcblxuICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSlcbiAgICB9LFxuICAgIHsgb25jZTogdHJ1ZSB9LFxuICApXG5cbiAgaW5wdXQuY2xpY2soKVxufSlcblxuZXZlbnQub24oJ3NldHRpbmdfY29uZmlnX3NhdmUnLCAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZSh3aW5kb3cuc2V0dGluZ19jb25maWdfaW5wdXQudmFsdWUpXG4gICAgc3RvcmFnZS5jb25maWcgPSBjb25maWdcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgIHJldHVybiB3aW5kb3cuYWxlcnQoJ1BhcnNlIGFuZCBzYXZlIGNvbmZpZyBlcnJvcicpXG4gIH1cblxuICB3aW5kb3cuYWxlcnQoJ1NhdmUgY29uZmlnIHN1Y2Nlc3MnKVxufSlcblxuZXZlbnQub24oJ3NldHRpbmdfd2FsbHBhcGVyX3RvZ2dsZScsIChpbmRleCwgeyB0YXJnZXQgfSkgPT4ge1xuICBpbmRleCA9ICtpbmRleFxuXG4gIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldCgnd2FsbHBhcGVycycsICh7IHdhbGxwYXBlcnMgfSkgPT4ge1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKCdhY3RpdmUnKSAhPT0gLTFcblxuICAgIHdhbGxwYXBlcnNbaW5kZXhdLmFjdGl2ZSA9ICFpc0FjdGl2ZVxuICAgIHdhbGxwYXBlci5jYWNoZSh3YWxscGFwZXJzKVxuXG4gICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHtcbiAgICAgIHdhbGxwYXBlcnMsXG4gICAgfSlcblxuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgfVxuICB9KVxufSlcblxuZXZlbnQub24oJ3NldHRpbmdfd2FsbHBhcGVyX2VkaXQnLCAoaW5kZXgsIHsgdGFyZ2V0IH0pID0+IHtcbiAgaW5kZXggPSAraW5kZXhcblxuICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgaW5wdXQudHlwZSA9ICdmaWxlJ1xuXG4gIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgJ2NoYW5nZScsXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IGlucHV0LmZpbGVzWzBdXG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ3ZpZGVvLycpKSB7XG4gICAgICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgICAgICAgY29uc3Qgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJylcbiAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgICAgICAgdmlkZW8uY2xhc3NOYW1lID0gJ2ludmlzaWJsZSdcbiAgICAgICAgICBjYW52YXMuY2xhc3NOYW1lID0gJ2ludmlzaWJsZSdcblxuICAgICAgICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHJlYWRlci5yZXN1bHQpXG4gICAgICAgICAgc291cmNlLnNldEF0dHJpYnV0ZSgndHlwZScsIGZpbGUudHlwZSlcbiAgICAgICAgICB2aWRlby5hcHBlbmRDaGlsZChzb3VyY2UpXG4gICAgICAgICAgd2luZG93LnNldHRpbmdfYm94LmFwcGVuZENoaWxkKHZpZGVvKVxuXG4gICAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdmlkZW8udmlkZW9XaWR0aFxuICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHRcbiAgICAgICAgICAgICAgd2luZG93LnNldHRpbmdfYm94LmFwcGVuZENoaWxkKGNhbnZhcylcblxuICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgdmlkZW8udmlkZW9XaWR0aCwgdmlkZW8udmlkZW9IZWlnaHQpXG5cbiAgICAgICAgICAgICAgY29uc3QgeyB3YWxscGFwZXJzIH0gPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoJ3dhbGxwYXBlcnMnKVxuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJylcblxuICAgICAgICAgICAgICB3aW5kb3cuc2V0dGluZ19ib3gucmVtb3ZlQ2hpbGQodmlkZW8pXG4gICAgICAgICAgICAgIHdpbmRvdy5zZXR0aW5nX2JveC5yZW1vdmVDaGlsZChjYW52YXMpXG5cbiAgICAgICAgICAgICAgd2FsbHBhcGVyc1tpbmRleF0udXJsID0gcmVzdWx0XG4gICAgICAgICAgICAgIHdhbGxwYXBlcnNbaW5kZXhdLnZpZGVvID0gaW5kZXhcblxuICAgICAgICAgICAgICB3YWxscGFwZXIuY2FjaGUod2FsbHBhcGVycylcblxuICAgICAgICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe1xuICAgICAgICAgICAgICAgIHdhbGxwYXBlcnMsXG4gICAgICAgICAgICAgICAgW2B3YWxscGFwZXJfdmlkZW9zXyR7aW5kZXh9YF06IHJlYWRlci5yZXN1bHQsXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRhcmdldC5wYXJlbnRFbGVtZW50XG4gICAgICAgICAgICAgIGl0ZW0uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke3Jlc3VsdH0pYFxuICAgICAgICAgICAgfSwgMjAwKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlLnR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgICBjb25zdCB7IHdhbGxwYXBlcnMgfSA9IGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldCgnd2FsbHBhcGVycycpXG5cbiAgICAgICAgICB3YWxscGFwZXJzW2luZGV4XS51cmwgPSByZWFkZXIucmVzdWx0XG5cbiAgICAgICAgICB3YWxscGFwZXIuY2FjaGUod2FsbHBhcGVycylcblxuICAgICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7XG4gICAgICAgICAgICB3YWxscGFwZXJzLFxuICAgICAgICAgICAgW2B3YWxscGFwZXJfdmlkZW9zXyR7aW5kZXh9YF06ICcnLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjb25zdCBpdGVtID0gdGFyZ2V0LnBhcmVudEVsZW1lbnRcbiAgICAgICAgICBpdGVtLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtyZWFkZXIucmVzdWx0fSlgXG5cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGFsZXJ0KCdPbmx5IGFjY2VwdCBpbWFnZSBvciB2aWRlbycpXG4gICAgICB9KVxuXG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKVxuICAgIH0sXG4gICAgeyBvbmNlOiB0cnVlIH0sXG4gIClcblxuICBpbnB1dC5jbGljaygpXG59KVxuXG5leHBvcnQgZGVmYXVsdCBzZXR0aW5nXG4iLCJpbXBvcnQgc3RvcmFnZSBmcm9tICcuL2NvcmUvc3RvcmFnZSdcblxuY29uc3Qgd2FsbHBhcGVyID0ge1xuICBkZWZhdWx0OiB7XG4gICAgd2FsbHBhcGVyczogW1xuICAgICAge1xuICAgICAgICB1cmw6IGBpbWcvdzAuanBnYCxcbiAgICAgICAgdmlkZW86IDAsXG4gICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogYGltZy93MS5qcGdgLFxuICAgICAgICB2aWRlbzogMSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogYGltZy93Mi5qcGdgLFxuICAgICAgICB2aWRlbzogMixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBsb2NhbDoge1xuICAgICAgd2FsbHBhcGVyX3ZpZGVvc18wOiAndmlkZW8vdzAubXA0JyxcbiAgICAgIHdhbGxwYXBlcl92aWRlb3NfMTogJ3ZpZGVvL3cxLm1wNCcsXG4gICAgICB3YWxscGFwZXJfdmlkZW9zXzI6ICd2aWRlby93Mi5tcDQnLFxuICAgIH0sXG4gIH0sXG59XG5cbndhbGxwYXBlci5pbml0ID0gKCkgPT4ge1xuICBjb25zdCB3YWxscGFwZXJzID0gd2FsbHBhcGVyLmRlZmF1bHQud2FsbHBhcGVyc1xuXG4gIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7XG4gICAgLi4ud2FsbHBhcGVyLmRlZmF1bHQubG9jYWwsXG5cbiAgICB3YWxscGFwZXJzOiB3YWxscGFwZXJzLmNvbmNhdChcbiAgICAgIEFycmF5KDkpLmZpbGwoe1xuICAgICAgICB1cmw6IGBpbWcvcGxhY2Vob2xkZXIucG5nYCxcbiAgICAgICAgZWRpdGJhbGU6IHRydWUsXG4gICAgICB9KSxcbiAgICApLFxuICB9KVxuXG4gIHJldHVybiB3YWxscGFwZXIuY2FjaGUod2FsbHBhcGVycylcbn1cblxud2FsbHBhcGVyLmNhY2hlID0gKHdhbGxwYXBlcnMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhY3RpdmVzID0gd2FsbHBhcGVycy5maWx0ZXIoKHcpID0+IHcuYWN0aXZlKVxuICAgIHN0b3JhZ2Uud2FsbHBhcGVycyA9IGFjdGl2ZXNcblxuICAgIHJldHVybiBhY3RpdmVzXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYWxlcnQoJ1RoZSB2YWx1ZSBvZiB3YWxscGFwZXJzIGV4Y2VlZGVkIHRoZSBxdW90YScpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG53YWxscGFwZXIuYm9vdCA9ICgpID0+IHtcbiAgY29uc3Qgd2FsbHBhcGVycyA9IHN0b3JhZ2Uud2FsbHBhcGVycyB8fCB3YWxscGFwZXIuaW5pdCgpXG4gIGNvbnN0IHBpY2sgPSB3YWxscGFwZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHdhbGxwYXBlcnMubGVuZ3RoKV1cblxuICBpZiAoIXBpY2spIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHdpbmRvdy53YWxsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtwaWNrLnVybH0pYFxuXG4gIGlmIChwaWNrLnZpZGVvID4gLTEpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGB3YWxscGFwZXJfdmlkZW9zXyR7cGljay52aWRlb31gXG5cbiAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldChrZXksIChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpXG5cbiAgICAgICAgc291cmNlLnNyYyA9IGRhdGFba2V5XVxuICAgICAgICBzb3VyY2UudHlwZSA9ICd2aWRlby9tcDQnXG5cbiAgICAgICAgd2luZG93LndhbGxfdmlkZW8uYXBwZW5kQ2hpbGQoc291cmNlKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdhbGxwYXBlclxuIiwiY29uc3Qgd2F2ZXIgPSB7fVxuXG53YXZlci5hZGQgPSAoeCwgeSkgPT4ge1xuICB3aW5kb3cud2F2ZV9jbGlja19ib3guaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJ3YXZlIGFjdGl2ZVwiIHN0eWxlPVwidHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpXCI+XG4gICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDxkaXY+PC9kaXY+XG4gICAgPC9kaXY+YFxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIChldmVudCkgPT4ge1xuICB3YXZlci5hZGQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSlcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IHdhdmVyXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0ICcuL3Byb3RvdHlwZSdcbmltcG9ydCB3YWxscGFwZXIgZnJvbSAnLi93YWxscGFwZXInXG5pbXBvcnQgZW1pdHRlciBmcm9tICcuL2NvcmUvZW1pdHRlcidcbmltcG9ydCBzdG9yYWdlIGZyb20gJy4vY29yZS9zdG9yYWdlJ1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2NvcmUvbG9nZ2VyJ1xuaW1wb3J0IG5vdGVyIGZyb20gJy4vbm90ZXInXG5pbXBvcnQgYm9va21hcmsgZnJvbSAnLi9ib29rbWFyaydcbmltcG9ydCAnLi93YXZlcidcbmltcG9ydCAnLi9zZXR0aW5nJ1xuXG53aW5kb3cuaG9sZGVyID0ge1xuICB3X3c6IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gIHdfaDogd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsXG5cbiAgY29kZV90YWJsZXM6IFtcbiAgICB7IGNvZGU6ICdkYXRlPT0nLCB2YWx1ZTogbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKSB9LFxuICAgIHsgY29kZTogJ3RpbWU9PScsIHZhbHVlOiBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpIH0sXG4gICAgeyBjb2RlOiAnbm93PT0nLCB2YWx1ZTogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpIH0sXG4gICAgeyBjb2RlOiAnbmFtZV8oLis/KT09JywgdmFsdWU6ICdIaSBzaXIsICQgPDMnIH0sXG4gIF0sXG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gIGhvbGRlci53X3cgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG4gIGhvbGRlci53X2ggPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxufSlcblxud2FsbHBhcGVyLmJvb3QoKVxubm90ZXIuYm9vdCgpXG5ib29rbWFyay5ib290KClcbmVtaXR0ZXIuY2xpY2soKVxuXG5zdG9yYWdlLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oXG4gIHtcbiAgICBsb2dfbGV2ZWw6ICdlcnJvcicsXG4gICAgbnVtYmVyX29mX3dvcmtzcGFjZTogMixcbiAgfSxcbiAgc3RvcmFnZS5jb25maWcsXG4pXG5cbmlmIChzdG9yYWdlLndvcmtzcGFjZSkge1xuICBpZiAoc3RvcmFnZS53b3Jrc3BhY2UgPT09IC0xKSB7XG4gICAgc3RvcmFnZS53b3Jrc3BhY2UrK1xuICB9XG5cbiAgd2luZG93LmJ0bl9zd2l0Y2hfd29ya3NwYWNlLmlubmVySFRNTCA9IHN0b3JhZ2Uud29ya3NwYWNlXG59IGVsc2Uge1xuICB3aW5kb3cuYnRuX3N3aXRjaF93b3Jrc3BhY2UuaW5uZXJIVE1MID0gJzAnXG59XG5cbmxvZ2dlci5sb2dfbGV2ZWwgPSBzdG9yYWdlLmNvbmZpZy5sb2dfbGV2ZWxcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==