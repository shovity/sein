/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/bookmark.js":
/*!*************************!*\
  !*** ./src/bookmark.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");


const bookmark = {
    bookmarkBarElement: window.bookmark_bar,
}

/**
* Create bookmark item from bookmark nodes
* @param  {Object} node
* @return {string} HTML generated by bookmark node
*/
bookmark.create = (node) => {
    const { url, title, children } = node

    if (children) {
        setTimeout(() => bookmark.render(node))
        return ''
    }
    
    return `
    <a class="item" href="${url}">
        <img src="${chrome.runtime.getURL("/_favicon/")}?pageUrl=${url}">
        <div class="title">${title}</div>
    </a>`
}

/**
* Create a parent of bookmark, this is a group of bookmark items
* @param  {Object} node
* @return {string}      HTML generated by bookmark nodes
*/
bookmark.createParent = (node) => {
    const label = node.title
    const nodes = node.children
    const childs = nodes.map(node => bookmark.create(node)).join('')
    const parentId = `${label}-${node.parentId || 'root'}`
    const status = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][`bookmark:parent:${parentId}`] || 'open'
    
    return `
    <div class="parent ${status}">
        <div class="parent-header" data-parent-id="${parentId}">
            <span class="icon icon-folder"></span>
            <div class="label">${label}</div>
        </div>
        <div class="stopgrap"></div>
        <div class="parent-childs">${childs}</div>
    </div>`
}

/**
* Render bookmark from bookmark node
* @param  {Object}  node
* @param  {Boolean} [clear=false] clean bookmark bar before render
*/
bookmark.render = (node, clear=false) => {
    if (clear) {
        bookmark.bookmarkBarElement.innerHTML = ''
    }

    bookmark.bookmarkBarElement.innerHTML += bookmark.createParent(node)
}

/**
* ToggleOpenParent
* @param  {string} parentId
*/
bookmark.toggleOpenParent = (parentId) => {
    // set config
    const key = `bookmark:parent:${parentId}`
    const open = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][key] === 'close'? 'open' : 'close'
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"][key] = open
    
    // change style bookmark parent
    document.querySelector(`[data-parent-id="${parentId}"]`).parentNode.className = `parent ${open}`
}

bookmark.fetch = () => {
    chrome.topSites.get((tops) => {
        bookmark.render({ children: tops, title: 'Most visited' }, true)
        
        chrome.bookmarks.getTree((bookmarks) => {
            bookmark.render(bookmarks[0].children[0])
        })
    })
}

bookmark.bookmarkBarElement.addEventListener('click', ({ target }) => {
    const id = target.getAttribute('data-parent-id') || target.parentNode.getAttribute('data-parent-id')

    if (id) {
        bookmark.toggleOpenParent(id)
    }
})

chrome.bookmarks.onCreated.addListener(bookmark.fetch)
chrome.bookmarks.onRemoved.addListener(bookmark.fetch)
chrome.bookmarks.onChanged.addListener(bookmark.fetch)
chrome.bookmarks.onMoved.addListener(bookmark.fetch)

bookmark.fetch()

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bookmark);

/***/ }),

/***/ "./src/core/emitter.js":
/*!*****************************!*\
  !*** ./src/core/emitter.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/core/logger.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event */ "./src/core/event.js");



const emitter = {}
const mounted = {}

emitter.mounted = mounted

/**
 * Emitter generator
 * @param name {string} Emitter name
 * @param handle {function} Call one time for setup emitter
 */
emitter.gen = (name, handle) => {
    if (emitter[name] || !/^[a-zA-Z][a-zA-Z0-9_]{0,63}$/.test(name)) {
        return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error(`emitter: name "${name}" existed or invalid`)
    }

    emitter[name] = () => {
        if (mounted[name]) {
            return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error(`emitter: duplicate mount emitter ${name}`)
        }

        handle()

        mounted[name] = true
    }
}

// Define emitter

emitter.gen('click', () => {
    function handleClickR(target, domEvent, up = 0) {
        if (up > 5 || !target) {
            return
        }

        const clickEmit = target.getAttribute('click-emit')

        if (!clickEmit) {
            return handleClickR(target.parentElement, domEvent, up + 1)
        }

        const name = clickEmit.split(':')[0]

        let payload = clickEmit.split(':').slice(1).join(':')

        // handle object payload
        if (payload[0] === '?') {
            const payloadObject = {}
            payload
                .slice(1)
                .split('&')
                .forEach((q) => {
                    const [key, value] = q.split('=')
                    if (key === '') {
                        return
                    }
                    payloadObject[key] = value
                })
            payload = payloadObject
        }

        _event__WEBPACK_IMPORTED_MODULE_1__["default"].next(name, payload, { target, domEvent })
    }

    window.document.body.addEventListener('click', (domEvent) => {
        handleClickR(domEvent.target, domEvent)
    })

    _logger__WEBPACK_IMPORTED_MODULE_0__["default"].info('emiter: click emiter mounted')
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (emitter);


/***/ }),

/***/ "./src/core/event.js":
/*!***************************!*\
  !*** ./src/core/event.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/core/logger.js");


const event = {
    pool: {},
}

event.emit = (name, ...payload) => {
    for (const handle of event.pool[name] || []) {
        handle(...payload)
    }
}

event.on = (name, handle) => {
    event.pool[name]?.push(handle) || (event.pool[name] = [handle])
}

event.next = (name, ...payload) => {
    setTimeout(event.emit, 0, name, ...payload)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (event);


/***/ }),

/***/ "./src/core/logger.js":
/*!****************************!*\
  !*** ./src/core/logger.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const LEVEL = [
    'debug',
    'info',
    'warning',
    'error',
]

const logger = {
    log_level: 'debug',

    get debug() {
        if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('debug')) {
            return console.debug.bind(window.console, '%cDEBUG:', 'color: #6c757d')
        }
        
        return () => undefined
    },

    get info() {
        if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('info')) {
            return console.info.bind(window.console, '%cINFO:', 'color: #17a2b8')
        }
        
        return () => undefined
    },

    get warning() {
        if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('warning')) {
            return console.warn.bind(window.console, '%cWARNING:', 'color: #ffc107')
        }
        
        return () => undefined
    },

    get error() {
        if (LEVEL.indexOf(this.log_level.toLowerCase()) <= LEVEL.indexOf('error')) {
            return console.error.bind(window.error, '%cERROR:', 'color: #dc3545')
        }
        
        return () => undefined
    },
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (logger);


/***/ }),

/***/ "./src/core/storage.js":
/*!*****************************!*\
  !*** ./src/core/storage.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/core/logger.js");


const storage = {}
const handler = {}

handler.get = (target, key) => {
    if (key === 'origin') {
        return target
    }

    const raw = localStorage[key]
    
    try {
        return raw && JSON.parse(raw)
    } catch (error) {
        return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].error('storage: parse json fail, key: ', key)
    }
}

handler.set = (target, key, value) => {    
    localStorage[key] = JSON.stringify(value)
    target[key] = value
    return true
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Proxy(storage, handler));


/***/ }),

/***/ "./src/noter.js":
/*!**********************!*\
  !*** ./src/noter.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/logger */ "./src/core/logger.js");
/* harmony import */ var _core_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/event */ "./src/core/event.js");




const noter = {
    notes: [],
    MAX_NOTE_NUMBER: 300,
    MAX_NOTE_CHARACTER: 3000,
}

noter.fetch = () => {
    chrome.storage.local.get('notes').then(({ notes }) => {
        noter.notes = notes
        noter.render()
    })
}

noter.save = () => {
    _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('noter save:', noter.notes)
    chrome.storage.local.set({ notes: noter.notes })
}

noter.createObject = (note) => {
    const defaultData = {
        msg: '',
        x: Math.floor(Math.random() * (holder.w_w - 500)),
        y: Math.floor(Math.random() * (holder.w_h - 250)),
        w: 300,
        h: 100,
        workspace: _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace,
        type: 'nomal',
        status: 'default',
    }
    
    return Object.assign(defaultData, note)
}

noter.createElement = (note) => {
    const { id, msg, x, y, w, h, type, status } = note
    const dom = document.createElement('div')

    dom.setAttribute('id', `noteid_${id}`)
    dom.setAttribute('class', 'note')
    dom.setAttribute('style', `transform: translate(${x}px, ${y}px)`)
    dom.setAttribute('note-status', status || 'default')

    dom.innerHTML = `
    <div class="box">
        <div class="note-controls" move-noteid="${id}">
            <div class="note-remove" remove-noteid="${id}">&times;</div>
        </div>
        <div class="rain-bow">
            <div mark="${id}:primary"></div>
            <div mark="${id}:success"></div>
            <div mark="${id}:danger"></div>
        </div>
        <textarea
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            editor-noteid="${id}"
            style="width:${w}px;height:${h-20}px;"
        >${msg}</textarea>
    </div>`

    return dom
}

noter.add = (note) => {
    if (noter.notes.length > noter.MAX_NOTE_NUMBER) {
        return alert('The maximum number of notes has been reached')
    }

    // New note don't have a id, push it to noter.notes
    if (note.id === undefined) {
        note.id = Date.now().toString()
        noter.notes.push(note)
    }
    
    _core_logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug(`add note ${note.id} = ${note.msg}`)
    
    // Render html
    window.note_box.appendChild(noter.createElement(note))
}

noter.render = (clear=true, workspace=+_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0) => {
    // Clear before render
    if (clear) {
        note_box.innerHTML = ''
    }
    
    // Loop adding
    noter.notes.filter(note => {
        return workspace === +note.workspace 
    }).forEach(note => {
        noter.add(note)
    })
}

noter.checkAndReplaceCode = (target) => {
    const string = target.value
    
    holder.code_tables.forEach(code => {
        const cregex = new RegExp(code.code)

        const result = string.match(cregex)
        if (result) {
            const datas = result.slice(1)

            const oldSelectionStart = target.selectionStart
            const oldValue = target.value

            let codeValue = code.value

            datas.forEach((data) => {
                codeValue = codeValue.replace('$', data)
            })

            target.value = string.replace(cregex, codeValue)

            const newSelectionStart = oldSelectionStart + target.value.length - oldValue.length
            target.setSelectionRange(newSelectionStart, newSelectionStart)
        }
    })
}

noter.remove = (id) => {
    const index = noter.notes.findIndex((note) => note.id == id)
    noter.notes.splice(index, 1)

    // Remove dom
    const dom = window[`noteid_${id}`]
    dom.parentElement.removeChild(dom)

    noter.save()
}

noter.mark = (id, status) => {
    const note = noter.notes.find(n => n.id == id)

    if (note.status === status) {
        note.status = 'default'
    } else {
        note.status = status
    }

    window[`noteid_${id}`].setAttribute('note-status', note.status)
    noter.save()
}

// NOTER BEHAVIOR
{
    let resizeId = false
    let moveId = false
    let fixX = 0
    let fixY = 0

    // Listen click note
    window.note_box.addEventListener('click', event => {
        const { target } = event

        const removeId = target.getAttribute('remove-noteid')
        const mark = target.getAttribute('mark')
        
        if (removeId) {
            noter.remove(removeId)
        } else if (mark) {
            const [ noteId, status ] = mark.split(':')
            noter.mark(noteId, status)
        }
    })
    
    // Handle move
    window.note_box.addEventListener('mousedown', event => {
        
        // Prevent right mouse
        if (event.which === 3) {
            return
        }

        const { target } = event
        
        // Detect resize
        if (target.getAttribute('editor-noteid') !== null) {
            const cx = event.clientX
            const cy = event.clientY
            const noteId = +target.getAttribute('editor-noteid')
            const noteIndex = noter.notes.findIndex((note) => note.id == noteId)
            const note = noter.notes[noteIndex]
            
            // Detect mouse down over resize btn
            if (note.x + note.w - cx < 15 && note.y + note.h - cy < 15) {
                resizeId = noteId
            }
        }
        
        if (target.getAttribute('move-noteid') !== null) {
            const noteId = +target.getAttribute('move-noteid')
            const noteIndex = noter.notes.findIndex((note) => note.id == noteId)
            
            // Fix position mouse vs note
            fixX = event.clientX - noter.notes[noteIndex].x
            fixY = event.clientY - noter.notes[noteIndex].y
            
            // Start move handle
            moveId = noteId
        }
    })
    
    window.addEventListener('mousemove', event => {
        if (moveId === false) return
        
        event.preventDefault()
        let x = event.clientX - fixX
        let y = event.clientY - fixY

        if (y < 0) {
            y = 0
        }

        if (y > holder.w_h - 20) {
            y = holder.w_h - 20
        }

        if (x < 0) {
            x = 0
        }

        if (x > holder.w_w - 20) {
            x = holder.w_w - 20
        }
        
        if (window[`noteid_${moveId}`]) window[`noteid_${moveId}`].style.transform = `translate(${x}px, ${y}px)`
    })
    
    window.addEventListener('mouseup', event => {
        if (moveId !== false) {
            const x = event.clientX - fixX
            const y = event.clientY - fixY
            const noteIndex = noter.notes.findIndex((note) => note.id == moveId)
            
            if (noteIndex !== -1) {
                noter.notes[noteIndex].x = x
                noter.notes[noteIndex].y = y
            }
            
            // End move handle
            moveId = false
            
            // Save when done move a note
            noter.save()
            
        } else if (resizeId !== false) {
            const { target } = event
            const noteIndex = noter.notes.findIndex((note) => note.id == resizeId)
            const w = window['noteid_' + resizeId].offsetWidth
            const h = window['noteid_' + resizeId].offsetHeight
            
            if (noteIndex !== -1) {
                noter.notes[noteIndex].w = w
                noter.notes[noteIndex].h = h
            }
            
            // End resize handle
            resizeId = false
            
            // Save when done move a note
            noter.save()
        }
        
        
    })
    
    // Handle edit notes
    // Keyup only when focus textarea
    window.note_box.addEventListener('keyup', ({ target, key }) => {
        const id = target.getAttribute('editor-noteid')
        
        if (id) {
            const index = noter.notes.findIndex((note) => note.id == id)
            
            // Handle note code
            if (key === '=') {
                noter.checkAndReplaceCode(target)
            }

            // Check max note character
            if (target.value.length > noter.MAX_NOTE_CHARACTER) {
                return alert('The maximum character has been reached')
            }
            
            noter.notes[index].msg = target.value
            noter.save()
        }
    })
    
    // Listen add note
    _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('noter_add', () => {
        noter.add(noter.createObject())
        noter.save()
    })
    
    // Listen switch workspace
    _core_event__WEBPACK_IMPORTED_MODULE_2__["default"].on('noter_switch_workspace', () => {
        let workspace = +_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace || 0

        if (workspace > 2) {
            workspace = 0
        } else {
            workspace++
        }
        
        window.btn_switch_workspace.innerHTML = workspace
        _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].workspace = workspace

        noter.save()
        noter.render()
    })

    // Listen sync notes cross tab
    chrome.storage.onChanged.addListener((changes, namespace) => {
        if (namespace === 'local' && changes.notes && document.hidden) {
            noter.notes = changes.notes.newValue
            noter.render()
        }
    })
}

noter.fetch()

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (noter);

/***/ }),

/***/ "./src/prototype.js":
/*!**************************!*\
  !*** ./src/prototype.js ***!
  \**************************/
/***/ (() => {

Array.prototype.sum = function () {
    return this.reduce((acc, e) => acc + e)
}

HTMLElement.prototype.addClass = function (className) {
    const regex = new RegExp( `^${className}$|^${className} | ${className}$| ${className}( )`, 'g')
    if (!regex.test(this.className)) {
        this.className = `${this.className} ${className}`.trim()
    }
}

HTMLElement.prototype.removeClass = function (className) {
    const regex = new RegExp( `^${className}$|^${className} | ${className}$| ${className}( )`, 'g')
    this.className = this.className.replace(regex, '$1').trim()
}

HTMLCollection.prototype.toArray = function () {
    return [...this]
}

NodeList.prototype.toArray = function () {
    return [...this]
}

/***/ }),

/***/ "./src/setting.js":
/*!************************!*\
  !*** ./src/setting.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/event */ "./src/core/event.js");
/* harmony import */ var _noter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noter */ "./src/noter.js");




const PLACEHOLDER_IMG_SRC = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQYV2M4c+bMfwAIMANkq3cY2wAAAABJRU5ErkJggg=='
const EXTEND_WALLPAPER_SIZE = 5

const setting = {
    isOpen: false,
    blob_buffer_url: null,
}

setting.render = () => {
    // render wallpaper
    const walW = window.settings_wallpapers.clientWidth / 6 - 10
    const walH = walW * holder.w_h / holder.w_w

    if (_core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers.length === 3) {
        
        // add placeholder for edit
        _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = [
            ..._core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers,
            ...new Array(EXTEND_WALLPAPER_SIZE).fill({ url: PLACEHOLDER_IMG_SRC }),
        ]
    }

    window.settings_wallpapers.innerHTML = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers.map((wall, index) => {
        let className = 'settings-wall-pre'
        if (wall.active) {
            className += ' active'
        }

        let inner = ''

        if (index >= 3) {
            inner += `<span click-emit="setting_wallpaper_edit:${index}">EDIT</span>`
        }

        return `
        <div
            class="${className}"
            style="width: ${walW}px; height: ${walH}px; background-image: url(${wall.url})"
            click-emit="setting_wallpaper_toggle:${index}"
        >${inner}</div>
        `
    }).join('')

    // render config
    window.setting_config_input.value = JSON.stringify(config)
        .replace(/,/g, ',\n')
        .replace('{', '{\n')
        .replace('}', '\n}')

    // render code table
    window.setting_code_table_input.value = holder.code_tables.map(codeTable => {
        return `${codeTable.code.slice(0, -2)} -> ${codeTable.value}`
    }).join('\n')
}

setting.toggle = state => {
    if (state === undefined) {
        state = !setting.isOpen
    }

    setting.isOpen = state

    if (state) {
        window.setting_box.removeClass('hidden')
        setting.render()
    } else {
        window.setting_box.addClass('hidden')
    }
}

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_close', () => {
    setting.toggle(false)
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_open', () => {
    setting.toggle(true)
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_backup', () => {
    const now = new Date()

    const data = {}
    data.notes = _noter__WEBPACK_IMPORTED_MODULE_2__["default"].notes
    data.storage = JSON.parse(JSON.stringify(localStorage))

    const jsonStringData = JSON.stringify(data)

    const blob = new Blob([jsonStringData], { type: 'text/plain' })

    // try collect buffer memory
    if (setting.blob_buffer_url !== null) {
        window.URL.revokeObjectURL(setting.blob_buffer_url)
    }

    setting.blob_buffer_url = window.URL.createObjectURL(blob)

    const anc = document.createElement('a')
    anc.href = setting.blob_buffer_url
    anc.download = 'sein-backup-' + now.toLocaleDateString().replace(/\//g, '-') + '.json'
    anc.click()
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_restore', () => {
    const input = document.createElement('input')
    input.type = 'file'

    input.addEventListener('change', () => {
        const file = input.files[0]
        const reader = new FileReader()

        reader.addEventListener('load', () => {
            const backupJsonStringData = reader.result
            const backupData = JSON.parse(backupJsonStringData)
            const { notes, storage } = backupData

            port.postMessage({ request: 'post_notes', data: notes })

            Object.keys(storage).forEach(k => {
                localStorage[k] = storage[k]
            })

            alert('Restore complated')
            location.reload()
        })

        reader.readAsText(file)
    }, { once: true })

    input.click()
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_config_save', () => {
    try {
        const config = JSON.parse(setting_config_input.value)
        _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].config = config
        window.config = config
    } catch (error) {
        return alert('Parse config error')
    }
    alert('Save config success')
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_wallpaper_toggle', (index, { target }) => {
    index = +index

    const wallpapers = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers
    const isActive = target.className.indexOf('active') !== -1

    if (isActive) {
        target.removeClass('active')
    } else {
        target.addClass('active')
    }

    wallpapers[index].active = !isActive
    
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = wallpapers
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_wallpaper_edit', (index, { target }) => {
    index = +index

    const input = document.createElement('input')
    input.type = 'file'
    
    input.addEventListener('change', () => {
        const file = input.files[0]
        const reader = new FileReader()

        // check file size
        if (file.size > 1048576) {
            return alert('Image must be less than 1 megabytes')
        }

        reader.addEventListener("load", () => {
            const buffys = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers

            buffys[index].url = reader.result
            _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = buffys
            
            const item = target.parentElement
            item.style.backgroundImage = `url(${reader.result})`
        })

        reader.readAsDataURL(file)
    }, { once: true })

    input.click()
})

_core_event__WEBPACK_IMPORTED_MODULE_1__["default"].on('setting_wallpaper_reset', () => {
    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = null
    location.reload()
})


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setting);

/***/ }),

/***/ "./src/wallpaper.js":
/*!**************************!*\
  !*** ./src/wallpaper.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");


let wallpapers = _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers

if (!wallpapers) {
    wallpapers = [
        {
            url: `img/w1.jpg`,
            active: true,
        },
        {
            url: `img/w2.jpg`,
            active: true,
        },
        {
            url: `img/w3.jpg`,
            active: true,
        },
    ]

    _core_storage__WEBPACK_IMPORTED_MODULE_0__["default"].wallpapers = wallpapers
}

wallpapers = wallpapers.filter((w) => w.active)

const wallForShow = wallpapers[Math.floor(Math.random() * wallpapers.length)]

if (wallForShow) {
    window.wall.style.backgroundImage = `url(${wallForShow.url})`

    setTimeout(() => {
        window.wall_ghost_left.style.backgroundImage = `url(${wallForShow.url})`
        window.wall_ghost_right.style.backgroundImage = `url(${wallForShow.url})`
    }, 500)
}


/***/ }),

/***/ "./src/waver.js":
/*!**********************!*\
  !*** ./src/waver.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const waver = {}

waver.add = (x, y) => {
    window.wave_click_box.innerHTML = `
    <div class="wave active" style="transform: translate(${x}px, ${y}px)">
        <div></div>
        <div></div>
        <div></div>
    </div>`
}

window.addEventListener('mouseup', (event) => {
    waver.add(event.clientX, event.clientY)
})

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (waver);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!***********************!*\
  !*** ./src/newtab.js ***!
  \***********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _prototype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prototype */ "./src/prototype.js");
/* harmony import */ var _prototype__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prototype__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wallpaper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wallpaper */ "./src/wallpaper.js");
/* harmony import */ var _core_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/event */ "./src/core/event.js");
/* harmony import */ var _core_emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/emitter */ "./src/core/emitter.js");
/* harmony import */ var _core_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/storage */ "./src/core/storage.js");
/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/logger */ "./src/core/logger.js");
/* harmony import */ var _noter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./noter */ "./src/noter.js");
/* harmony import */ var _bookmark__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bookmark */ "./src/bookmark.js");
/* harmony import */ var _waver__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./waver */ "./src/waver.js");
/* harmony import */ var _setting__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./setting */ "./src/setting.js");












window.config = _core_storage__WEBPACK_IMPORTED_MODULE_4__["default"].config || {
    log_level: 'debug',
}

window.holder = {
    w_w: window.document.documentElement.clientWidth,
    w_h: window.document.documentElement.clientHeight,

    code_tables: [
        { code: 'date==', value: new Date().toLocaleDateString() },
        { code: 'time==', value: new Date().toLocaleTimeString() },
        { code: 'now==', value: new Date().toLocaleString() },
        // { code: 'name_(.+?)', value: 'Hi sir, $ <3' },
    ],
}

window.addEventListener('resize', () => {
    holder.w_w = window.document.documentElement.clientWidth
    holder.w_h = window.document.documentElement.clientHeight
})

_core_emitter__WEBPACK_IMPORTED_MODULE_3__["default"].click()

_core_logger__WEBPACK_IMPORTED_MODULE_5__["default"].log_level = config.log_level
window.btn_switch_workspace.innerHTML = _core_storage__WEBPACK_IMPORTED_MODULE_4__["default"].workspace || 0

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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STtBQUNBO0FBQ0Y7QUFDUDtBQUNNO0FBQ047QUFDSTs7QUFFL0IsZ0JBQWdCLDREQUFjO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSx3REFBd0Q7QUFDbEUsVUFBVSx3REFBd0Q7QUFDbEUsVUFBVSxtREFBbUQ7QUFDN0QsYUFBYSwyQ0FBMkM7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDJEQUFhOztBQUViLDhEQUFnQjtBQUNoQix3Q0FBd0MsK0RBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9ib29rbWFyay5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL2NvcmUvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL2NvcmUvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vc2Vpbi8uL3NyYy9jb3JlL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL2NvcmUvc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL25vdGVyLmpzIiwid2VicGFjazovL3NlaW4vLi9zcmMvcHJvdG90eXBlLmpzIiwid2VicGFjazovL3NlaW4vLi9zcmMvc2V0dGluZy5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL3dhbGxwYXBlci5qcyIsIndlYnBhY2s6Ly9zZWluLy4vc3JjL3dhdmVyLmpzIiwid2VicGFjazovL3NlaW4vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vc2Vpbi93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9zZWluL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9zZWluL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vc2Vpbi93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3NlaW4vLi9zcmMvbmV3dGFiLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdG9yYWdlIGZyb20gJy4vY29yZS9zdG9yYWdlJ1xuXG5jb25zdCBib29rbWFyayA9IHtcbiAgICBib29rbWFya0JhckVsZW1lbnQ6IHdpbmRvdy5ib29rbWFya19iYXIsXG59XG5cbi8qKlxuKiBDcmVhdGUgYm9va21hcmsgaXRlbSBmcm9tIGJvb2ttYXJrIG5vZGVzXG4qIEBwYXJhbSAge09iamVjdH0gbm9kZVxuKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgZ2VuZXJhdGVkIGJ5IGJvb2ttYXJrIG5vZGVcbiovXG5ib29rbWFyay5jcmVhdGUgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgdXJsLCB0aXRsZSwgY2hpbGRyZW4gfSA9IG5vZGVcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGJvb2ttYXJrLnJlbmRlcihub2RlKSlcbiAgICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBgXG4gICAgPGEgY2xhc3M9XCJpdGVtXCIgaHJlZj1cIiR7dXJsfVwiPlxuICAgICAgICA8aW1nIHNyYz1cIiR7Y2hyb21lLnJ1bnRpbWUuZ2V0VVJMKFwiL19mYXZpY29uL1wiKX0/cGFnZVVybD0ke3VybH1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+JHt0aXRsZX08L2Rpdj5cbiAgICA8L2E+YFxufVxuXG4vKipcbiogQ3JlYXRlIGEgcGFyZW50IG9mIGJvb2ttYXJrLCB0aGlzIGlzIGEgZ3JvdXAgb2YgYm9va21hcmsgaXRlbXNcbiogQHBhcmFtICB7T2JqZWN0fSBub2RlXG4qIEByZXR1cm4ge3N0cmluZ30gICAgICBIVE1MIGdlbmVyYXRlZCBieSBib29rbWFyayBub2Rlc1xuKi9cbmJvb2ttYXJrLmNyZWF0ZVBhcmVudCA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSBub2RlLnRpdGxlXG4gICAgY29uc3Qgbm9kZXMgPSBub2RlLmNoaWxkcmVuXG4gICAgY29uc3QgY2hpbGRzID0gbm9kZXMubWFwKG5vZGUgPT4gYm9va21hcmsuY3JlYXRlKG5vZGUpKS5qb2luKCcnKVxuICAgIGNvbnN0IHBhcmVudElkID0gYCR7bGFiZWx9LSR7bm9kZS5wYXJlbnRJZCB8fCAncm9vdCd9YFxuICAgIGNvbnN0IHN0YXR1cyA9IHN0b3JhZ2VbYGJvb2ttYXJrOnBhcmVudDoke3BhcmVudElkfWBdIHx8ICdvcGVuJ1xuICAgIFxuICAgIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cInBhcmVudCAke3N0YXR1c31cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhcmVudC1oZWFkZXJcIiBkYXRhLXBhcmVudC1pZD1cIiR7cGFyZW50SWR9XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gaWNvbi1mb2xkZXJcIj48L3NwYW4+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGFiZWxcIj4ke2xhYmVsfTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN0b3BncmFwXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYXJlbnQtY2hpbGRzXCI+JHtjaGlsZHN9PC9kaXY+XG4gICAgPC9kaXY+YFxufVxuXG4vKipcbiogUmVuZGVyIGJvb2ttYXJrIGZyb20gYm9va21hcmsgbm9kZVxuKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlXG4qIEBwYXJhbSAge0Jvb2xlYW59IFtjbGVhcj1mYWxzZV0gY2xlYW4gYm9va21hcmsgYmFyIGJlZm9yZSByZW5kZXJcbiovXG5ib29rbWFyay5yZW5kZXIgPSAobm9kZSwgY2xlYXI9ZmFsc2UpID0+IHtcbiAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgYm9va21hcmsuYm9va21hcmtCYXJFbGVtZW50LmlubmVySFRNTCA9ICcnXG4gICAgfVxuXG4gICAgYm9va21hcmsuYm9va21hcmtCYXJFbGVtZW50LmlubmVySFRNTCArPSBib29rbWFyay5jcmVhdGVQYXJlbnQobm9kZSlcbn1cblxuLyoqXG4qIFRvZ2dsZU9wZW5QYXJlbnRcbiogQHBhcmFtICB7c3RyaW5nfSBwYXJlbnRJZFxuKi9cbmJvb2ttYXJrLnRvZ2dsZU9wZW5QYXJlbnQgPSAocGFyZW50SWQpID0+IHtcbiAgICAvLyBzZXQgY29uZmlnXG4gICAgY29uc3Qga2V5ID0gYGJvb2ttYXJrOnBhcmVudDoke3BhcmVudElkfWBcbiAgICBjb25zdCBvcGVuID0gc3RvcmFnZVtrZXldID09PSAnY2xvc2UnPyAnb3BlbicgOiAnY2xvc2UnXG4gICAgc3RvcmFnZVtrZXldID0gb3BlblxuICAgIFxuICAgIC8vIGNoYW5nZSBzdHlsZSBib29rbWFyayBwYXJlbnRcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYXJlbnQtaWQ9XCIke3BhcmVudElkfVwiXWApLnBhcmVudE5vZGUuY2xhc3NOYW1lID0gYHBhcmVudCAke29wZW59YFxufVxuXG5ib29rbWFyay5mZXRjaCA9ICgpID0+IHtcbiAgICBjaHJvbWUudG9wU2l0ZXMuZ2V0KCh0b3BzKSA9PiB7XG4gICAgICAgIGJvb2ttYXJrLnJlbmRlcih7IGNoaWxkcmVuOiB0b3BzLCB0aXRsZTogJ01vc3QgdmlzaXRlZCcgfSwgdHJ1ZSlcbiAgICAgICAgXG4gICAgICAgIGNocm9tZS5ib29rbWFya3MuZ2V0VHJlZSgoYm9va21hcmtzKSA9PiB7XG4gICAgICAgICAgICBib29rbWFyay5yZW5kZXIoYm9va21hcmtzWzBdLmNoaWxkcmVuWzBdKVxuICAgICAgICB9KVxuICAgIH0pXG59XG5cbmJvb2ttYXJrLmJvb2ttYXJrQmFyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICh7IHRhcmdldCB9KSA9PiB7XG4gICAgY29uc3QgaWQgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXBhcmVudC1pZCcpIHx8IHRhcmdldC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXJlbnQtaWQnKVxuXG4gICAgaWYgKGlkKSB7XG4gICAgICAgIGJvb2ttYXJrLnRvZ2dsZU9wZW5QYXJlbnQoaWQpXG4gICAgfVxufSlcblxuY2hyb21lLmJvb2ttYXJrcy5vbkNyZWF0ZWQuYWRkTGlzdGVuZXIoYm9va21hcmsuZmV0Y2gpXG5jaHJvbWUuYm9va21hcmtzLm9uUmVtb3ZlZC5hZGRMaXN0ZW5lcihib29rbWFyay5mZXRjaClcbmNocm9tZS5ib29rbWFya3Mub25DaGFuZ2VkLmFkZExpc3RlbmVyKGJvb2ttYXJrLmZldGNoKVxuY2hyb21lLmJvb2ttYXJrcy5vbk1vdmVkLmFkZExpc3RlbmVyKGJvb2ttYXJrLmZldGNoKVxuXG5ib29rbWFyay5mZXRjaCgpXG5cbmV4cG9ydCBkZWZhdWx0IGJvb2ttYXJrIiwiaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcidcbmltcG9ydCBldmVudCBmcm9tICcuL2V2ZW50J1xuXG5jb25zdCBlbWl0dGVyID0ge31cbmNvbnN0IG1vdW50ZWQgPSB7fVxuXG5lbWl0dGVyLm1vdW50ZWQgPSBtb3VudGVkXG5cbi8qKlxuICogRW1pdHRlciBnZW5lcmF0b3JcbiAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IEVtaXR0ZXIgbmFtZVxuICogQHBhcmFtIGhhbmRsZSB7ZnVuY3Rpb259IENhbGwgb25lIHRpbWUgZm9yIHNldHVwIGVtaXR0ZXJcbiAqL1xuZW1pdHRlci5nZW4gPSAobmFtZSwgaGFuZGxlKSA9PiB7XG4gICAgaWYgKGVtaXR0ZXJbbmFtZV0gfHwgIS9eW2EtekEtWl1bYS16QS1aMC05X117MCw2M30kLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIuZXJyb3IoYGVtaXR0ZXI6IG5hbWUgXCIke25hbWV9XCIgZXhpc3RlZCBvciBpbnZhbGlkYClcbiAgICB9XG5cbiAgICBlbWl0dGVyW25hbWVdID0gKCkgPT4ge1xuICAgICAgICBpZiAobW91bnRlZFtuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci5lcnJvcihgZW1pdHRlcjogZHVwbGljYXRlIG1vdW50IGVtaXR0ZXIgJHtuYW1lfWApXG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGUoKVxuXG4gICAgICAgIG1vdW50ZWRbbmFtZV0gPSB0cnVlXG4gICAgfVxufVxuXG4vLyBEZWZpbmUgZW1pdHRlclxuXG5lbWl0dGVyLmdlbignY2xpY2snLCAoKSA9PiB7XG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tSKHRhcmdldCwgZG9tRXZlbnQsIHVwID0gMCkge1xuICAgICAgICBpZiAodXAgPiA1IHx8ICF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xpY2tFbWl0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnY2xpY2stZW1pdCcpXG5cbiAgICAgICAgaWYgKCFjbGlja0VtaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDbGlja1IodGFyZ2V0LnBhcmVudEVsZW1lbnQsIGRvbUV2ZW50LCB1cCArIDEpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuYW1lID0gY2xpY2tFbWl0LnNwbGl0KCc6JylbMF1cblxuICAgICAgICBsZXQgcGF5bG9hZCA9IGNsaWNrRW1pdC5zcGxpdCgnOicpLnNsaWNlKDEpLmpvaW4oJzonKVxuXG4gICAgICAgIC8vIGhhbmRsZSBvYmplY3QgcGF5bG9hZFxuICAgICAgICBpZiAocGF5bG9hZFswXSA9PT0gJz8nKSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkT2JqZWN0ID0ge31cbiAgICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgICAgICAuc3BsaXQoJyYnKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChxKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHEuc3BsaXQoJz0nKVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZE9iamVjdFtrZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWRPYmplY3RcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50Lm5leHQobmFtZSwgcGF5bG9hZCwgeyB0YXJnZXQsIGRvbUV2ZW50IH0pXG4gICAgfVxuXG4gICAgd2luZG93LmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZG9tRXZlbnQpID0+IHtcbiAgICAgICAgaGFuZGxlQ2xpY2tSKGRvbUV2ZW50LnRhcmdldCwgZG9tRXZlbnQpXG4gICAgfSlcblxuICAgIGxvZ2dlci5pbmZvKCdlbWl0ZXI6IGNsaWNrIGVtaXRlciBtb3VudGVkJylcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IGVtaXR0ZXJcbiIsImltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInXG5cbmNvbnN0IGV2ZW50ID0ge1xuICAgIHBvb2w6IHt9LFxufVxuXG5ldmVudC5lbWl0ID0gKG5hbWUsIC4uLnBheWxvYWQpID0+IHtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBldmVudC5wb29sW25hbWVdIHx8IFtdKSB7XG4gICAgICAgIGhhbmRsZSguLi5wYXlsb2FkKVxuICAgIH1cbn1cblxuZXZlbnQub24gPSAobmFtZSwgaGFuZGxlKSA9PiB7XG4gICAgZXZlbnQucG9vbFtuYW1lXT8ucHVzaChoYW5kbGUpIHx8IChldmVudC5wb29sW25hbWVdID0gW2hhbmRsZV0pXG59XG5cbmV2ZW50Lm5leHQgPSAobmFtZSwgLi4ucGF5bG9hZCkgPT4ge1xuICAgIHNldFRpbWVvdXQoZXZlbnQuZW1pdCwgMCwgbmFtZSwgLi4ucGF5bG9hZClcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXZlbnRcbiIsImNvbnN0IExFVkVMID0gW1xuICAgICdkZWJ1ZycsXG4gICAgJ2luZm8nLFxuICAgICd3YXJuaW5nJyxcbiAgICAnZXJyb3InLFxuXVxuXG5jb25zdCBsb2dnZXIgPSB7XG4gICAgbG9nX2xldmVsOiAnZGVidWcnLFxuXG4gICAgZ2V0IGRlYnVnKCkge1xuICAgICAgICBpZiAoTEVWRUwuaW5kZXhPZih0aGlzLmxvZ19sZXZlbC50b0xvd2VyQ2FzZSgpKSA8PSBMRVZFTC5pbmRleE9mKCdkZWJ1ZycpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS5kZWJ1Zy5iaW5kKHdpbmRvdy5jb25zb2xlLCAnJWNERUJVRzonLCAnY29sb3I6ICM2Yzc1N2QnKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkXG4gICAgfSxcblxuICAgIGdldCBpbmZvKCkge1xuICAgICAgICBpZiAoTEVWRUwuaW5kZXhPZih0aGlzLmxvZ19sZXZlbC50b0xvd2VyQ2FzZSgpKSA8PSBMRVZFTC5pbmRleE9mKCdpbmZvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmluZm8uYmluZCh3aW5kb3cuY29uc29sZSwgJyVjSU5GTzonLCAnY29sb3I6ICMxN2EyYjgnKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkXG4gICAgfSxcblxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICBpZiAoTEVWRUwuaW5kZXhPZih0aGlzLmxvZ19sZXZlbC50b0xvd2VyQ2FzZSgpKSA8PSBMRVZFTC5pbmRleE9mKCd3YXJuaW5nJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4uYmluZCh3aW5kb3cuY29uc29sZSwgJyVjV0FSTklORzonLCAnY29sb3I6ICNmZmMxMDcnKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkXG4gICAgfSxcblxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgaWYgKExFVkVMLmluZGV4T2YodGhpcy5sb2dfbGV2ZWwudG9Mb3dlckNhc2UoKSkgPD0gTEVWRUwuaW5kZXhPZignZXJyb3InKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IuYmluZCh3aW5kb3cuZXJyb3IsICclY0VSUk9SOicsICdjb2xvcjogI2RjMzU0NScpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiAoKSA9PiB1bmRlZmluZWRcbiAgICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBsb2dnZXJcbiIsImltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInXG5cbmNvbnN0IHN0b3JhZ2UgPSB7fVxuY29uc3QgaGFuZGxlciA9IHt9XG5cbmhhbmRsZXIuZ2V0ID0gKHRhcmdldCwga2V5KSA9PiB7XG4gICAgaWYgKGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cblxuICAgIGNvbnN0IHJhdyA9IGxvY2FsU3RvcmFnZVtrZXldXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJhdyAmJiBKU09OLnBhcnNlKHJhdylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLmVycm9yKCdzdG9yYWdlOiBwYXJzZSBqc29uIGZhaWwsIGtleTogJywga2V5KVxuICAgIH1cbn1cblxuaGFuZGxlci5zZXQgPSAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiB7ICAgIFxuICAgIGxvY2FsU3RvcmFnZVtrZXldID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBQcm94eShzdG9yYWdlLCBoYW5kbGVyKVxuIiwiaW1wb3J0IHN0b3JhZ2UgZnJvbSAnLi9jb3JlL3N0b3JhZ2UnXG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vY29yZS9sb2dnZXInXG5pbXBvcnQgZXZlbnQgZnJvbSAnLi9jb3JlL2V2ZW50J1xuXG5jb25zdCBub3RlciA9IHtcbiAgICBub3RlczogW10sXG4gICAgTUFYX05PVEVfTlVNQkVSOiAzMDAsXG4gICAgTUFYX05PVEVfQ0hBUkFDVEVSOiAzMDAwLFxufVxuXG5ub3Rlci5mZXRjaCA9ICgpID0+IHtcbiAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoJ25vdGVzJykudGhlbigoeyBub3RlcyB9KSA9PiB7XG4gICAgICAgIG5vdGVyLm5vdGVzID0gbm90ZXNcbiAgICAgICAgbm90ZXIucmVuZGVyKClcbiAgICB9KVxufVxuXG5ub3Rlci5zYXZlID0gKCkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1Zygnbm90ZXIgc2F2ZTonLCBub3Rlci5ub3RlcylcbiAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoeyBub3Rlczogbm90ZXIubm90ZXMgfSlcbn1cblxubm90ZXIuY3JlYXRlT2JqZWN0ID0gKG5vdGUpID0+IHtcbiAgICBjb25zdCBkZWZhdWx0RGF0YSA9IHtcbiAgICAgICAgbXNnOiAnJyxcbiAgICAgICAgeDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhvbGRlci53X3cgLSA1MDApKSxcbiAgICAgICAgeTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhvbGRlci53X2ggLSAyNTApKSxcbiAgICAgICAgdzogMzAwLFxuICAgICAgICBoOiAxMDAsXG4gICAgICAgIHdvcmtzcGFjZTogc3RvcmFnZS53b3Jrc3BhY2UsXG4gICAgICAgIHR5cGU6ICdub21hbCcsXG4gICAgICAgIHN0YXR1czogJ2RlZmF1bHQnLFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0RGF0YSwgbm90ZSlcbn1cblxubm90ZXIuY3JlYXRlRWxlbWVudCA9IChub3RlKSA9PiB7XG4gICAgY29uc3QgeyBpZCwgbXNnLCB4LCB5LCB3LCBoLCB0eXBlLCBzdGF0dXMgfSA9IG5vdGVcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnaWQnLCBgbm90ZWlkXyR7aWR9YClcbiAgICBkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsICdub3RlJylcbiAgICBkb20uc2V0QXR0cmlidXRlKCdzdHlsZScsIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgKVxuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ25vdGUtc3RhdHVzJywgc3RhdHVzIHx8ICdkZWZhdWx0JylcblxuICAgIGRvbS5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cImJveFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibm90ZS1jb250cm9sc1wiIG1vdmUtbm90ZWlkPVwiJHtpZH1cIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJub3RlLXJlbW92ZVwiIHJlbW92ZS1ub3RlaWQ9XCIke2lkfVwiPiZ0aW1lczs8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyYWluLWJvd1wiPlxuICAgICAgICAgICAgPGRpdiBtYXJrPVwiJHtpZH06cHJpbWFyeVwiPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBtYXJrPVwiJHtpZH06c3VjY2Vzc1wiPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBtYXJrPVwiJHtpZH06ZGFuZ2VyXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICAgICAgICBhdXRvY29ycmVjdD1cIm9mZlwiXG4gICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZT1cIm9mZlwiXG4gICAgICAgICAgICBzcGVsbGNoZWNrPVwiZmFsc2VcIlxuICAgICAgICAgICAgZWRpdG9yLW5vdGVpZD1cIiR7aWR9XCJcbiAgICAgICAgICAgIHN0eWxlPVwid2lkdGg6JHt3fXB4O2hlaWdodDoke2gtMjB9cHg7XCJcbiAgICAgICAgPiR7bXNnfTwvdGV4dGFyZWE+XG4gICAgPC9kaXY+YFxuXG4gICAgcmV0dXJuIGRvbVxufVxuXG5ub3Rlci5hZGQgPSAobm90ZSkgPT4ge1xuICAgIGlmIChub3Rlci5ub3Rlcy5sZW5ndGggPiBub3Rlci5NQVhfTk9URV9OVU1CRVIpIHtcbiAgICAgICAgcmV0dXJuIGFsZXJ0KCdUaGUgbWF4aW11bSBudW1iZXIgb2Ygbm90ZXMgaGFzIGJlZW4gcmVhY2hlZCcpXG4gICAgfVxuXG4gICAgLy8gTmV3IG5vdGUgZG9uJ3QgaGF2ZSBhIGlkLCBwdXNoIGl0IHRvIG5vdGVyLm5vdGVzXG4gICAgaWYgKG5vdGUuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub3RlLmlkID0gRGF0ZS5ub3coKS50b1N0cmluZygpXG4gICAgICAgIG5vdGVyLm5vdGVzLnB1c2gobm90ZSlcbiAgICB9XG4gICAgXG4gICAgbG9nZ2VyLmRlYnVnKGBhZGQgbm90ZSAke25vdGUuaWR9ID0gJHtub3RlLm1zZ31gKVxuICAgIFxuICAgIC8vIFJlbmRlciBodG1sXG4gICAgd2luZG93Lm5vdGVfYm94LmFwcGVuZENoaWxkKG5vdGVyLmNyZWF0ZUVsZW1lbnQobm90ZSkpXG59XG5cbm5vdGVyLnJlbmRlciA9IChjbGVhcj10cnVlLCB3b3Jrc3BhY2U9K3N0b3JhZ2Uud29ya3NwYWNlIHx8IDApID0+IHtcbiAgICAvLyBDbGVhciBiZWZvcmUgcmVuZGVyXG4gICAgaWYgKGNsZWFyKSB7XG4gICAgICAgIG5vdGVfYm94LmlubmVySFRNTCA9ICcnXG4gICAgfVxuICAgIFxuICAgIC8vIExvb3AgYWRkaW5nXG4gICAgbm90ZXIubm90ZXMuZmlsdGVyKG5vdGUgPT4ge1xuICAgICAgICByZXR1cm4gd29ya3NwYWNlID09PSArbm90ZS53b3Jrc3BhY2UgXG4gICAgfSkuZm9yRWFjaChub3RlID0+IHtcbiAgICAgICAgbm90ZXIuYWRkKG5vdGUpXG4gICAgfSlcbn1cblxubm90ZXIuY2hlY2tBbmRSZXBsYWNlQ29kZSA9ICh0YXJnZXQpID0+IHtcbiAgICBjb25zdCBzdHJpbmcgPSB0YXJnZXQudmFsdWVcbiAgICBcbiAgICBob2xkZXIuY29kZV90YWJsZXMuZm9yRWFjaChjb2RlID0+IHtcbiAgICAgICAgY29uc3QgY3JlZ2V4ID0gbmV3IFJlZ0V4cChjb2RlLmNvZGUpXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKGNyZWdleClcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXMgPSByZXN1bHQuc2xpY2UoMSlcblxuICAgICAgICAgICAgY29uc3Qgb2xkU2VsZWN0aW9uU3RhcnQgPSB0YXJnZXQuc2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0LnZhbHVlXG5cbiAgICAgICAgICAgIGxldCBjb2RlVmFsdWUgPSBjb2RlLnZhbHVlXG5cbiAgICAgICAgICAgIGRhdGFzLmZvckVhY2goKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb2RlVmFsdWUgPSBjb2RlVmFsdWUucmVwbGFjZSgnJCcsIGRhdGEpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBzdHJpbmcucmVwbGFjZShjcmVnZXgsIGNvZGVWYWx1ZSlcblxuICAgICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uU3RhcnQgPSBvbGRTZWxlY3Rpb25TdGFydCArIHRhcmdldC52YWx1ZS5sZW5ndGggLSBvbGRWYWx1ZS5sZW5ndGhcbiAgICAgICAgICAgIHRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZShuZXdTZWxlY3Rpb25TdGFydCwgbmV3U2VsZWN0aW9uU3RhcnQpXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5ub3Rlci5yZW1vdmUgPSAoaWQpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IG5vdGVyLm5vdGVzLmZpbmRJbmRleCgobm90ZSkgPT4gbm90ZS5pZCA9PSBpZClcbiAgICBub3Rlci5ub3Rlcy5zcGxpY2UoaW5kZXgsIDEpXG5cbiAgICAvLyBSZW1vdmUgZG9tXG4gICAgY29uc3QgZG9tID0gd2luZG93W2Bub3RlaWRfJHtpZH1gXVxuICAgIGRvbS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGRvbSlcblxuICAgIG5vdGVyLnNhdmUoKVxufVxuXG5ub3Rlci5tYXJrID0gKGlkLCBzdGF0dXMpID0+IHtcbiAgICBjb25zdCBub3RlID0gbm90ZXIubm90ZXMuZmluZChuID0+IG4uaWQgPT0gaWQpXG5cbiAgICBpZiAobm90ZS5zdGF0dXMgPT09IHN0YXR1cykge1xuICAgICAgICBub3RlLnN0YXR1cyA9ICdkZWZhdWx0J1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vdGUuc3RhdHVzID0gc3RhdHVzXG4gICAgfVxuXG4gICAgd2luZG93W2Bub3RlaWRfJHtpZH1gXS5zZXRBdHRyaWJ1dGUoJ25vdGUtc3RhdHVzJywgbm90ZS5zdGF0dXMpXG4gICAgbm90ZXIuc2F2ZSgpXG59XG5cbi8vIE5PVEVSIEJFSEFWSU9SXG57XG4gICAgbGV0IHJlc2l6ZUlkID0gZmFsc2VcbiAgICBsZXQgbW92ZUlkID0gZmFsc2VcbiAgICBsZXQgZml4WCA9IDBcbiAgICBsZXQgZml4WSA9IDBcblxuICAgIC8vIExpc3RlbiBjbGljayBub3RlXG4gICAgd2luZG93Lm5vdGVfYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gZXZlbnRcblxuICAgICAgICBjb25zdCByZW1vdmVJZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JlbW92ZS1ub3RlaWQnKVxuICAgICAgICBjb25zdCBtYXJrID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbWFyaycpXG4gICAgICAgIFxuICAgICAgICBpZiAocmVtb3ZlSWQpIHtcbiAgICAgICAgICAgIG5vdGVyLnJlbW92ZShyZW1vdmVJZClcbiAgICAgICAgfSBlbHNlIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBjb25zdCBbIG5vdGVJZCwgc3RhdHVzIF0gPSBtYXJrLnNwbGl0KCc6JylcbiAgICAgICAgICAgIG5vdGVyLm1hcmsobm90ZUlkLCBzdGF0dXMpXG4gICAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIC8vIEhhbmRsZSBtb3ZlXG4gICAgd2luZG93Lm5vdGVfYm94LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGV2ZW50ID0+IHtcbiAgICAgICAgXG4gICAgICAgIC8vIFByZXZlbnQgcmlnaHQgbW91c2VcbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudFxuICAgICAgICBcbiAgICAgICAgLy8gRGV0ZWN0IHJlc2l6ZVxuICAgICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZSgnZWRpdG9yLW5vdGVpZCcpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjeCA9IGV2ZW50LmNsaWVudFhcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gZXZlbnQuY2xpZW50WVxuICAgICAgICAgICAgY29uc3Qgbm90ZUlkID0gK3RhcmdldC5nZXRBdHRyaWJ1dGUoJ2VkaXRvci1ub3RlaWQnKVxuICAgICAgICAgICAgY29uc3Qgbm90ZUluZGV4ID0gbm90ZXIubm90ZXMuZmluZEluZGV4KChub3RlKSA9PiBub3RlLmlkID09IG5vdGVJZClcbiAgICAgICAgICAgIGNvbnN0IG5vdGUgPSBub3Rlci5ub3Rlc1tub3RlSW5kZXhdXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERldGVjdCBtb3VzZSBkb3duIG92ZXIgcmVzaXplIGJ0blxuICAgICAgICAgICAgaWYgKG5vdGUueCArIG5vdGUudyAtIGN4IDwgMTUgJiYgbm90ZS55ICsgbm90ZS5oIC0gY3kgPCAxNSkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZUlkID0gbm90ZUlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb3ZlLW5vdGVpZCcpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBub3RlSWQgPSArdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW92ZS1ub3RlaWQnKVxuICAgICAgICAgICAgY29uc3Qgbm90ZUluZGV4ID0gbm90ZXIubm90ZXMuZmluZEluZGV4KChub3RlKSA9PiBub3RlLmlkID09IG5vdGVJZClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRml4IHBvc2l0aW9uIG1vdXNlIHZzIG5vdGVcbiAgICAgICAgICAgIGZpeFggPSBldmVudC5jbGllbnRYIC0gbm90ZXIubm90ZXNbbm90ZUluZGV4XS54XG4gICAgICAgICAgICBmaXhZID0gZXZlbnQuY2xpZW50WSAtIG5vdGVyLm5vdGVzW25vdGVJbmRleF0ueVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTdGFydCBtb3ZlIGhhbmRsZVxuICAgICAgICAgICAgbW92ZUlkID0gbm90ZUlkXG4gICAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChtb3ZlSWQgPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgbGV0IHggPSBldmVudC5jbGllbnRYIC0gZml4WFxuICAgICAgICBsZXQgeSA9IGV2ZW50LmNsaWVudFkgLSBmaXhZXG5cbiAgICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgICAgICB5ID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPiBob2xkZXIud19oIC0gMjApIHtcbiAgICAgICAgICAgIHkgPSBob2xkZXIud19oIC0gMjBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgeCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4ID4gaG9sZGVyLndfdyAtIDIwKSB7XG4gICAgICAgICAgICB4ID0gaG9sZGVyLndfdyAtIDIwXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh3aW5kb3dbYG5vdGVpZF8ke21vdmVJZH1gXSkgd2luZG93W2Bub3RlaWRfJHttb3ZlSWR9YF0uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgXG4gICAgfSlcbiAgICBcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKG1vdmVJZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYIC0gZml4WFxuICAgICAgICAgICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFkgLSBmaXhZXG4gICAgICAgICAgICBjb25zdCBub3RlSW5kZXggPSBub3Rlci5ub3Rlcy5maW5kSW5kZXgoKG5vdGUpID0+IG5vdGUuaWQgPT0gbW92ZUlkKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobm90ZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG5vdGVyLm5vdGVzW25vdGVJbmRleF0ueCA9IHhcbiAgICAgICAgICAgICAgICBub3Rlci5ub3Rlc1tub3RlSW5kZXhdLnkgPSB5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEVuZCBtb3ZlIGhhbmRsZVxuICAgICAgICAgICAgbW92ZUlkID0gZmFsc2VcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2F2ZSB3aGVuIGRvbmUgbW92ZSBhIG5vdGVcbiAgICAgICAgICAgIG5vdGVyLnNhdmUoKVxuICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSBpZiAocmVzaXplSWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gZXZlbnRcbiAgICAgICAgICAgIGNvbnN0IG5vdGVJbmRleCA9IG5vdGVyLm5vdGVzLmZpbmRJbmRleCgobm90ZSkgPT4gbm90ZS5pZCA9PSByZXNpemVJZClcbiAgICAgICAgICAgIGNvbnN0IHcgPSB3aW5kb3dbJ25vdGVpZF8nICsgcmVzaXplSWRdLm9mZnNldFdpZHRoXG4gICAgICAgICAgICBjb25zdCBoID0gd2luZG93Wydub3RlaWRfJyArIHJlc2l6ZUlkXS5vZmZzZXRIZWlnaHRcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG5vdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBub3Rlci5ub3Rlc1tub3RlSW5kZXhdLncgPSB3XG4gICAgICAgICAgICAgICAgbm90ZXIubm90ZXNbbm90ZUluZGV4XS5oID0gaFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFbmQgcmVzaXplIGhhbmRsZVxuICAgICAgICAgICAgcmVzaXplSWQgPSBmYWxzZVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTYXZlIHdoZW4gZG9uZSBtb3ZlIGEgbm90ZVxuICAgICAgICAgICAgbm90ZXIuc2F2ZSgpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgIH0pXG4gICAgXG4gICAgLy8gSGFuZGxlIGVkaXQgbm90ZXNcbiAgICAvLyBLZXl1cCBvbmx5IHdoZW4gZm9jdXMgdGV4dGFyZWFcbiAgICB3aW5kb3cubm90ZV9ib3guYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoeyB0YXJnZXQsIGtleSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZWRpdG9yLW5vdGVpZCcpXG4gICAgICAgIFxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbm90ZXIubm90ZXMuZmluZEluZGV4KChub3RlKSA9PiBub3RlLmlkID09IGlkKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBIYW5kbGUgbm90ZSBjb2RlXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICBub3Rlci5jaGVja0FuZFJlcGxhY2VDb2RlKHRhcmdldClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgbWF4IG5vdGUgY2hhcmFjdGVyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LnZhbHVlLmxlbmd0aCA+IG5vdGVyLk1BWF9OT1RFX0NIQVJBQ1RFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGVydCgnVGhlIG1heGltdW0gY2hhcmFjdGVyIGhhcyBiZWVuIHJlYWNoZWQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBub3Rlci5ub3Rlc1tpbmRleF0ubXNnID0gdGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICBub3Rlci5zYXZlKClcbiAgICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgLy8gTGlzdGVuIGFkZCBub3RlXG4gICAgZXZlbnQub24oJ25vdGVyX2FkZCcsICgpID0+IHtcbiAgICAgICAgbm90ZXIuYWRkKG5vdGVyLmNyZWF0ZU9iamVjdCgpKVxuICAgICAgICBub3Rlci5zYXZlKClcbiAgICB9KVxuICAgIFxuICAgIC8vIExpc3RlbiBzd2l0Y2ggd29ya3NwYWNlXG4gICAgZXZlbnQub24oJ25vdGVyX3N3aXRjaF93b3Jrc3BhY2UnLCAoKSA9PiB7XG4gICAgICAgIGxldCB3b3Jrc3BhY2UgPSArc3RvcmFnZS53b3Jrc3BhY2UgfHwgMFxuXG4gICAgICAgIGlmICh3b3Jrc3BhY2UgPiAyKSB7XG4gICAgICAgICAgICB3b3Jrc3BhY2UgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3Jrc3BhY2UrK1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB3aW5kb3cuYnRuX3N3aXRjaF93b3Jrc3BhY2UuaW5uZXJIVE1MID0gd29ya3NwYWNlXG4gICAgICAgIHN0b3JhZ2Uud29ya3NwYWNlID0gd29ya3NwYWNlXG5cbiAgICAgICAgbm90ZXIuc2F2ZSgpXG4gICAgICAgIG5vdGVyLnJlbmRlcigpXG4gICAgfSlcblxuICAgIC8vIExpc3RlbiBzeW5jIG5vdGVzIGNyb3NzIHRhYlxuICAgIGNocm9tZS5zdG9yYWdlLm9uQ2hhbmdlZC5hZGRMaXN0ZW5lcigoY2hhbmdlcywgbmFtZXNwYWNlKSA9PiB7XG4gICAgICAgIGlmIChuYW1lc3BhY2UgPT09ICdsb2NhbCcgJiYgY2hhbmdlcy5ub3RlcyAmJiBkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIG5vdGVyLm5vdGVzID0gY2hhbmdlcy5ub3Rlcy5uZXdWYWx1ZVxuICAgICAgICAgICAgbm90ZXIucmVuZGVyKClcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbm5vdGVyLmZldGNoKClcblxuZXhwb3J0IGRlZmF1bHQgbm90ZXIiLCJBcnJheS5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlZHVjZSgoYWNjLCBlKSA9PiBhY2MgKyBlKVxufVxuXG5IVE1MRWxlbWVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKCBgXiR7Y2xhc3NOYW1lfSR8XiR7Y2xhc3NOYW1lfSB8ICR7Y2xhc3NOYW1lfSR8ICR7Y2xhc3NOYW1lfSggKWAsICdnJylcbiAgICBpZiAoIXJlZ2V4LnRlc3QodGhpcy5jbGFzc05hbWUpKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gYCR7dGhpcy5jbGFzc05hbWV9ICR7Y2xhc3NOYW1lfWAudHJpbSgpXG4gICAgfVxufVxuXG5IVE1MRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKCBgXiR7Y2xhc3NOYW1lfSR8XiR7Y2xhc3NOYW1lfSB8ICR7Y2xhc3NOYW1lfSR8ICR7Y2xhc3NOYW1lfSggKWAsICdnJylcbiAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UocmVnZXgsICckMScpLnRyaW0oKVxufVxuXG5IVE1MQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXNdXG59XG5cbk5vZGVMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbLi4udGhpc11cbn0iLCJpbXBvcnQgc3RvcmFnZSBmcm9tICcuL2NvcmUvc3RvcmFnZSdcbmltcG9ydCBldmVudCBmcm9tICcuL2NvcmUvZXZlbnQnXG5pbXBvcnQgbm90ZXIgZnJvbSAnLi9ub3RlcidcblxuY29uc3QgUExBQ0VIT0xERVJfSU1HX1NSQyA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQVlBQUFBZkZjU0pBQUFBRFVsRVFWUVlWMk00YytiTWZ3QUlNQU5rcTNjWTJ3QUFBQUJKUlU1RXJrSmdnZz09J1xuY29uc3QgRVhURU5EX1dBTExQQVBFUl9TSVpFID0gNVxuXG5jb25zdCBzZXR0aW5nID0ge1xuICAgIGlzT3BlbjogZmFsc2UsXG4gICAgYmxvYl9idWZmZXJfdXJsOiBudWxsLFxufVxuXG5zZXR0aW5nLnJlbmRlciA9ICgpID0+IHtcbiAgICAvLyByZW5kZXIgd2FsbHBhcGVyXG4gICAgY29uc3Qgd2FsVyA9IHdpbmRvdy5zZXR0aW5nc193YWxscGFwZXJzLmNsaWVudFdpZHRoIC8gNiAtIDEwXG4gICAgY29uc3Qgd2FsSCA9IHdhbFcgKiBob2xkZXIud19oIC8gaG9sZGVyLndfd1xuXG4gICAgaWYgKHN0b3JhZ2Uud2FsbHBhcGVycy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIGFkZCBwbGFjZWhvbGRlciBmb3IgZWRpdFxuICAgICAgICBzdG9yYWdlLndhbGxwYXBlcnMgPSBbXG4gICAgICAgICAgICAuLi5zdG9yYWdlLndhbGxwYXBlcnMsXG4gICAgICAgICAgICAuLi5uZXcgQXJyYXkoRVhURU5EX1dBTExQQVBFUl9TSVpFKS5maWxsKHsgdXJsOiBQTEFDRUhPTERFUl9JTUdfU1JDIH0pLFxuICAgICAgICBdXG4gICAgfVxuXG4gICAgd2luZG93LnNldHRpbmdzX3dhbGxwYXBlcnMuaW5uZXJIVE1MID0gc3RvcmFnZS53YWxscGFwZXJzLm1hcCgod2FsbCwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9ICdzZXR0aW5ncy13YWxsLXByZSdcbiAgICAgICAgaWYgKHdhbGwuYWN0aXZlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgKz0gJyBhY3RpdmUnXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5uZXIgPSAnJ1xuXG4gICAgICAgIGlmIChpbmRleCA+PSAzKSB7XG4gICAgICAgICAgICBpbm5lciArPSBgPHNwYW4gY2xpY2stZW1pdD1cInNldHRpbmdfd2FsbHBhcGVyX2VkaXQ6JHtpbmRleH1cIj5FRElUPC9zcGFuPmBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgXG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwiJHtjbGFzc05hbWV9XCJcbiAgICAgICAgICAgIHN0eWxlPVwid2lkdGg6ICR7d2FsV31weDsgaGVpZ2h0OiAke3dhbEh9cHg7IGJhY2tncm91bmQtaW1hZ2U6IHVybCgke3dhbGwudXJsfSlcIlxuICAgICAgICAgICAgY2xpY2stZW1pdD1cInNldHRpbmdfd2FsbHBhcGVyX3RvZ2dsZToke2luZGV4fVwiXG4gICAgICAgID4ke2lubmVyfTwvZGl2PlxuICAgICAgICBgXG4gICAgfSkuam9pbignJylcblxuICAgIC8vIHJlbmRlciBjb25maWdcbiAgICB3aW5kb3cuc2V0dGluZ19jb25maWdfaW5wdXQudmFsdWUgPSBKU09OLnN0cmluZ2lmeShjb25maWcpXG4gICAgICAgIC5yZXBsYWNlKC8sL2csICcsXFxuJylcbiAgICAgICAgLnJlcGxhY2UoJ3snLCAne1xcbicpXG4gICAgICAgIC5yZXBsYWNlKCd9JywgJ1xcbn0nKVxuXG4gICAgLy8gcmVuZGVyIGNvZGUgdGFibGVcbiAgICB3aW5kb3cuc2V0dGluZ19jb2RlX3RhYmxlX2lucHV0LnZhbHVlID0gaG9sZGVyLmNvZGVfdGFibGVzLm1hcChjb2RlVGFibGUgPT4ge1xuICAgICAgICByZXR1cm4gYCR7Y29kZVRhYmxlLmNvZGUuc2xpY2UoMCwgLTIpfSAtPiAke2NvZGVUYWJsZS52YWx1ZX1gXG4gICAgfSkuam9pbignXFxuJylcbn1cblxuc2V0dGluZy50b2dnbGUgPSBzdGF0ZSA9PiB7XG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhdGUgPSAhc2V0dGluZy5pc09wZW5cbiAgICB9XG5cbiAgICBzZXR0aW5nLmlzT3BlbiA9IHN0YXRlXG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgd2luZG93LnNldHRpbmdfYm94LnJlbW92ZUNsYXNzKCdoaWRkZW4nKVxuICAgICAgICBzZXR0aW5nLnJlbmRlcigpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnNldHRpbmdfYm94LmFkZENsYXNzKCdoaWRkZW4nKVxuICAgIH1cbn1cblxuZXZlbnQub24oJ3NldHRpbmdfY2xvc2UnLCAoKSA9PiB7XG4gICAgc2V0dGluZy50b2dnbGUoZmFsc2UpXG59KVxuXG5ldmVudC5vbignc2V0dGluZ19vcGVuJywgKCkgPT4ge1xuICAgIHNldHRpbmcudG9nZ2xlKHRydWUpXG59KVxuXG5ldmVudC5vbignc2V0dGluZ19iYWNrdXAnLCAoKSA9PiB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuXG4gICAgY29uc3QgZGF0YSA9IHt9XG4gICAgZGF0YS5ub3RlcyA9IG5vdGVyLm5vdGVzXG4gICAgZGF0YS5zdG9yYWdlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsb2NhbFN0b3JhZ2UpKVxuXG4gICAgY29uc3QganNvblN0cmluZ0RhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKVxuXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtqc29uU3RyaW5nRGF0YV0sIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pXG5cbiAgICAvLyB0cnkgY29sbGVjdCBidWZmZXIgbWVtb3J5XG4gICAgaWYgKHNldHRpbmcuYmxvYl9idWZmZXJfdXJsICE9PSBudWxsKSB7XG4gICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHNldHRpbmcuYmxvYl9idWZmZXJfdXJsKVxuICAgIH1cblxuICAgIHNldHRpbmcuYmxvYl9idWZmZXJfdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcblxuICAgIGNvbnN0IGFuYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgIGFuYy5ocmVmID0gc2V0dGluZy5ibG9iX2J1ZmZlcl91cmxcbiAgICBhbmMuZG93bmxvYWQgPSAnc2Vpbi1iYWNrdXAtJyArIG5vdy50b0xvY2FsZURhdGVTdHJpbmcoKS5yZXBsYWNlKC9cXC8vZywgJy0nKSArICcuanNvbidcbiAgICBhbmMuY2xpY2soKVxufSlcblxuZXZlbnQub24oJ3NldHRpbmdfcmVzdG9yZScsICgpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICBpbnB1dC50eXBlID0gJ2ZpbGUnXG5cbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBpbnB1dC5maWxlc1swXVxuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBiYWNrdXBKc29uU3RyaW5nRGF0YSA9IHJlYWRlci5yZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IGJhY2t1cERhdGEgPSBKU09OLnBhcnNlKGJhY2t1cEpzb25TdHJpbmdEYXRhKVxuICAgICAgICAgICAgY29uc3QgeyBub3Rlcywgc3RvcmFnZSB9ID0gYmFja3VwRGF0YVxuXG4gICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKHsgcmVxdWVzdDogJ3Bvc3Rfbm90ZXMnLCBkYXRhOiBub3RlcyB9KVxuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdG9yYWdlKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZVtrXSA9IHN0b3JhZ2Vba11cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGFsZXJ0KCdSZXN0b3JlIGNvbXBsYXRlZCcpXG4gICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICB9KVxuXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpXG4gICAgfSwgeyBvbmNlOiB0cnVlIH0pXG5cbiAgICBpbnB1dC5jbGljaygpXG59KVxuXG5ldmVudC5vbignc2V0dGluZ19jb25maWdfc2F2ZScsICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBKU09OLnBhcnNlKHNldHRpbmdfY29uZmlnX2lucHV0LnZhbHVlKVxuICAgICAgICBzdG9yYWdlLmNvbmZpZyA9IGNvbmZpZ1xuICAgICAgICB3aW5kb3cuY29uZmlnID0gY29uZmlnXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGFsZXJ0KCdQYXJzZSBjb25maWcgZXJyb3InKVxuICAgIH1cbiAgICBhbGVydCgnU2F2ZSBjb25maWcgc3VjY2VzcycpXG59KVxuXG5ldmVudC5vbignc2V0dGluZ193YWxscGFwZXJfdG9nZ2xlJywgKGluZGV4LCB7IHRhcmdldCB9KSA9PiB7XG4gICAgaW5kZXggPSAraW5kZXhcblxuICAgIGNvbnN0IHdhbGxwYXBlcnMgPSBzdG9yYWdlLndhbGxwYXBlcnNcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHRhcmdldC5jbGFzc05hbWUuaW5kZXhPZignYWN0aXZlJykgIT09IC0xXG5cbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICB9XG5cbiAgICB3YWxscGFwZXJzW2luZGV4XS5hY3RpdmUgPSAhaXNBY3RpdmVcbiAgICBcbiAgICBzdG9yYWdlLndhbGxwYXBlcnMgPSB3YWxscGFwZXJzXG59KVxuXG5ldmVudC5vbignc2V0dGluZ193YWxscGFwZXJfZWRpdCcsIChpbmRleCwgeyB0YXJnZXQgfSkgPT4ge1xuICAgIGluZGV4ID0gK2luZGV4XG5cbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICBpbnB1dC50eXBlID0gJ2ZpbGUnXG4gICAgXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gaW5wdXQuZmlsZXNbMF1cbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuXG4gICAgICAgIC8vIGNoZWNrIGZpbGUgc2l6ZVxuICAgICAgICBpZiAoZmlsZS5zaXplID4gMTA0ODU3Nikge1xuICAgICAgICAgICAgcmV0dXJuIGFsZXJ0KCdJbWFnZSBtdXN0IGJlIGxlc3MgdGhhbiAxIG1lZ2FieXRlcycpXG4gICAgICAgIH1cblxuICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnVmZnlzID0gc3RvcmFnZS53YWxscGFwZXJzXG5cbiAgICAgICAgICAgIGJ1ZmZ5c1tpbmRleF0udXJsID0gcmVhZGVyLnJlc3VsdFxuICAgICAgICAgICAgc3RvcmFnZS53YWxscGFwZXJzID0gYnVmZnlzXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXQucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgaXRlbS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7cmVhZGVyLnJlc3VsdH0pYFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpXG4gICAgfSwgeyBvbmNlOiB0cnVlIH0pXG5cbiAgICBpbnB1dC5jbGljaygpXG59KVxuXG5ldmVudC5vbignc2V0dGluZ193YWxscGFwZXJfcmVzZXQnLCAoKSA9PiB7XG4gICAgc3RvcmFnZS53YWxscGFwZXJzID0gbnVsbFxuICAgIGxvY2F0aW9uLnJlbG9hZCgpXG59KVxuXG5cbmV4cG9ydCBkZWZhdWx0IHNldHRpbmciLCJpbXBvcnQgc3RvcmFnZSBmcm9tICcuL2NvcmUvc3RvcmFnZSdcblxubGV0IHdhbGxwYXBlcnMgPSBzdG9yYWdlLndhbGxwYXBlcnNcblxuaWYgKCF3YWxscGFwZXJzKSB7XG4gICAgd2FsbHBhcGVycyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdXJsOiBgaW1nL3cxLmpwZ2AsXG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVybDogYGltZy93Mi5qcGdgLFxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB1cmw6IGBpbWcvdzMuanBnYCxcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICBdXG5cbiAgICBzdG9yYWdlLndhbGxwYXBlcnMgPSB3YWxscGFwZXJzXG59XG5cbndhbGxwYXBlcnMgPSB3YWxscGFwZXJzLmZpbHRlcigodykgPT4gdy5hY3RpdmUpXG5cbmNvbnN0IHdhbGxGb3JTaG93ID0gd2FsbHBhcGVyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB3YWxscGFwZXJzLmxlbmd0aCldXG5cbmlmICh3YWxsRm9yU2hvdykge1xuICAgIHdpbmRvdy53YWxsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHt3YWxsRm9yU2hvdy51cmx9KWBcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cud2FsbF9naG9zdF9sZWZ0LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHt3YWxsRm9yU2hvdy51cmx9KWBcbiAgICAgICAgd2luZG93LndhbGxfZ2hvc3RfcmlnaHQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke3dhbGxGb3JTaG93LnVybH0pYFxuICAgIH0sIDUwMClcbn1cbiIsImNvbnN0IHdhdmVyID0ge31cblxud2F2ZXIuYWRkID0gKHgsIHkpID0+IHtcbiAgICB3aW5kb3cud2F2ZV9jbGlja19ib3guaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJ3YXZlIGFjdGl2ZVwiIHN0eWxlPVwidHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpXCI+XG4gICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDxkaXY+PC9kaXY+XG4gICAgPC9kaXY+YFxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIChldmVudCkgPT4ge1xuICAgIHdhdmVyLmFkZChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKVxufSlcblxuZXhwb3J0IGRlZmF1bHQgd2F2ZXIiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0ICcuL3Byb3RvdHlwZSdcbmltcG9ydCAnLi93YWxscGFwZXInXG5cbmltcG9ydCBldmVudCBmcm9tICcuL2NvcmUvZXZlbnQnXG5pbXBvcnQgZW1pdHRlciBmcm9tICcuL2NvcmUvZW1pdHRlcidcbmltcG9ydCBzdG9yYWdlIGZyb20gJy4vY29yZS9zdG9yYWdlJ1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2NvcmUvbG9nZ2VyJ1xuaW1wb3J0IG5vdGVyIGZyb20gJy4vbm90ZXInXG5pbXBvcnQgYm9va21hcmsgZnJvbSAnLi9ib29rbWFyaydcbmltcG9ydCB3YXZlciBmcm9tICcuL3dhdmVyJ1xuaW1wb3J0IHNldHRpbmcgZnJvbSAnLi9zZXR0aW5nJ1xuXG53aW5kb3cuY29uZmlnID0gc3RvcmFnZS5jb25maWcgfHwge1xuICAgIGxvZ19sZXZlbDogJ2RlYnVnJyxcbn1cblxud2luZG93LmhvbGRlciA9IHtcbiAgICB3X3c6IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgd19oOiB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxcblxuICAgIGNvZGVfdGFibGVzOiBbXG4gICAgICAgIHsgY29kZTogJ2RhdGU9PScsIHZhbHVlOiBuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpIH0sXG4gICAgICAgIHsgY29kZTogJ3RpbWU9PScsIHZhbHVlOiBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpIH0sXG4gICAgICAgIHsgY29kZTogJ25vdz09JywgdmFsdWU6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSB9LFxuICAgICAgICAvLyB7IGNvZGU6ICduYW1lXyguKz8pJywgdmFsdWU6ICdIaSBzaXIsICQgPDMnIH0sXG4gICAgXSxcbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHtcbiAgICBob2xkZXIud193ID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuICAgIGhvbGRlci53X2ggPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxufSlcblxuZW1pdHRlci5jbGljaygpXG5cbmxvZ2dlci5sb2dfbGV2ZWwgPSBjb25maWcubG9nX2xldmVsXG53aW5kb3cuYnRuX3N3aXRjaF93b3Jrc3BhY2UuaW5uZXJIVE1MID0gc3RvcmFnZS53b3Jrc3BhY2UgfHwgMFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9